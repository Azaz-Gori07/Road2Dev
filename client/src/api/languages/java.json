{
  "technology": "Java",
  "slug": "java-phase-1-foundations",
  "description": "Java Programming ka complete beginner course - Setup, Syntax aur Control Flow",
  "levels": [
    {
      "level": "Beginner",
      "order": 1,
      "description": "Java Introduction, Installation aur First Programs",
      "topics": [
        {
          "id": 1,
          "title": "Java Introduction aur Setup",
          "english": "Complete Java introduction and setup guide",
          "hinglish": "Java ka poora parichay aur setup",
          "examples": [
            "// Hello World Program\npublic class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello Java!\");\n    }\n}"
          ],
          "practice": [
            {
              "question": "Java ka sabse important feature kya hai?",
              "answer": "Platform Independence - Write Once, Run Anywhere"
            },
            {
              "question": "JVM, JRE, JDK mein kya antar hai?",
              "answer": "JDK=Development Tools, JRE=Runtime, JVM=Bytecode Execution"
            },
            {
              "question": "Java program compile aur run karne ke commands?",
              "answer": "javac File.java (compile), java ClassName (run)"
            },
            {
              "question": "main() method kyun zaroori hai?",
              "answer": "Ye program ka entry point (starting point) hota hai"
            }
          ],
          "detailed_explanation": {
            "example_code": "",
            "components": [
              {
                "name": "Java Setup",
                "english": "Complete installation and configuration",
                "hinglish": "Poori installation aur configuration",
                "importance": "High",
                "tip": "Always set PATH variable correctly",
                "role": "Development environment setup",
                "pros": "Once setup, easy to use",
                "cons": "Initial setup time required",
                "example": "JDK install → PATH set → IDE install",
                "use_case": "Every Java developer needs this"
              }
            ],
            "comparison_table": {
              "headers": ["Tool", "Purpose", "Required For"],
              "rows": [
                ["JDK", "Development", "Writing Java programs"],
                ["JRE", "Runtime", "Running Java programs"],
                ["IDE", "Coding", "Efficient development"]
              ]
            },
            "decision_table": {
              "headers": ["Task", "Solution"],
              "rows": [
                ["Learn Java", "Install JDK + VS Code"],
                ["Professional Work", "JDK + IntelliJ/Eclipse"],
                ["Just Run Apps", "JRE sufficient"]
              ]
            },
            "best_practices": [
              {
                "practice": "Class name and file name same rakhein",
                "reason": "Java compilation requirement",
                "hinglish": "Class aur file ka naam same rakho"
              }
            ]
          }
        },
        {
          "id": 2,
          "title": "Variables aur Data Types",
          "english": "Variables, data types and declarations",
          "hinglish": "Variables, data types aur unki declaration",
          "examples": [
            "int age = 25;\ndouble salary = 50000.50;\nchar grade = 'A';\nboolean isJavaFun = true;"
          ],
          "practice": [
            {
              "question": "Primitive data types kitne hote hain?",
              "answer": "8: byte, short, int, long, float, double, char, boolean"
            },
            {
              "question": "int aur double mein kya antar hai?",
              "answer": "int integer values, double decimal values"
            },
            {
              "question": "Variable declare karne ka syntax?",
              "answer": "dataType variableName = value;"
            },
            {
              "question": "Constant variable kaise banate hain?",
              "answer": "final keyword use karke: final int MAX = 100;"
            }
          ],
          "detailed_explanation": {
            "example_code": "public class VariablesExample {\n    public static void main(String[] args) {\n        // Primitive variables\n        int age = 25;\n        double price = 99.99;\n        char letter = 'A';\n        bool flag = true;\n        \n        // Reference variable\n        String name = \"John\";\n        \n        // Constant\n        final double PI = 3.14;\n        \n        System.out.println(\"Age: \" + age);\n        System.out.println(\"PI: \" + PI);\n    }\n}",
            "components": [
              {
                "name": "Primitive Data Types",
                "english": "Basic built-in data types",
                "hinglish": "Basic built-in data types",
                "importance": "High",
                "tip": "int most common, use double for decimals",
                "role": "Store simple values",
                "pros": "Fast, memory efficient",
                "cons": "Limited functionality",
                "example": "int, double, char, boolean",
                "use_case": "Numbers, characters, true/false"
              }
            ],
            "comparison_table": {
              "headers": ["Type", "Size", "Range", "Example"],
              "rows": [
                ["byte", "1 byte", "-128 to 127", "byte b = 100"],
                ["int", "4 bytes", "-2B to 2B", "int x = 1000"],
                ["double", "8 bytes", "Decimal values", "double d = 10.5"],
                ["boolean", "1 bit", "true/false", "bool flag = true"]
              ]
            },
            "decision_table": {
              "headers": ["Data to Store", "Use Data Type"],
              "rows": [
                ["Small integers", "byte or short"],
                ["Normal integers", "int"],
                ["Large integers", "long"],
                ["Decimals", "double"],
                ["Single character", "char"],
                ["True/False", "boolean"]
              ]
            },
            "best_practices": [
              {
                "practice": "Meaningful variable names use karein",
                "reason": "Code readability improves",
                "hinglish": "Variables ka meaningful naam rakho"
              }
            ]
          }
        },
        {
          "id": 3,
          "title": "Operators in Java",
          "english": "All types of operators in Java",
          "hinglish": "Java mein sabhi prakar ke operators",
          "examples": [
            "int sum = 10 + 5;  // Arithmetic\nboolean result = (10 > 5);  // Relational\nif(a && b) { }  // Logical\nint max = (a > b) ? a : b;  // Ternary"
          ],
          "practice": [
            {
              "question": "Arithmetic operators konse hote hain?",
              "answer": "+ - * / % (addition, subtraction, multiplication, division, modulus)"
            },
            {
              "question": "== aur = mein kya antar hai?",
              "answer": "== comparison karta hai, = assignment karta hai"
            },
            {
              "question": "Ternary operator ka syntax?",
              "answer": "condition ? value1 : value2"
            },
            {
              "question": "&& aur || mein kya antar hai?",
              "answer": "&& (AND) - dono true, || (OR) - koi ek true"
            }
          ],
          "detailed_explanation": {
            "example_code": "public class OperatorsExample {\n    public static void main(String[] args) {\n        int a = 10, b = 5;\n        \n        // Arithmetic\n        int sum = a + b;\n        int mod = a % b;\n        \n        // Relational\n        boolean isGreater = a > b;\n        \n        // Logical\n        boolean result = (a > 0) && (b > 0);\n        \n        // Ternary\n        int max = (a > b) ? a : b;\n        \n        // Assignment\n        a += 5;  // a = a + 5\n        \n        System.out.println(\"Sum: \" + sum);\n        System.out.println(\"Max: \" + max);\n    }\n}",
            "components": [
              {
                "name": "Operator Types",
                "english": "Different categories of operators",
                "hinglish": "Operators ke alag-alag categories",
                "importance": "High",
                "tip": "Learn operator precedence",
                "role": "Perform operations on operands",
                "pros": "Make code concise",
                "cons": "Complex expressions confusing",
                "example": "Arithmetic, Relational, Logical",
                "use_case": "Calculations, comparisons, conditions"
              }
            ],
            "comparison_table": {
              "headers": ["Operator Type", "Symbols", "Purpose"],
              "rows": [
                ["Arithmetic", "+ - * / %", "Mathematical calculations"],
                ["Relational", "> < == != >= <=", "Comparisons"],
                ["Logical", "&& || !", "Boolean operations"],
                ["Assignment", "= += -= *= /=", "Assign values"],
                ["Ternary", "?:", "Short if-else"]
              ]
            },
            "decision_table": {
              "headers": ["Need", "Use Operator"],
              "rows": [
                ["Add/Subtract", "+ -"],
                ["Compare values", "== != > <"],
                ["Multiple conditions", "&& ||"],
                ["Quick if-else", "?:"],
                ["Check type", "instanceof"]
              ]
            },
            "best_practices": [
              {
                "practice": "Complex expressions ke liye parentheses use karein",
                "reason": "Precedence clear rahe",
                "hinglish": "Complex expressions mein parentheses zaroor use karo"
              }
            ]
          }
        },
        {
          "id": 4,
          "title": "Type Casting aur Input",
          "english": "Type conversion and user input",
          "hinglish": "Type conversion aur user input",
          "examples": [
            "// Type Casting\nint num = (int) 10.5;\n\n// Scanner Input\nScanner sc = new Scanner(System.in);\nint n = sc.nextInt();"
          ],
          "practice": [
            {
              "question": "Widening casting aur narrowing casting mein antar?",
              "answer": "Widening: automatic (int to double), Narrowing: manual (double to int)"
            },
            {
              "question": "Scanner class import kaise karte hain?",
              "answer": "import java.util.Scanner;"
            },
            {
              "question": "User se string input kaise lein?",
              "answer": "sc.nextLine() method use karke"
            },
            {
              "question": "Type casting mein data loss kab hota hai?",
              "answer": "Narrowing casting mein (double to int)"
            }
          ],
          "detailed_explanation": {
            "example_code": "import java.util.Scanner;\n\npublic class InputExample {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Get integer input\n        System.out.print(\"Enter age: \");\n        int age = sc.nextInt();\n        \n        // Get string input\n        sc.nextLine();  // Clear buffer\n        System.out.print(\"Enter name: \");\n        String name = sc.nextLine();\n        \n        // Type casting\n        double price = 99.99;\n        int intPrice = (int) price;  // Narrowing\n        \n        System.out.println(\"Name: \" + name + \", Age: \" + age);\n        System.out.println(\"Price (int): \" + intPrice);\n        \n        sc.close();\n    }\n}",
            "components": [
              {
                "name": "Scanner Class",
                "english": "Get user input from console",
                "hinglish": "Console se user input lena",
                "importance": "Medium",
                "tip": "Always close scanner after use",
                "role": "Interactive programs banane ke liye",
                "pros": "Easy to use, different data types",
                "cons": "Buffer issues with nextLine()",
                "example": "nextInt(), nextDouble(), nextLine()",
                "use_case": "User input wale programs"
              }
            ],
            "comparison_table": {
              "headers": ["Conversion", "Type", "Example"],
              "rows": [
                ["Widening", "Automatic", "int → double"],
                ["Narrowing", "Manual", "double → int"],
                ["String to int", "Parse", "Integer.parseInt()"],
                ["int to String", "Convert", "String.valueOf()"]
              ]
            },
            "decision_table": {
              "headers": ["Situation", "Approach"],
              "rows": [
                ["Small to large type", "Automatic (Widening)"],
                ["Large to small type", "Manual cast (Narrowing)"],
                ["Get user input", "Use Scanner class"],
                ["String to number", "Use parse methods"]
              ]
            },
            "best_practices": [
              {
                "practice": "Scanner close() method call karein",
                "reason": "Resource leak se bachne ke liye",
                "hinglish": "Scanner use karne ke baad close() zaroor call karo"
              }
            ]
          }
        },
        {
          "id": 5,
          "title": "Control Flow - If-else aur Switch",
          "english": "Decision making statements",
          "hinglish": "Decision making statements",
          "examples": [
            "// If-else\nif(age >= 18) {\n    System.out.println(\"Adult\");\n} else {\n    System.out.println(\"Minor\");\n}\n\n// Switch\nswitch(day) {\n    case 1: System.out.println(\"Monday\"); break;\n    default: System.out.println(\"Invalid\");\n}"
          ],
          "practice": [
            {
              "question": "if-else statement ka use kab karte hain?",
              "answer": "Jab 2 ya 3 conditions check karni ho"
            },
            {
              "question": "Switch statement mein default case zaroori hai?",
              "answer": "Nahi, optional hai lekin recommended hai"
            },
            {
              "question": "Enhanced switch kya hota hai?",
              "answer": "Java 14+ feature, arrow syntax, multiple values"
            },
            {
              "question": "Nested if-else kya hota hai?",
              "answer": "if ke andar if statement"
            }
          ],
          "detailed_explanation": {
            "example_code": "public class ControlFlow {\n    public static void main(String[] args) {\n        int marks = 85;\n        \n        // If-else-if ladder\n        if(marks >= 90) {\n            System.out.println(\"Grade A\");\n        } else if(marks >= 75) {\n            System.out.println(\"Grade B\");\n        } else if(marks >= 50) {\n            System.out.println(\"Grade C\");\n        } else {\n            System.out.println(\"Fail\");\n        }\n        \n        // Switch statement\n        int day = 3;\n        switch(day) {\n            case 1:\n                System.out.println(\"Monday\");\n                break;\n            case 2:\n                System.out.println(\"Tuesday\");\n                break;\n            default:\n                System.out.println(\"Other day\");\n        }\n    }\n}",
            "components": [
              {
                "name": "If-else Statement",
                "english": "Conditional branching",
                "hinglish": "Conditions ke hisab se code run karna",
                "importance": "High",
                "tip": "Always use braces {} for clarity",
                "role": "Decision making in code",
                "pros": "Flexible, any condition",
                "cons": "Complex for many conditions",
                "example": "if(condition) { } else { }",
                "use_case": "Multiple condition checking"
              }
            ],
            "comparison_table": {
              "headers": ["Statement", "Best For", "Limitations"],
              "rows": [
                ["if-else", "2-3 conditions", "Complex for many"],
                ["switch", "Single variable", "Only equality check"],
                ["if-else-if", "Multiple ranges", "Readability issues"],
                ["ternary", "Simple conditions", "Only one expression"]
              ]
            },
            "decision_table": {
              "headers": ["Condition Type", "Use"],
              "rows": [
                ["Range checking", "if-else"],
                ["Exact value match", "switch"],
                ["Simple true/false", "ternary operator"],
                ["Multiple variables", "if-else"]
              ]
            },
            "best_practices": [
              {
                "practice": "Switch mein break statement zaroor use karein",
                "reason": "Fall-through se bachne ke liye",
                "hinglish": "Switch mein break statement mat bhoolo"
              }
            ]
          }
        },
        {
          "id": 6,
          "title": "Loops in Java",
          "english": "Different types of loops for repetition",
          "hinglish": "Repetition ke liye alag-alag loops",
          "examples": [
            "// For loop\nfor(int i=1; i<=10; i++) {\n    System.out.println(i);\n}\n\n// While loop\nwhile(condition) {\n    // code\n}\n\n// For-each loop\nfor(String name : names) {\n    System.out.println(name);\n}"
          ],
          "practice": [
            {
              "question": "For loop ke 3 parts kya hote hain?",
              "answer": "Initialization, Condition, Increment/Decrement"
            },
            {
              "question": "While aur do-while mein kya antar hai?",
              "answer": "While: pehle condition check, do-while: pehle execution phir check"
            },
            {
              "question": "Enhanced for loop ka use kab karte hain?",
              "answer": "Arrays ya Collections traverse karne ke liye"
            },
            {
              "question": "break aur continue statement ka use?",
              "answer": "break: loop se bahar, continue: current iteration skip"
            }
          ],
          "detailed_explanation": {
            "example_code": "public class LoopsExample {\n    public static void main(String[] args) {\n        // For loop - print 1 to 5\n        for(int i = 1; i <= 5; i++) {\n            System.out.print(i + \" \");\n        }\n        System.out.println();\n        \n        // While loop\n        int count = 1;\n        while(count <= 3) {\n            System.out.println(\"Count: \" + count);\n            count++;\n        }\n        \n        // Do-while loop\n        int x = 1;\n        do {\n            System.out.println(\"x: \" + x);\n            x++;\n        } while(x <= 3);\n        \n        // For-each loop\n        String[] fruits = {\"Apple\", \"Banana\", \"Mango\"};\n        for(String fruit : fruits) {\n            System.out.println(fruit);\n        }\n    }\n}",
            "components": [
              {
                "name": "Loop Types",
                "english": "Different repetition structures",
                "hinglish": "Alag-alag repetition structures",
                "importance": "High",
                "tip": "For loop when iterations known, while when unknown",
                "role": "Code repetition control",
                "pros": "Automate repetitive tasks",
                "cons": "Infinite loop risk",
                "example": "for, while, do-while, for-each",
                "use_case": "Iterating arrays, processing data"
              }
            ],
            "comparison_table": {
              "headers": ["Loop", "When to Use", "Example"],
              "rows": [
                ["for", "Iterations known", "Print 1 to 10"],
                ["while", "Condition based", "Read until end"],
                ["do-while", "At least once", "Menu display"],
                ["for-each", "Collections/Arrays", "Process all items"]
              ]
            },
            "decision_table": {
              "headers": ["Requirement", "Choose Loop"],
              "rows": [
                ["Fixed iterations", "for loop"],
                ["Condition based", "while loop"],
                ["Run at least once", "do-while"],
                ["All elements process", "for-each"],
                ["Early exit needed", "break statement"]
              ]
            },
            "best_practices": [
              {
                "practice": "Infinite loop se bachne ke liye condition update zaroor karein",
                "reason": "Program hang na ho",
                "hinglish": "Loop ke andar condition update karte raho"
              }
            ]
          }
        },
        {
          "id": 7,
          "title": "Command Line Arguments",
          "english": "Passing arguments to Java program",
          "hinglish": "Java program mein arguments pass karna",
          "examples": [
            "// Run: java MyProgram arg1 arg2 arg3\n// In main method:\n// args[0] = \"arg1\", args[1] = \"arg2\""
          ],
          "practice": [
            {
              "question": "Command line arguments kya hote hain?",
              "answer": "Program run karte time diye gaye values"
            },
            {
              "question": "Command line arguments kaise access karte hain?",
              "answer": "main method ke String[] args array se"
            },
            {
              "question": "Arguments kitne pass kiye ja sakte hain?",
              "answer": "Unlimited, space separated"
            },
            {
              "question": "Arguments ka data type kya hota hai?",
              "answer": "Sab string hote hain, convert karna padta hai"
            }
          ],
          "detailed_explanation": {
            "example_code": "public class CommandLineArgs {\n    public static void main(String[] args) {\n        // Check if arguments passed\n        if(args.length == 0) {\n            System.out.println(\"No arguments provided\");\n            return;\n        }\n        \n        // Print all arguments\n        System.out.println(\"Number of arguments: \" + args.length);\n        \n        for(int i = 0; i < args.length; i++) {\n            System.out.println(\"Argument \" + i + \": \" + args[i]);\n        }\n        \n        // Use arguments\n        if(args.length >= 2) {\n            String name = args[0];\n            int age = Integer.parseInt(args[1]);\n            System.out.println(\"Name: \" + name + \", Age: \" + age);\n        }\n    }\n}",
            "components": [
              {
                "name": "args array",
                "english": "String array containing command line arguments",
                "hinglish": "Command line arguments wala string array",
                "importance": "Medium",
                "tip": "Always check args.length before accessing",
                "role": "Program ko external input dena",
                "pros": "No Scanner needed, direct input",
                "cons": "Only strings, compile-run needed",
                "example": "java MyApp John 25",
                "use_case": "Quick testing, batch processing"
              }
            ],
            "comparison_table": {
              "headers": ["Input Method", "When to Use", "Limitation"],
              "rows": [
                ["Command Line Args", "One-time input", "Only at startup"],
                ["Scanner", "Interactive", "User interaction"],
                ["Configuration File", "Multiple settings", "File handling needed"]
              ]
            },
            "decision_table": {
              "headers": ["Scenario", "Input Method"],
              "rows": [
                ["Quick test values", "Command Line Args"],
                ["User interaction", "Scanner"],
                ["Multiple inputs", "Scanner or File"],
                ["Batch processing", "Command Line Args"]
              ]
            },
            "best_practices": [
              {
                "practice": "Pehle args.length check karein",
                "reason": "ArrayIndexOutOfBoundsException se bachne ke liye",
                "hinglish": "Args array access karne se pehle length check karo"
              }
            ]
          }
        }
      ]
    },
    {
      "level": "Intermediate",
      "order": 2,
      "description": "Classes, Objects, OOP Principles aur Advanced Concepts",
      "topics": [
        {
          "id": 1,
          "title": "Classes aur Objects",
          "english": "Creating classes and objects in Java",
          "hinglish": "Java mein classes aur objects banana",
          "examples": [
            "// Class definition\nclass Student {\n    String name;\n    int age;\n    \n    // Constructor\n    Student(String n, int a) {\n        this.name = n;\n        this.age = a;\n    }\n    \n    // Method\n    void display() {\n        System.out.println(name + \" - \" + age);\n    }\n}"
          ],
          "practice": [
            {
              "question": "Class aur Object mein kya antar hai?",
              "answer": "Class blueprint hai, Object uska actual instance hai"
            },
            {
              "question": "Constructor kya hota hai aur kaise banate hain?",
              "answer": "Constructor object initialize karta hai, class ke naam se hi banata hai"
            },
            {
              "question": "'this' keyword ka use kyun karte hain?",
              "answer": "Current object refer karne ke liye, variable name conflict solve karne ke liye"
            },
            {
              "question": "Static method aur instance method mein kya antar hai?",
              "answer": "Static: class level, instance: object level"
            }
          ],
          "detailed_explanation": {
            "example_code": "public class Car {\n    // Instance variables\n    String model;\n    double price;\n    \n    // Default constructor\n    Car() {\n        model = \"Unknown\";\n        price = 0.0;\n    }\n    \n    // Parameterized constructor\n    Car(String model, double price) {\n        this.model = model;\n        this.price = price;\n    }\n    \n    // Copy constructor\n    Car(Car other) {\n        this.model = other.model;\n        this.price = other.price;\n    }\n    \n    // Instance method\n    void display() {\n        System.out.println(model + \": ₹\" + price);\n    }\n    \n    // Static method\n    static void companyInfo() {\n        System.out.println(\"Car Manufacturer\");\n    }\n}\n\n// Usage\nclass Main {\n    public static void main(String[] args) {\n        Car car1 = new Car();  // Default constructor\n        Car car2 = new Car(\"Swift\", 800000);  // Parameterized\n        Car car3 = new Car(car2);  // Copy constructor\n        \n        car2.display();\n        Car.companyInfo();  // Static method call\n    }\n}",
            "components": [
              {
                "name": "Constructor",
                "english": "Special method to initialize objects",
                "hinglish": "Objects initialize karne wala special method",
                "importance": "High",
                "tip": "Constructor ka naam class ke naam se match karna chahiye",
                "role": "Object creation time initialization",
                "pros": "Automatic initialization, multiple types",
                "cons": "Default constructor lost when custom defined",
                "example": "ClassName() { } or ClassName(params) { }",
                "use_case": "Har class mein object setup ke liye"
              }
            ],
            "comparison_table": {
              "headers": ["Constructor Type", "When Called", "Use Case"],
              "rows": [
                ["Default", "No arguments", "Default values set"],
                ["Parameterized", "With arguments", "Custom initialization"],
                ["Copy", "Another object", "Duplicate object create"]
              ]
            },
            "decision_table": {
              "headers": ["Situation", "Use Constructor"],
              "rows": [
                ["Simple object", "Default constructor"],
                ["Custom values", "Parameterized constructor"],
                ["Duplicate object", "Copy constructor"],
                ["Multiple ways", "Constructor overloading"]
              ]
            },
            "best_practices": [
              {
                "practice": "Getter-setter methods ke through hi variables access karein",
                "reason": "Encapsulation maintain rahega",
                "hinglish": "Variables direct access na karke getter-setter use karo"
              }
            ]
          }
        },
        {
          "id": 2,
          "title": "Method Overloading aur Nested Classes",
          "english": "Method overloading and nested/inner classes",
          "hinglish": "Method overloading aur nested/inner classes",
          "examples": [
            "// Method overloading\nclass Calculator {\n    int add(int a, int b) { return a+b; }\n    double add(double a, double b) { return a+b; }\n    int add(int a, int b, int c) { return a+b+c; }\n}\n\n// Inner class\nclass Outer {\n    class Inner {\n        void show() { System.out.println(\"Inner\"); }\n    }\n}"
          ],
          "practice": [
            {
              "question": "Method overloading kya hai?",
              "answer": "Same naam ke methods with different parameters"
            },
            {
              "question": "Method overloading ke rules kya hain?",
              "answer": "Method name same, parameters different (type/count/order)"
            },
            {
              "question": "Nested class kitne types ki hoti hai?",
              "answer": "Static nested class aur non-static inner class"
            },
            {
              "question": "Inner class outer class ki private members access kar sakti hai?",
              "answer": "Haan, inner class outer class ke sab members access kar sakti hai"
            }
          ],
          "detailed_explanation": {
            "example_code": "// Method Overloading Example\nclass MathOperations {\n    // Different parameter types\n    int multiply(int a, int b) {\n        return a * b;\n    }\n    \n    double multiply(double a, double b) {\n        return a * b;\n    }\n    \n    // Different parameter count\n    int multiply(int a, int b, int c) {\n        return a * b * c;\n    }\n    \n    // Different parameter order (not recommended)\n    void print(String msg, int times) {\n        for(int i=0; i<times; i++) System.out.println(msg);\n    }\n    \n    void print(int times, String msg) {\n        for(int i=0; i<times; i++) System.out.println(msg);\n    }\n}\n\n// Nested Classes Example\nclass University {\n    String name = \"ABC University\";\n    \n    // Static Nested Class\n    static class Department {\n        void show() {\n            System.out.println(\"Department Info\");\n        }\n    }\n    \n    // Non-static Inner Class\n    class Student {\n        void display() {\n            System.out.println(\"University: \" + name);  // Can access outer members\n        }\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // Method overloading usage\n        MathOperations math = new MathOperations();\n        System.out.println(math.multiply(5, 3));\n        System.out.println(math.multiply(2.5, 4.0));\n        \n        // Nested class usage\n        University.Department dept = new University.Department();  // Static nested\n        dept.show();\n        \n        University uni = new University();\n        University.Student student = uni.new Student();  // Inner class\n        student.display();\n    }\n}",
            "components": [
              {
                "name": "Method Overloading",
                "english": "Multiple methods with same name but different parameters",
                "hinglish": "Same naam ke methods with different parameters",
                "importance": "High",
                "tip": "Return type different se overloading nahi hota",
                "role": "Same functionality for different inputs",
                "pros": "Clean API, intuitive naming",
                "cons": "Confusing if overused",
                "example": "print(int), print(String), print(double)",
                "use_case": "Same operation different data types"
              }
            ],
            "comparison_table": {
              "headers": ["Feature", "Method Overloading", "Method Overriding"],
              "rows": [
                ["Purpose", "Same class mein multiple versions", "Inheritance mein parent method modify"],
                ["Parameters", "Different hona chahiye", "Same hone chahiye"],
                ["Return Type", "Can be different", "Same or covariant"],
                ["Binding", "Compile-time", "Runtime"]
              ]
            },
            "decision_table": {
              "headers": ["Requirement", "Solution"],
              "rows": [
                ["Different inputs same operation", "Method Overloading"],
                ["Related class within class", "Nested/Inner Class"],
                ["Only grouping needed", "Static Nested Class"],
                ["Access outer class members", "Non-static Inner Class"]
              ]
            },
            "best_practices": [
              {
                "practice": "Overloaded methods similar functionality rakhein",
                "reason": "User confusion nahi honi chahiye",
                "hinglish": "Overloaded methods ka functionality similar rakho"
              }
            ]
          }
        },
        {
          "id": 3,
          "title": "Encapsulation",
          "english": "Data hiding using encapsulation",
          "hinglish": "Encapsulation ka use karke data hiding",
          "examples": [
            "class BankAccount {\n    private double balance;  // Data hiding\n    \n    public double getBalance() { return balance; }\n    public void deposit(double amount) {\n        if(amount > 0) balance += amount;\n    }\n}"
          ],
          "practice": [
            {
              "question": "Encapsulation kya hai?",
              "answer": "Data aur methods ek unit mein band karna, data hiding"
            },
            {
              "question": "Getter aur setter methods kyun use karte hain?",
              "answer": "Control maintain karne ke liye, validation ke liye"
            },
            {
              "question": "Private variable ko dusri class se kaise access karte hain?",
              "answer": "Public getter-setter methods ke through"
            },
            {
              "question": "Encapsulation ke fayde?",
              "answer": "Security, flexibility, maintainability"
            }
          ],
          "detailed_explanation": {
            "example_code": "public class Employee {\n    // Private data members (encapsulated)\n    private String name;\n    private int age;\n    private double salary;\n    \n    // Public getter methods\n    public String getName() {\n        return name;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n    \n    // Public setter methods with validation\n    public void setName(String name) {\n        if(name != null && !name.trim().isEmpty()) {\n            this.name = name;\n        }\n    }\n    \n    public void setAge(int age) {\n        if(age >= 18 && age <= 60) {  // Validation\n            this.age = age;\n        } else {\n            System.out.println(\"Invalid age!\");\n        }\n    }\n    \n    public void setSalary(double salary) {\n        if(salary >= 0) {\n            this.salary = salary;\n        }\n    }\n    \n    // Business logic method\n    public void giveBonus(double percentage) {\n        if(percentage > 0 && percentage <= 50) {\n            this.salary += this.salary * (percentage/100);\n        }\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        Employee emp = new Employee();\n        \n        // Using setters (with validation)\n        emp.setName(\"Rahul\");\n        emp.setAge(25);\n        emp.setSalary(50000);\n        \n        // Using getters\n        System.out.println(\"Name: \" + emp.getName());\n        System.out.println(\"Age: \" + emp.getAge());\n        \n        // Business method\n        emp.giveBonus(10);\n        \n        // Direct access not allowed (compilation error)\n        // emp.salary = 100000;  // Error: private member\n    }\n}",
            "components": [
              {
                "name": "Getter-Setter Methods",
                "english": "Public methods to access private data",
                "hinglish": "Private data access karne ke liye public methods",
                "importance": "High",
                "tip": "Always validate data in setters",
                "role": "Controlled access to data",
                "pros": "Security, validation, flexibility",
                "cons": "More code to write",
                "example": "getName(), setAge(int age)",
                "use_case": "Har class jisme data hiding chahiye"
              }
            ],
            "comparison_table": {
              "headers": ["Access Type", "Within Class", "Outside Class", "Inherited Class"],
              "rows": [
                ["public", "✓", "✓", "✓"],
                ["private", "✓", "✗", "✗"],
                ["protected", "✓", "✗", "✓"],
                ["default", "✓", "Same package", "Same package"]
              ]
            },
            "decision_table": {
              "headers": ["Data Type", "Access Modifier"],
              "rows": [
                ["Internal implementation", "private"],
                ["API methods", "public"],
                ["For subclass access", "protected"],
                ["Package-level sharing", "default"]
              ]
            },
            "best_practices": [
              {
                "practice": "Variable ko private rakhein aur getter-setter public",
                "reason": "Maximum encapsulation achieve karne ke liye",
                "hinglish": "Variables private rakho, getter-setter public rakho"
              }
            ]
          }
        },
        {
          "id": 4,
          "title": "Inheritance",
          "english": "Creating class hierarchies using inheritance",
          "hinglish": "Inheritance ka use karke class hierarchies banana",
          "examples": [
            "// Parent class\nclass Vehicle {\n    void start() { System.out.println(\"Vehicle starting\"); }\n}\n\n// Child class\nclass Car extends Vehicle {\n    @Override\n    void start() { System.out.println(\"Car starting\"); }\n}"
          ],
          "practice": [
            {
              "question": "Inheritance ke types konse hain?",
              "answer": "Single, Multilevel, Hierarchical, Hybrid, Multiple (interface through)"
            },
            {
              "question": "super keyword ka use kya hai?",
              "answer": "Parent class ke members access karne ke liye"
            },
            {
              "question": "Method overriding kya hoti hai?",
              "answer": "Child class mein parent class ke method ko modify karna"
            },
            {
              "question": "final keyword inheritance mein kya karta hai?",
              "answer": "final class: inherit nahi kar sakte, final method: override nahi kar sakte"
            }
          ],
          "detailed_explanation": {
            "example_code": "// Single Inheritance\nclass Animal {\n    String name;\n    \n    void eat() {\n        System.out.println(name + \" is eating\");\n    }\n}\n\nclass Dog extends Animal {\n    void bark() {\n        System.out.println(name + \" is barking\");\n    }\n}\n\n// Multilevel Inheritance\nclass Vehicle {\n    void start() {\n        System.out.println(\"Vehicle starting\");\n    }\n}\n\nclass Car extends Vehicle {\n    @Override\n    void start() {\n        super.start();  // Calling parent method\n        System.out.println(\"Car specific start\");\n    }\n}\n\nclass SportsCar extends Car {\n    void turboBoost() {\n        System.out.println(\"Turbo boost engaged!\");\n    }\n}\n\n// Hierarchical Inheritance\nclass Shape {\n    void draw() {\n        System.out.println(\"Drawing shape\");\n    }\n}\n\nclass Circle extends Shape {\n    @Override\n    void draw() {\n        System.out.println(\"Drawing circle\");\n    }\n}\n\nclass Square extends Shape {\n    @Override\n    void draw() {\n        System.out.println(\"Drawing square\");\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // Single inheritance\n        Dog dog = new Dog();\n        dog.name = \"Buddy\";\n        dog.eat();  // Inherited method\n        dog.bark(); // Own method\n        \n        // Multilevel inheritance\n        SportsCar car = new SportsCar();\n        car.start();  // From Car class\n        car.turboBoost();\n        \n        // Hierarchical inheritance\n        Shape s1 = new Circle();\n        Shape s2 = new Square();\n        s1.draw();  // Drawing circle\n        s2.draw();  // Drawing square\n    }\n}",
            "components": [
              {
                "name": "extends Keyword",
                "english": "Creates inheritance relationship",
                "hinglish": "Inheritance relationship banata hai",
                "importance": "High",
                "tip": "Java supports only single class inheritance",
                "role": "Parent-child class relationship",
                "pros": "Code reuse, polymorphism",
                "cons": "Tight coupling, fragile base class",
                "example": "class Child extends Parent",
                "use_case": "IS-A relationship (Car IS-A Vehicle)"
              }
            ],
            "comparison_table": {
              "headers": ["Inheritance Type", "Structure", "Example"],
              "rows": [
                ["Single", "A ← B", "Vehicle ← Car"],
                ["Multilevel", "A ← B ← C", "Vehicle ← Car ← SportsCar"],
                ["Hierarchical", "A ← B, A ← C", "Shape ← Circle, Shape ← Square"]
              ]
            },
            "decision_table": {
              "headers": ["Relationship", "Use Inheritance"],
              "rows": [
                ["IS-A relationship", "Yes (Car IS-A Vehicle)"],
                ["Code reuse needed", "Yes"],
                ["Multiple behaviors needed", "Use Interfaces"],
                ["Tight coupling acceptable", "Yes"]
              ]
            },
            "best_practices": [
              {
                "practice": "@Override annotation zaroor use karein",
                "reason": "Compile-time checking ke liye",
                "hinglish": "Method override karte time @Override annotation use karo"
              }
            ]
          }
        },
        {
          "id": 5,
          "title": "Polymorphism",
          "english": "Compile-time and runtime polymorphism",
          "hinglish": "Compile-time aur runtime polymorphism",
          "examples": [
            "// Compile-time (Overloading)\nvoid print(int a) { }\nvoid print(String s) { }\n\n// Runtime (Overriding)\nclass Parent { void show() { } }\nclass Child extends Parent { \n    @Override\n    void show() { } \n}"
          ],
          "practice": [
            {
              "question": "Polymorphism ke do types konse hain?",
              "answer": "Compile-time (method overloading) aur Runtime (method overriding)"
            },
            {
              "question": "Dynamic Method Dispatch kya hai?",
              "answer": "Runtime par decide hona ki konsa method call hoga"
            },
            {
              "question": "Parent reference se child object kaise banate hain?",
              "answer": "Parent p = new Child();"
            },
            {
              "question": "Runtime polymorphism ka example do",
              "answer": "Animal a = new Dog(); a.sound(); // Dog ka sound"
            }
          ],
          "detailed_explanation": {
            "example_code": "// Compile-time Polymorphism (Method Overloading)\nclass Calculator {\n    // Same method name, different parameters\n    int add(int a, int b) {\n        return a + b;\n    }\n    \n    double add(double a, double b) {\n        return a + b;\n    }\n    \n    String add(String a, String b) {\n        return a + b;\n    }\n}\n\n// Runtime Polymorphism (Method Overriding)\nclass Bank {\n    double getInterestRate() {\n        return 5.0;  // Base interest rate\n    }\n}\n\nclass SBI extends Bank {\n    @Override\n    double getInterestRate() {\n        return 6.5;  // SBI specific rate\n    }\n}\n\nclass HDFC extends Bank {\n    @Override\n    double getInterestRate() {\n        return 7.0;  // HDFC specific rate\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // Compile-time polymorphism\n        Calculator calc = new Calculator();\n        System.out.println(calc.add(5, 3));      // int version\n        System.out.println(calc.add(2.5, 3.5));  // double version\n        System.out.println(calc.add(\"Hello\", \" World\")); // String version\n        \n        // Runtime polymorphism\n        Bank bank;  // Parent reference\n        \n        bank = new SBI();  // Parent reference, Child object\n        System.out.println(\"SBI Rate: \" + bank.getInterestRate());  // Calls SBI's method\n        \n        bank = new HDFC();  // Same reference, different object\n        System.out.println(\"HDFC Rate: \" + bank.getInterestRate());  // Calls HDFC's method\n        \n        // Dynamic Method Dispatch\n        Bank[] banks = {new SBI(), new HDFC(), new Bank()};\n        for(Bank b : banks) {\n            System.out.println(\"Interest Rate: \" + b.getInterestRate());\n            // Runtime par decide hoga konsa method call hoga\n        }\n    }\n}",
            "components": [
              {
                "name": "Dynamic Method Dispatch",
                "english": "Runtime decision of method to call",
                "hinglish": "Runtime par decide hona ki konsa method call hoga",
                "importance": "High",
                "tip": "Works only with overridden methods, not overloaded",
                "role": "Runtime polymorphism implementation",
                "pros": "Flexibility, extensible code",
                "cons": "Slight performance overhead",
                "example": "Parent p = new Child(); p.method();",
                "use_case": "Framework design, plugin architecture"
              }
            ],
            "comparison_table": {
              "headers": ["Aspect", "Compile-time Polymorphism", "Runtime Polymorphism"],
              "rows": [
                ["Mechanism", "Method overloading", "Method overriding"],
                ["Decision Time", "Compile time", "Runtime"],
                ["Binding", "Static binding", "Dynamic binding"],
                ["Performance", "Faster", "Slightly slower"],
                ["Example", "add(int), add(double)", "Animal a = new Dog(); a.sound();"]
              ]
            },
            "decision_table": {
              "headers": ["Requirement", "Use Polymorphism Type"],
              "rows": [
                ["Same operation, different inputs", "Compile-time (Overloading)"],
                ["Different behavior for subtypes", "Runtime (Overriding)"],
                ["Framework/Plugin design", "Runtime (Dynamic Dispatch)"],
                ["Mathematical operations", "Compile-time (Overloading)"]
              ]
            },
            "best_practices": [
              {
                "practice": "Runtime polymorphism ke liye abstract classes/interfaces use karein",
                "reason": "Better design, loose coupling",
                "hinglish": "Runtime polymorphism ke liye abstract classes ya interfaces use karo"
              }
            ]
          }
        },
        {
          "id": 6,
          "title": "Abstraction",
          "english": "Abstract classes and interfaces",
          "hinglish": "Abstract classes aur interfaces",
          "examples": [
            "// Abstract class\nabstract class Animal {\n    abstract void sound();  // Abstract method\n    void sleep() { System.out.println(\"Sleeping\"); }  // Concrete method\n}\n\n// Interface\ninterface Vehicle {\n    void start();  // Abstract method\n    default void stop() { System.out.println(\"Stopping\"); }  // Default method\n}"
          ],
          "practice": [
            {
              "question": "Abstract class aur interface mein kya antar hai?",
              "answer": "Abstract class: partial abstraction, Interface: complete abstraction"
            },
            {
              "question": "Abstract method kya hota hai?",
              "answer": "Method jiska sirf declaration hota hai, implementation nahi"
            },
            {
              "question": "Java 8+ mein interface mein kya naye features aaye?",
              "answer": "Default methods aur static methods"
            },
            {
              "question": "Functional interface kya hota hai?",
              "answer": "Interface jisme sirf ek abstract method ho"
            }
          ],
          "detailed_explanation": {
            "example_code": "// Abstract Class Example\nabstract class Shape {\n    String color;\n    \n    // Constructor in abstract class\n    Shape(String color) {\n        this.color = color;\n    }\n    \n    // Abstract method (no implementation)\n    abstract double area();\n    \n    // Concrete method (with implementation)\n    void displayColor() {\n        System.out.println(\"Color: \" + color);\n    }\n}\n\nclass Circle extends Shape {\n    double radius;\n    \n    Circle(String color, double radius) {\n        super(color);  // Calling abstract class constructor\n        this.radius = radius;\n    }\n    \n    @Override\n    double area() {\n        return Math.PI * radius * radius;\n    }\n}\n\n// Interface Example\ninterface Drawable {\n    // Abstract method (public abstract by default)\n    void draw();\n    \n    // Default method (Java 8+)\n    default void setColor(String color) {\n        System.out.println(\"Setting color to \" + color);\n    }\n    \n    // Static method (Java 8+)\n    static void info() {\n        System.out.println(\"Drawable Interface\");\n    }\n}\n\ninterface Resizable {\n    void resize(int percent);\n}\n\n// Multiple inheritance through interfaces\nclass Rectangle extends Shape implements Drawable, Resizable {\n    double length, width;\n    \n    Rectangle(String color, double l, double w) {\n        super(color);\n        this.length = l;\n        this.width = w;\n    }\n    \n    @Override\n    double area() {\n        return length * width;\n    }\n    \n    @Override\n    public void draw() {\n        System.out.println(\"Drawing Rectangle\");\n    }\n    \n    @Override\n    public void resize(int percent) {\n        length *= (1 + percent/100.0);\n        width *= (1 + percent/100.0);\n    }\n}\n\n// Functional Interface (Single Abstract Method)\n@FunctionalInterface\ninterface Calculator {\n    int calculate(int a, int b);\n    \n    // Can have multiple default/static methods\n    default void showResult(int result) {\n        System.out.println(\"Result: \" + result);\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // Abstract class usage\n        Shape circle = new Circle(\"Red\", 5.0);\n        System.out.println(\"Circle Area: \" + circle.area());\n        circle.displayColor();\n        \n        // Interface usage\n        Rectangle rect = new Rectangle(\"Blue\", 10, 5);\n        rect.draw();\n        rect.setColor(\"Green\");  // Default method\n        Drawable.info();  // Static method\n        \n        // Functional interface with lambda\n        Calculator add = (a, b) -> a + b;\n        System.out.println(\"Addition: \" + add.calculate(5, 3));\n    }\n}",
            "components": [
              {
                "name": "Abstract Class",
                "english": "Partial abstraction - can have both abstract and concrete methods",
                "hinglish": "Partial abstraction - abstract aur concrete dono methods",
                "importance": "High",
                "tip": "Use when there's IS-A relationship with common implementation",
                "role": "Template for related classes",
                "pros": "Code reuse, partial implementation",
                "cons": "Single inheritance only",
                "example": "abstract class Animal { abstract void sound(); void eat() { } }",
                "use_case": "Related classes with common behavior"
              }
            ],
            "comparison_table": {
              "headers": ["Feature", "Abstract Class", "Interface"],
              "rows": [
                ["Methods", "Abstract + Concrete", "All abstract (till Java 7)"],
                ["Variables", "Any type", "Only public static final"],
                ["Constructor", "Can have", "Cannot have"],
                ["Inheritance", "Single", "Multiple"],
                ["When to use", "IS-A with common code", "HAS-A capability"]
              ]
            },
            "decision_table": {
              "headers": ["Requirement", "Use"],
              "rows": [
                ["Complete abstraction", "Interface"],
                ["Partial abstraction with common code", "Abstract Class"],
                ["Multiple inheritance needed", "Interface"],
                ["Template method pattern", "Abstract Class"],
                ["Callback/Listener", "Interface"]
              ]
            },
            "best_practices": [
              {
                "practice": "Interface use karein jab multiple inheritance chahiye",
                "reason": "Java multiple class inheritance support nahi karti",
                "hinglish": "Multiple inheritance ke liye interfaces hi use karo"
              }
            ]
          }
        },
        {
          "id": 7,
          "title": "Packages aur Access Modifiers",
          "english": "Packages and access control in Java",
          "hinglish": "Java mein packages aur access control",
          "examples": [
            "// Package declaration\npackage com.mycompany.util;\n\n// Import statement\nimport java.util.ArrayList;\n\n// Different access levels\npublic class MyClass {\n    public int publicVar;\n    private int privateVar;\n    protected int protectedVar;\n    int defaultVar;  // package-private\n}"
          ],
          "practice": [
            {
              "question": "Package kya hota hai?",
              "answer": "Related classes ko group karne ka tarika"
            },
            {
              "question": "Access modifiers konse hote hain?",
              "answer": "public, private, protected, default (package-private)"
            },
            {
              "question": "protected access modifier ka scope kya hai?",
              "answer": "Same package + subclasses (different package mein bhi)"
            },
            {
              "question": "import statement ka use kya hai?",
              "answer": "Dusre package ki classes use karne ke liye"
            }
          ],
          "detailed_explanation": {
            "example_code": "// File 1: com/company/model/Employee.java\npackage com.company.model;\n\npublic class Employee {\n    // Different access modifiers\n    public String name;           // Accessible everywhere\n    private double salary;        // Accessible only in this class\n    protected String department;  // Accessible in package + subclasses\n    int employeeId;               // Default - accessible in same package\n    \n    // Constructor\n    public Employee(String name, double salary) {\n        this.name = name;\n        this.salary = salary;\n    }\n    \n    // Public getter for private field\n    public double getSalary() {\n        return salary;\n    }\n    \n    // Package-private method\n    void setEmployeeId(int id) {\n        this.employeeId = id;\n    }\n}\n\n// File 2: com/company/model/Manager.java (Same package)\npackage com.company.model;\n\npublic class Manager extends Employee {\n    public Manager(String name, double salary) {\n        super(name, salary);\n        // Can access protected member\n        this.department = \"Management\";\n        // Can access default member (same package)\n        this.employeeId = 1001;\n    }\n}\n\n// File 3: com/company/main/MainApp.java (Different package)\npackage com.company.main;\n\nimport com.company.model.Employee;\nimport com.company.model.Manager;\n\npublic class MainApp {\n    public static void main(String[] args) {\n        Employee emp = new Employee(\"John\", 50000);\n        \n        // Can access public members\n        System.out.println(\"Name: \" + emp.name);\n        System.out.println(\"Salary: \" + emp.getSalary());\n        \n        // Cannot access private, protected, or default members\n        // emp.salary = 60000;  // Error: private\n        // emp.department = \"IT\";  // Error: protected (different package, not subclass)\n        // emp.employeeId = 1002;  // Error: default (different package)\n        \n        Manager mgr = new Manager(\"Alice\", 80000);\n        // Through subclass in different package\n        System.out.println(\"Manager: \" + mgr.name);\n    }\n}\n\n// File 4: com/company/util/Helper.java\npackage com.company.util;\n\nimport com.company.model.Employee;\n\npublic class Helper {\n    public void processEmployee(Employee emp) {\n        // Can only access public members\n        System.out.println(\"Processing: \" + emp.name);\n    }\n}",
            "components": [
              {
                "name": "Package",
                "english": "Namespace for organizing classes",
                "hinglish": "Classes organize karne ka namespace",
                "importance": "High",
                "tip": "Use reverse domain name convention",
                "role": "Avoid naming conflicts, organize code",
                "pros": "Better organization, access control",
                "cons": "Directory structure needed",
                "example": "com.company.project.module",
                "use_case": "Every real-world Java project"
              }
            ],
            "comparison_table": {
              "headers": ["Access Modifier", "Class", "Package", "Subclass", "World"],
              "rows": [
                ["private", "✓", "✗", "✗", "✗"],
                ["default", "✓", "✓", "✗", "✗"],
                ["protected", "✓", "✓", "✓", "✗"],
                ["public", "✓", "✓", "✓", "✓"]
              ]
            },
            "decision_table": {
              "headers": ["Need", "Access Modifier"],
              "rows": [
                ["Internal implementation", "private"],
                ["Package-level sharing", "default"],
                ["Subclass access", "protected"],
                ["Public API", "public"]
              ]
            },
            "best_practices": [
              {
                "practice": "Package names lowercase mein rakhein",
                "reason": "Java naming convention",
                "hinglish": "Package names hamesha lowercase mein rakho"
              }
            ]
          }
        },
        {
          "id": 8,
          "title": "Association, Aggregation, Composition",
          "english": "Object relationships in OOP",
          "hinglish": "OOP mein object relationships",
          "examples": [
            "// Association\nclass Teacher {\n    Student[] students;  // Teacher associated with Students\n}\n\n// Aggregation (HAS-A, weak)\nclass Department {\n    Professor prof;  // Department HAS-A Professor\n}\n\n// Composition (HAS-A, strong)\nclass Car {\n    Engine engine;  // Car HAS-A Engine (cannot exist without)"
          ],
          "practice": [
            {
              "question": "Association kya hoti hai?",
              "answer": "Objects ka relationship, ek object dusre object ko use karta hai"
            },
            {
              "question": "Aggregation aur Composition mein kya antar hai?",
              "answer": "Aggregation: weak relationship, Composition: strong (lifecycle dependent)"
            },
            {
              "question": "Composition ka example do",
              "answer": "Car aur Engine - Engine Car ke bina exist nahi kar sakta"
            },
            {
              "question": "Loose coupling kya hoti hai?",
              "answer": "Objects independent hote hain, changes dusre par asar nahi karte"
            }
          ],
          "detailed_explanation": {
            "example_code": "// 1. ASSOCIATION (Simple relationship)\nclass Student {\n    String name;\n    Student(String name) { this.name = name; }\n}\n\nclass Teacher {\n    String name;\n    Student[] students;  // Association: Teacher has students\n    \n    Teacher(String name) {\n        this.name = name;\n    }\n    \n    void addStudent(Student student) {\n        // Teacher can work with multiple students\n    }\n}\n\n// 2. AGGREGATION (HAS-A, weak relationship)\nclass Address {\n    String city, state;\n    Address(String city, String state) {\n        this.city = city;\n        this.state = state;\n    }\n}\n\nclass Employee {\n    String name;\n    Address address;  // Aggregation: Employee HAS-A Address\n    \n    Employee(String name, Address address) {\n        this.name = name;\n        this.address = address;  // Address passed from outside\n    }\n    \n    void display() {\n        System.out.println(name + \" lives in \" + address.city);\n    }\n}\n\n// 3. COMPOSITION (HAS-A, strong relationship)\nclass Engine {\n    String type;\n    Engine(String type) { this.type = type; }\n    void start() { System.out.println(type + \" engine started\"); }\n}\n\nclass Car {\n    String model;\n    Engine engine;  // Composition: Car HAS-A Engine\n    \n    Car(String model) {\n        this.model = model;\n        this.engine = new Engine(\"V8\");  // Created inside Car\n    }\n    \n    void startCar() {\n        System.out.print(model + \": \");\n        engine.start();\n    }\n}\n\n// 4. LOOSE COUPLING EXAMPLE\ninterface Payment {\n    void pay(double amount);\n}\n\nclass CreditCardPayment implements Payment {\n    public void pay(double amount) {\n        System.out.println(\"Paid ₹\" + amount + \" via Credit Card\");\n    }\n}\n\nclass UPIPayment implements Payment {\n    public void pay(double amount) {\n        System.out.println(\"Paid ₹\" + amount + \" via UPI\");\n    }\n}\n\nclass ShoppingCart {\n    Payment payment;  // Loose coupling through interface\n    \n    void setPayment(Payment payment) {\n        this.payment = payment;\n    }\n    \n    void checkout(double amount) {\n        payment.pay(amount);\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // Association\n        Teacher teacher = new Teacher(\"Mr. Sharma\");\n        Student student = new Student(\"Rahul\");\n        \n        // Aggregation\n        Address addr = new Address(\"Delhi\", \"Delhi\");\n        Employee emp = new Employee(\"John\", addr);\n        emp.display();\n        \n        // Composition\n        Car car = new Car(\"BMW\");\n        car.startCar();\n        \n        // Loose Coupling\n        ShoppingCart cart = new ShoppingCart();\n        cart.setPayment(new CreditCardPayment());\n        cart.checkout(1000);\n        \n        cart.setPayment(new UPIPayment());  // Easy to change\n        cart.checkout(500);\n    }\n}",
            "components": [
              {
                "name": "Composition",
                "english": "Strong HAS-A relationship, lifecycle dependent",
                "hinglish": "Strong HAS-A relationship, lifecycle ek saath",
                "importance": "High",
                "tip": "Use when parts cannot exist without whole",
                "role": "Create complex objects from simpler ones",
                "pros": "Strong encapsulation, controlled lifecycle",
                "cons": "Tight coupling",
                "example": "Car has Engine, House has Rooms",
                "use_case": "When parts are integral to whole"
              }
            ],
            "comparison_table": {
              "headers": ["Relationship", "Strength", "Lifecycle", "Example"],
              "rows": [
                ["Association", "Weak", "Independent", "Teacher-Student"],
                ["Aggregation", "Medium", "Independent", "Department-Professor"],
                ["Composition", "Strong", "Dependent", "Car-Engine"],
                ["Inheritance", "Very Strong", "Dependent", "Car-Vehicle (IS-A)"]
              ]
            },
            "decision_table": {
              "headers": ["Relationship Type", "Use"],
              "rows": [
                ["IS-A relationship", "Inheritance"],
                ["HAS-A with independent lifecycle", "Aggregation"],
                ["HAS-A with dependent lifecycle", "Composition"],
                ["Using functionality", "Association"],
                ["Flexibility needed", "Interface (Loose Coupling)"]
              ]
            },
            "best_practices": [
              {
                "practice": "Composition over inheritance prefer karein",
                "reason": "More flexible, less coupling",
                "hinglish": "Inheritance se zyada composition prefer karo"
              }
            ]
          }
        },
        {
          "id": 9,
          "title": "Design Patterns - Singleton aur Factory",
          "english": "Common design patterns in Java",
          "hinglish": "Java mein common design patterns",
          "examples": [
            "// Singleton Pattern\nclass Logger {\n    private static Logger instance;\n    private Logger() { }  // Private constructor\n    public static Logger getInstance() {\n        if(instance == null) {\n            instance = new Logger();\n        }\n        return instance;\n    }\n}\n\n// Factory Pattern\ninterface Vehicle { void drive(); }\nclass Car implements Vehicle { \n    public void drive() { System.out.println(\"Driving car\"); }\n}\nclass VehicleFactory {\n    public static Vehicle getVehicle(String type) {\n        if(type.equals(\"car\")) return new Car();\n        return null;\n    }\n}"
          ],
          "practice": [
            {
              "question": "Singleton pattern kya hai?",
              "answer": "Design pattern jisme class ka sirf ek hi instance create hota hai"
            },
            {
              "question": "Singleton class ka constructor kaisa hota hai?",
              "answer": "Private constructor, taki bahar se object na ban sake"
            },
            {
              "question": "Factory pattern ka use kyun karte hain?",
              "answer": "Object creation logic hide karne ke liye, flexibility ke liye"
            },
            {
              "question": "Lazy initialization kya hoti hai?",
              "answer": "Object tab create karna jab zaroorat ho, pehle se nahi"
            }
          ],
          "detailed_explanation": {
            "example_code": "// 1. SINGLETON PATTERN\nclass DatabaseConnection {\n    // Private static instance\n    private static DatabaseConnection instance;\n    \n    // Private constructor to prevent external instantiation\n    private DatabaseConnection() {\n        System.out.println(\"Database connection created\");\n    }\n    \n    // Public method to get instance (Lazy initialization)\n    public static DatabaseConnection getInstance() {\n        if(instance == null) {\n            instance = new DatabaseConnection();\n        }\n        return instance;\n    }\n    \n    // Thread-safe version (for multithreading)\n    public static DatabaseConnection getThreadSafeInstance() {\n        if(instance == null) {\n            synchronized(DatabaseConnection.class) {\n                if(instance == null) {\n                    instance = new DatabaseConnection();\n                }\n            }\n        }\n        return instance;\n    }\n    \n    // Business method\n    public void executeQuery(String query) {\n        System.out.println(\"Executing: \" + query);\n    }\n}\n\n// 2. FACTORY PATTERN\ninterface Notification {\n    void send(String message);\n}\n\nclass EmailNotification implements Notification {\n    @Override\n    public void send(String message) {\n        System.out.println(\"Sending Email: \" + message);\n    }\n}\n\nclass SMSNotification implements Notification {\n    @Override\n    public void send(String message) {\n        System.out.println(\"Sending SMS: \" + message);\n    }\n}\n\nclass PushNotification implements Notification {\n    @Override\n    public void send(String message) {\n        System.out.println(\"Sending Push: \" + message);\n    }\n}\n\n// Factory Class\nclass NotificationFactory {\n    public static Notification createNotification(String channel) {\n        switch(channel.toLowerCase()) {\n            case \"email\":\n                return new EmailNotification();\n            case \"sms\":\n                return new SMSNotification();\n            case \"push\":\n                return new PushNotification();\n            default:\n                throw new IllegalArgumentException(\"Unknown channel: \" + channel);\n        }\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        // Singleton Pattern Usage\n        DatabaseConnection db1 = DatabaseConnection.getInstance();\n        DatabaseConnection db2 = DatabaseConnection.getInstance();\n        \n        // Both refer to same instance\n        System.out.println(\"Same instance? \" + (db1 == db2));  // true\n        db1.executeQuery(\"SELECT * FROM users\");\n        \n        // Factory Pattern Usage\n        Notification email = NotificationFactory.createNotification(\"email\");\n        email.send(\"Hello via Email\");\n        \n        Notification sms = NotificationFactory.createNotification(\"sms\");\n        sms.send(\"Hello via SMS\");\n        \n        // Adding new notification type doesn't affect client code\n        Notification push = NotificationFactory.createNotification(\"push\");\n        push.send(\"Hello via Push\");\n    }\n}",
            "components": [
              {
                "name": "Singleton Pattern",
                "english": "Ensures only one instance of a class exists",
                "hinglish": "Class ka sirf ek hi instance banane ko ensure karta hai",
                "importance": "High",
                "tip": "Use for shared resources like database connections",
                "role": "Control object creation, global access point",
                "pros": "Memory efficient, consistent state",
                "cons": "Global state, testing difficulties",
                "example": "Logger, Configuration, Database Connection",
                "use_case": "When exactly one object needed"
              }
            ],
            "comparison_table": {
              "headers": ["Pattern", "Purpose", "When to Use"],
              "rows": [
                ["Singleton", "Single instance", "Database, Logger, Config"],
                ["Factory", "Object creation", "Multiple similar objects"],
                ["Both", "Controlled creation", "Flexible systems"]
              ]
            },
            "decision_table": {
              "headers": ["Requirement", "Pattern"],
              "rows": [
                ["Only one instance needed", "Singleton"],
                ["Hide object creation logic", "Factory"],
                ["Multiple object types", "Factory"],
                ["Global access point", "Singleton"]
              ]
            },
            "best_practices": [
              {
                "practice": "Singleton ke liye enum bhi use kar sakte hain",
                "reason": "Thread-safe aur serialization-safe",
                "hinglish": "Singleton ke liye enum use karo, thread-safe rahega"
              }
            ]
          }
        }
      ]
    },
    {
      "level": "Intermediate to Advanced",
      "order": 3,
      "description": "String Handling, Collections, Exception Handling aur Wrapper Classes",
      "topics": [
        {
          "id": 1,
          "title": "String Handling",
          "english": "String manipulation using String, StringBuilder, StringBuffer",
          "hinglish": "String, StringBuilder, StringBuffer ka use karke string manipulation",
          "examples": [
            "String str = \"Hello\";\nStringBuilder sb = new StringBuilder(\"Hello\");\nsb.append(\" World\");\nSystem.out.println(sb.toString());"
          ],
          "practice": [
            {
              "question": "String, StringBuilder aur StringBuffer mein kya antar hai?",
              "answer": "String immutable, StringBuilder mutable (not thread-safe), StringBuffer mutable (thread-safe)"
            },
            {
              "question": "== aur equals() mein kya antar hai?",
              "answer": "== reference compare karta hai, equals() content compare karta hai"
            },
            {
              "question": "String immutable kyun hota hai?",
              "answer": "Security, caching, thread-safety ke liye"
            },
            {
              "question": "String pool kya hota hai?",
              "answer": "Heap memory ka special area jahan String store hote hain"
            }
          ],
          "detailed_explanation": {
            "example_code": "public class StringExample {\n    public static void main(String[] args) {\n        // String - Immutable\n        String s1 = \"Hello\";\n        s1.concat(\" World\");  // Creates new object\n        System.out.println(s1);  // Still \"Hello\"\n        \n        // StringBuilder - Mutable, Not thread-safe\n        StringBuilder sb = new StringBuilder(\"Hello\");\n        sb.append(\" World\");\n        System.out.println(sb);  // \"Hello World\"\n        \n        // StringBuffer - Mutable, Thread-safe\n        StringBuffer sbf = new StringBuffer(\"Hello\");\n        sbf.append(\" World\");\n        System.out.println(sbf);  // \"Hello World\"\n        \n        // String methods\n        String str = \"Java Programming\";\n        System.out.println(\"Length: \" + str.length());\n        System.out.println(\"Char at 5: \" + str.charAt(5));\n        System.out.println(\"Substring: \" + str.substring(5, 11));\n        System.out.println(\"Uppercase: \" + str.toUpperCase());\n        \n        // String comparison\n        String a = \"Hello\";\n        String b = \"Hello\";\n        String c = new String(\"Hello\");\n        \n        System.out.println(\"a == b: \" + (a == b));  // true (string pool)\n        System.out.println(\"a == c: \" + (a == c));  // false (different objects)\n        System.out.println(\"a.equals(c): \" + a.equals(c));  // true (content same)\n        \n        // Regular expressions\n        String email = \"test@example.com\";\n        boolean isValid = email.matches(\"^[A-Za-z0-9+_.-]+@(.+)$\");\n        System.out.println(\"Valid email? \" + isValid);\n    }\n}",
            "components": [
              {
                "name": "StringBuilder",
                "english": "Mutable sequence of characters (not thread-safe)",
                "hinglish": "Mutable character sequence (thread-safe nahi)",
                "importance": "High",
                "tip": "Use when many string modifications needed",
                "role": "Efficient string manipulation",
                "pros": "Fast, mutable",
                "cons": "Not thread-safe",
                "example": "StringBuilder sb = new StringBuilder(); sb.append(\"text\");",
                "use_case": "String concatenation in loops"
              }
            ],
            "comparison_table": {
              "headers": ["Feature", "String", "StringBuilder", "StringBuffer"],
              "rows": [
                ["Mutability", "Immutable", "Mutable", "Mutable"],
                ["Thread Safety", "Yes", "No", "Yes"],
                ["Performance", "Slow for modifications", "Fast", "Moderate"],
                ["Storage", "String Pool", "Heap", "Heap"],
                ["When to use", "Constants, keys", "Single thread modifications", "Multi-thread modifications"]
              ]
            },
            "decision_table": {
              "headers": ["Scenario", "Use"],
              "rows": [
                ["Constant strings", "String"],
                ["Single-thread string manipulation", "StringBuilder"],
                ["Multi-thread string manipulation", "StringBuffer"],
                ["Many string operations", "StringBuilder/StringBuffer"]
              ]
            },
            "best_practices": [
              {
                "practice": "String concatenation in loops ke liye StringBuilder use karein",
                "reason": "Performance improvement",
                "hinglish": "Loops mein string concatenation ke liye StringBuilder use karo"
              }
            ]
          }
        },
        {
          "id": 2,
          "title": "Collections Framework - List aur Set",
          "english": "List and Set interfaces and their implementations",
          "hinglish": "List aur Set interfaces aur unki implementations",
          "examples": [
            "List<String> list = new ArrayList<>();\nlist.add(\"Apple\");\n\nSet<Integer> set = new HashSet<>();\nset.add(10);"
          ],
          "practice": [
            {
              "question": "ArrayList aur LinkedList mein kya antar hai?",
              "answer": "ArrayList: array based (fast access), LinkedList: node based (fast insert/delete)"
            },
            {
              "question": "HashSet, LinkedHashSet aur TreeSet mein kya antar hai?",
              "answer": "HashSet: no order, LinkedHashSet: insertion order, TreeSet: sorted order"
            },
            {
              "question": "Vector aur ArrayList mein kya antar hai?",
              "answer": "Vector thread-safe, ArrayList not thread-safe"
            },
            {
              "question": "Stack class kaise implement hoti hai?",
              "answer": "LIFO (Last In First Out) principle par"
            }
          ],
          "detailed_explanation": {
            "example_code": "import java.util.*;\n\npublic class CollectionsExample {\n    public static void main(String[] args) {\n        // LIST Implementations\n        // ArrayList - Resizable array\n        List<String> arrayList = new ArrayList<>();\n        arrayList.add(\"Apple\");\n        arrayList.add(\"Banana\");\n        arrayList.add(\"Mango\");\n        System.out.println(\"ArrayList: \" + arrayList);\n        \n        // LinkedList - Doubly linked list\n        List<String> linkedList = new LinkedList<>();\n        linkedList.add(\"First\");\n        linkedList.add(\"Last\");\n        linkedList.add(1, \"Middle\");  // Insert at index\n        System.out.println(\"LinkedList: \" + linkedList);\n        \n        // Vector - Thread-safe version of ArrayList\n        Vector<String> vector = new Vector<>();\n        vector.add(\"One\");\n        vector.add(\"Two\");\n        System.out.println(\"Vector: \" + vector);\n        \n        // Stack - LIFO\n        Stack<String> stack = new Stack<>();\n        stack.push(\"First\");\n        stack.push(\"Second\");\n        System.out.println(\"Stack top: \" + stack.peek());\n        System.out.println(\"Popped: \" + stack.pop());\n        \n        // SET Implementations\n        // HashSet - No order, no duplicates\n        Set<String> hashSet = new HashSet<>();\n        hashSet.add(\"Zebra\");\n        hashSet.add(\"Apple\");\n        hashSet.add(\"Banana\");\n        hashSet.add(\"Apple\");  // Duplicate ignored\n        System.out.println(\"HashSet (no order): \" + hashSet);\n        \n        // LinkedHashSet - Insertion order\n        Set<String> linkedHashSet = new LinkedHashSet<>();\n        linkedHashSet.add(\"Zebra\");\n        linkedHashSet.add(\"Apple\");\n        linkedHashSet.add(\"Banana\");\n        System.out.println(\"LinkedHashSet (insertion order): \" + linkedHashSet);\n        \n        // TreeSet - Sorted order\n        Set<String> treeSet = new TreeSet<>();\n        treeSet.add(\"Zebra\");\n        treeSet.add(\"Apple\");\n        treeSet.add(\"Banana\");\n        System.out.println(\"TreeSet (sorted): \" + treeSet);\n        \n        // Iterators\n        Iterator<String> iterator = arrayList.iterator();\n        while(iterator.hasNext()) {\n            System.out.println(\"Item: \" + iterator.next());\n        }\n        \n        // ListIterator (bidirectional)\n        ListIterator<String> listIterator = arrayList.listIterator();\n        while(listIterator.hasNext()) {\n            System.out.println(\"Forward: \" + listIterator.next());\n        }\n    }\n}",
            "components": [
              {
                "name": "ArrayList",
                "english": "Resizable array implementation of List",
                "hinglish": "List ki resizable array implementation",
                "importance": "High",
                "tip": "Default choice for List when random access needed",
                "role": "Store ordered collection with duplicates",
                "pros": "Fast random access, cache friendly",
                "cons": "Slow insert/delete in middle",
                "example": "List<String> list = new ArrayList<>();",
                "use_case": "When frequent access by index needed"
              }
            ],
            "comparison_table": {
              "headers": ["Collection", "Order", "Duplicates", "Null Allowed", "When to Use"],
              "rows": [
                ["ArrayList", "Insertion", "Yes", "Yes", "Frequent access by index"],
                ["LinkedList", "Insertion", "Yes", "Yes", "Frequent insert/delete"],
                ["HashSet", "No order", "No", "One null", "Unique elements, fast lookup"],
                ["TreeSet", "Sorted", "No", "No (if natural ordering)", "Sorted unique elements"],
                ["LinkedHashSet", "Insertion", "No", "Yes", "Unique with insertion order"]
              ]
            },
            "decision_table": {
              "headers": ["Requirement", "Choose"],
              "rows": [
                ["Index-based access", "ArrayList"],
                ["Frequent insert/delete", "LinkedList"],
                ["Unique elements", "HashSet"],
                ["Unique + sorted", "TreeSet"],
                ["Unique + insertion order", "LinkedHashSet"]
              ]
            },
            "best_practices": [
              {
                "practice": "Interface type se reference rakhein (List, Set, Map)",
                "reason": "Flexibility to change implementation",
                "hinglish": "List<String> list = new ArrayList<>(); - aisa syntax use karo"
              }
            ]
          }
        },
        {
          "id": 3,
          "title": "Collections Framework - Queue aur Map",
          "english": "Queue and Map interfaces and implementations",
          "hinglish": "Queue aur Map interfaces aur implementations",
          "examples": [
            "Queue<String> queue = new PriorityQueue<>();\nqueue.add(\"Task1\");\n\nMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"One\");"
          ],
          "practice": [
            {
              "question": "HashMap aur Hashtable mein kya antar hai?",
              "answer": "HashMap: not synchronized, allows one null key; Hashtable: synchronized, no null keys"
            },
            {
              "question": "PriorityQueue kya hoti hai?",
              "answer": "Queue jisme elements priority ke hisaab se arrange hote hain"
            },
            {
              "question": "LinkedHashMap ka special feature kya hai?",
              "answer": "Insertion order maintain karti hai"
            },
            {
              "question": "TreeMap mein elements kaise arrange hote hain?",
              "answer": "Keys ke natural order mein ya Comparator ke hisaab se"
            }
          ],
          "detailed_explanation": {
            "example_code": "import java.util.*;\n\npublic class QueueMapExample {\n    public static void main(String[] args) {\n        // QUEUE Implementations\n        // PriorityQueue - Natural ordering\n        Queue<String> priorityQueue = new PriorityQueue<>();\n        priorityQueue.add(\"Zebra\");\n        priorityQueue.add(\"Apple\");\n        priorityQueue.add(\"Banana\");\n        System.out.print(\"PriorityQueue: \");\n        while(!priorityQueue.isEmpty()) {\n            System.out.print(priorityQueue.poll() + \" \");  // Sorted order\n        }\n        System.out.println();\n        \n        // ArrayDeque - Double ended queue\n        Deque<String> arrayDeque = new ArrayDeque<>();\n        arrayDeque.addFirst(\"First\");\n        arrayDeque.addLast(\"Last\");\n        arrayDeque.offer(\"Middle\");\n        System.out.println(\"ArrayDeque: \" + arrayDeque);\n        \n        // MAP Implementations\n        // HashMap - No order, O(1) operations\n        Map<Integer, String> hashMap = new HashMap<>();\n        hashMap.put(101, \"John\");\n        hashMap.put(102, \"Alice\");\n        hashMap.put(103, \"Bob\");\n        hashMap.put(null, \"Null Key\");  // Allows one null key\n        hashMap.put(104, null);  // Allows null values\n        System.out.println(\"HashMap: \" + hashMap);\n        \n        // LinkedHashMap - Insertion order\n        Map<Integer, String> linkedHashMap = new LinkedHashMap<>();\n        linkedHashMap.put(103, \"Bob\");\n        linkedHashMap.put(101, \"John\");\n        linkedHashMap.put(102, \"Alice\");\n        System.out.println(\"LinkedHashMap (insertion order): \" + linkedHashMap);\n        \n        // TreeMap - Sorted by keys\n        Map<Integer, String> treeMap = new TreeMap<>();\n        treeMap.put(103, \"Bob\");\n        treeMap.put(101, \"John\");\n        treeMap.put(102, \"Alice\");\n        System.out.println(\"TreeMap (sorted keys): \" + treeMap);\n        \n        // Hashtable - Legacy, thread-safe\n        Hashtable<Integer, String> hashtable = new Hashtable<>();\n        hashtable.put(1, \"One\");\n        hashtable.put(2, \"Two\");\n        // hashtable.put(null, \"Null\");  // Throws NullPointerException\n        System.out.println(\"Hashtable: \" + hashtable);\n        \n        // Map iteration\n        for(Map.Entry<Integer, String> entry : hashMap.entrySet()) {\n            System.out.println(\"Key: \" + entry.getKey() + \", Value: \" + entry.getValue());\n        }\n        \n        // Collections utility class\n        List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9);\n        Collections.sort(numbers);\n        System.out.println(\"Sorted: \" + numbers);\n        Collections.reverse(numbers);\n        System.out.println(\"Reversed: \" + numbers);\n        System.out.println(\"Max: \" + Collections.max(numbers));\n    }\n}",
            "components": [
              {
                "name": "HashMap",
                "english": "Hash table based implementation of Map",
                "hinglish": "Map ki hash table based implementation",
                "importance": "High",
                "tip": "Default choice for Map when ordering not required",
                "role": "Store key-value pairs",
                "pros": "O(1) operations, allows one null key",
                "cons": "No ordering, not thread-safe",
                "example": "Map<String, Integer> map = new HashMap<>();",
                "use_case": "Fast lookup by key, caching"
              }
            ],
            "comparison_table": {
              "headers": ["Map Type", "Order", "Null Keys", "Thread-Safe", "When to Use"],
              "rows": [
                ["HashMap", "No order", "One null", "No", "General purpose, fast"],
                ["LinkedHashMap", "Insertion/access order", "One null", "No", "Maintain insertion order"],
                ["TreeMap", "Sorted by keys", "No", "No", "Sorted map needed"],
                ["Hashtable", "No order", "No", "Yes", "Legacy, thread-safe required"]
              ]
            },
            "decision_table": {
              "headers": ["Requirement", "Choose"],
              "rows": [
                ["Fast lookup, no ordering", "HashMap"],
                ["Insertion order needed", "LinkedHashMap"],
                ["Sorted keys needed", "TreeMap"],
                ["Thread-safe (legacy)", "Hashtable"],
                ["Priority-based processing", "PriorityQueue"],
                ["Double-ended operations", "ArrayDeque"]
              ]
            },
            "best_practices": [
              {
                "practice": "Map iterate karne ke liye entrySet() use karein",
                "reason": "Key-value pairs mil jate hain, efficient",
                "hinglish": "Map iterate karne ke liye entrySet() method use karo"
              }
            ]
          }
        },
        {
          "id": 4,
          "title": "Comparable aur Comparator",
          "english": "Sorting collections using Comparable and Comparator",
          "hinglish": "Comparable aur Comparator ka use karke collections sort karna",
          "examples": [
            "// Comparable\nclass Student implements Comparable<Student> {\n    public int compareTo(Student other) {\n        return this.name.compareTo(other.name);\n    }\n}\n\n// Comparator\nComparator<Student> ageComparator = (s1, s2) -> s1.age - s2.age;"
          ],
          "practice": [
            {
              "question": "Comparable aur Comparator mein kya antar hai?",
              "answer": "Comparable: natural ordering (class implements), Comparator: custom ordering (separate class)"
            },
            {
              "question": "compareTo() method kya return karta hai?",
              "answer": "Negative (less than), Zero (equal), Positive (greater than)"
            },
            {
              "question": "Multiple sorting criteria kaise implement karte hain?",
              "answer": "Multiple Comparator classes banake"
            },
            {
              "question": "Collections.sort() kaise kaam karta hai?",
              "answer": "Comparable ya Comparator ke hisaab se sort karta hai"
            }
          ],
          "detailed_explanation": {
            "example_code": "import java.util.*;\n\n// Comparable Example - Natural ordering\nclass Student implements Comparable<Student> {\n    String name;\n    int age;\n    double marks;\n    \n    Student(String name, int age, double marks) {\n        this.name = name;\n        this.age = age;\n        this.marks = marks;\n    }\n    \n    // Natural ordering by name\n    @Override\n    public int compareTo(Student other) {\n        return this.name.compareTo(other.name);\n    }\n    \n    @Override\n    public String toString() {\n        return name + \" (\" + age + \", \" + marks + \")\";\n    }\n}\n\n// Comparator Classes - Custom ordering\nclass AgeComparator implements Comparator<Student> {\n    @Override\n    public int compare(Student s1, Student s2) {\n        return s1.age - s2.age;  // Ascending by age\n    }\n}\n\nclass MarksComparator implements Comparator<Student> {\n    @Override\n    public int compare(Student s1, Student s2) {\n        return Double.compare(s2.marks, s1.marks);  // Descending by marks\n    }\n}\n\npublic class SortingExample {\n    public static void main(String[] args) {\n        List<Student> students = new ArrayList<>();\n        students.add(new Student(\"Rahul\", 22, 85.5));\n        students.add(new Student(\"Amit\", 20, 90.0));\n        students.add(new Student(\"Priya\", 21, 88.0));\n        \n        // Natural ordering (by name - from Comparable)\n        Collections.sort(students);\n        System.out.println(\"Sorted by name (natural order):\");\n        students.forEach(System.out::println);\n        \n        // Custom ordering by age\n        Collections.sort(students, new AgeComparator());\n        System.out.println(\"\\nSorted by age (ascending):\");\n        students.forEach(System.out::println);\n        \n        // Custom ordering by marks (descending)\n        Collections.sort(students, new MarksComparator());\n        System.out.println(\"\\nSorted by marks (descending):\");\n        students.forEach(System.out::println);\n        \n        // Using anonymous comparator\n        Collections.sort(students, new Comparator<Student>() {\n            @Override\n            public int compare(Student s1, Student s2) {\n                int nameCompare = s1.name.compareTo(s2.name);\n                if(nameCompare != 0) return nameCompare;\n                return s1.age - s2.age;  // Then by age\n            }\n        });\n        System.out.println(\"\\nSorted by name then age:\");\n        students.forEach(System.out::println);\n        \n        // Using lambda expression (Java 8+)\n        Collections.sort(students, (s1, s2) -> {\n            int ageCompare = s1.age - s2.age;\n            if(ageCompare != 0) return ageCompare;\n            return Double.compare(s2.marks, s1.marks);\n        });\n        System.out.println(\"\\nSorted by age then marks (descending):\");\n        students.forEach(System.out::println);\n        \n        // Multiple comparators chaining\n        Comparator<Student> comparatorChain = new AgeComparator()\n            .thenComparing(new MarksComparator());\n        Collections.sort(students, comparatorChain);\n        System.out.println(\"\\nSorted by age then marks:\");\n        students.forEach(System.out::println);\n    }\n}",
            "components": [
              {
                "name": "Comparable Interface",
                "english": "Defines natural ordering of objects",
                "hinglish": "Objects ki natural ordering define karta hai",
                "importance": "High",
                "tip": "Use when there's a single natural ordering",
                "role": "Default sorting for objects",
                "pros": "Simple, built-in sorting",
                "cons": "Only one natural order possible",
                "example": "class Student implements Comparable<Student>",
                "use_case": "When class has obvious natural order"
              }
            ],
            "comparison_table": {
              "headers": ["Aspect", "Comparable", "Comparator"],
              "rows": [
                ["Method", "compareTo()", "compare()"],
                ["Package", "java.lang", "java.util"],
                ["Sorting logic", "Inside class", "Separate class"],
                ["Number of sequences", "One (natural)", "Multiple (custom)"],
                ["Modifies class", "Yes", "No"],
                ["When to use", "Natural ordering", "Custom ordering"]
              ]
            },
            "decision_table": {
              "headers": ["Situation", "Use"],
              "rows": [
                ["Single natural order", "Comparable"],
                ["Multiple sorting ways", "Comparator"],
                ["Cannot modify class", "Comparator"],
                ["Default sorting needed", "Comparable"]
              ]
            },
            "best_practices": [
              {
                "practice": "compareTo() aur compare() methods consistent rakhne ke liye equals() ko bhi override karein",
                "reason": "Sorting aur equality consistency ke liye",
                "hinglish": "compareTo() override karte time equals() bhi override karo"
              }
            ]
          }
        },
        {
          "id": 5,
          "title": "Exception Handling",
          "english": "Handling runtime errors using exceptions",
          "hinglish": "Exceptions ka use karke runtime errors handle karna",
          "examples": [
            "try {\n    int result = 10 / 0;\n} catch(ArithmeticException e) {\n    System.out.println(\"Cannot divide by zero\");\n} finally {\n    System.out.println(\"Cleanup\");\n}"
          ],
          "practice": [
            {
              "question": "Checked aur Unchecked exceptions mein kya antar hai?",
              "answer": "Checked: compile-time check (IOException), Unchecked: runtime (NullPointerException)"
            },
            {
              "question": "finally block hamesha execute hota hai?",
              "answer": "Haan, except System.exit() ya fatal error ke case mein"
            },
            {
              "question": "throw aur throws mein kya antar hai?",
              "answer": "throw: exception throw karna, throws: method signature mein exception declare karna"
            },
            {
              "question": "Custom exception kaise banate hain?",
              "answer": "Exception class extend karke"
            }
          ],
          "detailed_explanation": {
            "example_code": "import java.io.*;\n\n// Custom Exception\nclass InsufficientBalanceException extends Exception {\n    private double amount;\n    \n    public InsufficientBalanceException(double amount) {\n        super(\"Insufficient balance. Need: \" + amount + \" more\");\n        this.amount = amount;\n    }\n    \n    public double getAmount() {\n        return amount;\n    }\n}\n\nclass BankAccount {\n    private double balance;\n    \n    public BankAccount(double balance) {\n        this.balance = balance;\n    }\n    \n    public void withdraw(double amount) throws InsufficientBalanceException {\n        if(amount > balance) {\n            throw new InsufficientBalanceException(amount - balance);\n        }\n        balance -= amount;\n        System.out.println(\"Withdrawal successful. Remaining: \" + balance);\n    }\n}\n\npublic class ExceptionHandlingExample {\n    public static void main(String[] args) {\n        // Basic try-catch-finally\n        try {\n            int[] numbers = {1, 2, 3};\n            System.out.println(numbers[5]);  // ArrayIndexOutOfBoundsException\n        } catch(ArrayIndexOutOfBoundsException e) {\n            System.out.println(\"Array index error: \" + e.getMessage());\n        } finally {\n            System.out.println(\"This always executes\");\n        }\n        \n        // Multiple catch blocks\n        try {\n            String str = null;\n            System.out.println(str.length());  // NullPointerException\n            int result = 10 / 0;  // ArithmeticException\n        } catch(NullPointerException e) {\n            System.out.println(\"Null pointer: \" + e);\n        } catch(ArithmeticException e) {\n            System.out.println(\"Arithmetic error: \" + e);\n        } catch(Exception e) {\n            System.out.println(\"Generic error: \" + e);\n        }\n        \n        // Multi-catch (Java 7+)\n        try {\n            // Some code that may throw multiple exceptions\n        } catch(NullPointerException | ArithmeticException e) {\n            System.out.println(\"Either null or arithmetic error: \" + e);\n        }\n        \n        // Try-with-resources (Java 7+)\n        try (FileReader reader = new FileReader(\"test.txt\")) {\n            // Auto-closed after try block\n            System.out.println(\"File read\");\n        } catch(IOException e) {\n            System.out.println(\"File error: \" + e);\n        }\n        \n        // Custom exception usage\n        BankAccount account = new BankAccount(1000);\n        try {\n            account.withdraw(1500);\n        } catch(InsufficientBalanceException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            System.out.println(\"Additional needed: \" + e.getAmount());\n        }\n        \n        // Exception propagation\n        try {\n            method1();\n        } catch(Exception e) {\n            System.out.println(\"Caught in main: \" + e);\n        }\n    }\n    \n    static void method1() throws IOException {\n        method2();\n    }\n    \n    static void method2() throws IOException {\n        // Checked exception must be declared\n        throw new IOException(\"IO Error occurred\");\n    }\n}",
            "components": [
              {
                "name": "try-catch-finally",
                "english": "Block for exception handling and cleanup",
                "hinglish": "Exception handling aur cleanup ka block",
                "importance": "High",
                "tip": "Always close resources in finally or use try-with-resources",
                "role": "Handle exceptions and ensure cleanup",
                "pros": "Graceful error handling, resource management",
                "cons": "Code complexity increases",
                "example": "try { } catch(Exception e) { } finally { }",
                "use_case": "Error-prone code, resource handling"
              }
            ],
            "comparison_table": {
              "headers": ["Exception Type", "Checked/Unchecked", "Examples", "Handling Required"],
              "rows": [
                ["Checked", "Checked", "IOException, SQLException", "Must handle or declare"],
                ["Unchecked", "Unchecked", "NullPointerException, ArithmeticException", "Optional"],
                ["Error", "Unchecked", "OutOfMemoryError, StackOverflowError", "Should not catch"]
              ]
            },
            "decision_table": {
              "headers": ["Scenario", "Exception Handling Strategy"],
              "rows": [
                ["Resource cleanup needed", "try-with-resources or finally"],
                ["Multiple similar exceptions", "Multi-catch"],
                ["Custom error conditions", "Custom exception"],
                ["Method cannot handle", "Throws declaration"],
                ["Recoverable error", "Catch and handle"],
                ["Unrecoverable error", "Throw further"]
              ]
            },
            "best_practices": [
              {
                "practice": "Specific exceptions catch karein, generic Exception nahi",
                "reason": "Better error handling aur debugging",
                "hinglish": "Specific exceptions catch karo, sirf Exception nahi"
              }
            ]
          }
        },
        {
          "id": 6,
          "title": "Wrapper Classes aur Autoboxing",
          "english": "Primitive wrapper classes and autoboxing/unboxing",
          "hinglish": "Primitive wrapper classes aur autoboxing/unboxing",
          "examples": [
            "Integer i = 10;  // Autoboxing (int to Integer)\nint j = i;        // Unboxing (Integer to int)\n\nInteger k = Integer.valueOf(\"100\");  // String to Integer"
          ],
          "practice": [
            {
              "question": "Wrapper classes konse hain?",
              "answer": "Byte, Short, Integer, Long, Float, Double, Character, Boolean"
            },
            {
              "question": "Autoboxing aur Unboxing kya hota hai?",
              "answer": "Autoboxing: primitive → wrapper, Unboxing: wrapper → primitive"
            },
            {
              "question": "valueOf() method ka use kya hai?",
              "answer": "String se wrapper object banane ke liye"
            },
            {
              "question": "Integer caching kya hota hai?",
              "answer": "-128 to 127 range ke Integer objects cache hote hain"
            }
          ],
          "detailed_explanation": {
            "example_code": "public class WrapperExample {\n    public static void main(String[] args) {\n        // Primitive types\n        int primitiveInt = 100;\n        double primitiveDouble = 99.99;\n        char primitiveChar = 'A';\n        boolean primitiveBool = true;\n        \n        // Wrapper classes (manual)\n        Integer wrappedInt = Integer.valueOf(100);\n        Double wrappedDouble = Double.valueOf(99.99);\n        Character wrappedChar = Character.valueOf('A');\n        Boolean wrappedBool = Boolean.valueOf(true);\n        \n        // Autoboxing (Automatic conversion primitive → wrapper)\n        Integer autoBoxedInt = 100;  // int to Integer\n        Double autoBoxedDouble = 99.99;  // double to Double\n        \n        // Unboxing (Automatic conversion wrapper → primitive)\n        int unboxedInt = wrappedInt;  // Integer to int\n        double unboxedDouble = wrappedDouble;  // Double to double\n        \n        System.out.println(\"Primitive int: \" + primitiveInt);\n        System.out.println(\"Wrapper Integer: \" + wrappedInt);\n        System.out.println(\"Autoboxed Integer: \" + autoBoxedInt);\n        System.out.println(\"Unboxed int: \" + unboxedInt);\n        \n        // Useful methods\n        String numStr = \"123\";\n        int parsedInt = Integer.parseInt(numStr);  // String to int\n        Integer valueOfInt = Integer.valueOf(numStr);  // String to Integer\n        System.out.println(\"Parsed int: \" + parsedInt);\n        System.out.println(\"ValueOf Integer: \" + valueOfInt);\n        \n        // Integer to String\n        String intStr = Integer.toString(456);\n        String intStr2 = String.valueOf(456);\n        System.out.println(\"Integer to String: \" + intStr);\n        \n        // Comparison\n        Integer a = 100;\n        Integer b = 100;\n        Integer c = 200;\n        Integer d = 200;\n        \n        System.out.println(\"a == b (100 == 100): \" + (a == b));  // true (cached)\n        System.out.println(\"c == d (200 == 200): \" + (c == d));  // false (not cached)\n        System.out.println(\"c.equals(d): \" + c.equals(d));  // true (value comparison)\n        \n        // Character class methods\n        char ch = 'A';\n        System.out.println(\"Is digit? \" + Character.isDigit(ch));\n        System.out.println(\"Is letter? \" + Character.isLetter(ch));\n        System.out.println(\"Is uppercase? \" + Character.isUpperCase(ch));\n        System.out.println(\"To lowercase: \" + Character.toLowerCase(ch));\n        \n        // Boolean class\n        Boolean bool1 = true;\n        Boolean bool2 = Boolean.parseBoolean(\"TRUE\");\n        Boolean bool3 = Boolean.valueOf(\"false\");\n        System.out.println(\"Boolean values: \" + bool1 + \", \" + bool2 + \", \" + bool3);\n        \n        // Number class (parent of numeric wrappers)\n        Number num = 123.45;  // Can hold any numeric type\n        System.out.println(\"Number as int: \" + num.intValue());\n        System.out.println(\"Number as double: \" + num.doubleValue());\n        \n        // Auto-unboxing in expressions\n        Integer x = 10;\n        Integer y = 20;\n        Integer sum = x + y;  // x and y unboxed, then result boxed\n        System.out.println(\"Sum: \" + sum);\n        \n        // NullPointerException risk with unboxing\n        Integer nullableInt = null;\n        try {\n            int risk = nullableInt;  // NullPointerException\n        } catch(NullPointerException e) {\n            System.out.println(\"NPE in unboxing: \" + e);\n        }\n    }\n}",
            "components": [
              {
                "name": "Autoboxing",
                "english": "Automatic conversion from primitive to wrapper",
                "hinglish": "Primitive se wrapper mein automatic conversion",
                "importance": "High",
                "tip": "Happens automatically when primitive is used where wrapper expected",
                "role": "Simplify primitive-wrapper conversions",
                "pros": "Cleaner code, less verbose",
                "cons": "Performance overhead, null risk",
                "example": "Integer i = 10;  // int to Integer",
                "use_case": "Collections (which require objects)"
              }
            ],
            "comparison_table": {
              "headers": ["Primitive", "Wrapper", "Size", "Default Value"],
              "rows": [
                ["byte", "Byte", "1 byte", "0"],
                ["short", "Short", "2 bytes", "0"],
                ["int", "Integer", "4 bytes", "0"],
                ["long", "Long", "8 bytes", "0L"],
                ["float", "Float", "4 bytes", "0.0f"],
                ["double", "Double", "8 bytes", "0.0d"],
                ["char", "Character", "2 bytes", "'\\u0000'"],
                ["boolean", "Boolean", "1 bit", "false"]
              ]
            },
            "decision_table": {
              "headers": ["Scenario", "Use"],
              "rows": [
                ["Performance critical", "Primitive types"],
                ["Collections needed", "Wrapper classes"],
                ["Null values needed", "Wrapper classes"],
                ["Method parameters flexibility", "Wrapper classes"],
                ["Memory efficiency", "Primitive types"]
              ]
            },
            "best_practices": [
              {
                "practice": "Wrapper objects compare karne ke liye equals() use karein, == nahi",
                "reason": "== reference compare karta hai, equals() value compare karta hai",
                "hinglish": "Wrapper objects compare karne ke liye equals() method use karo"
              }
            ]
          }
        },
        {
          "id": 7,
          "title": "Multithreading Basics",
          "english": "Creating and managing threads in Java",
          "hinglish": "Java mein threads banana aur manage karna",
          "examples": [
            "// Extending Thread\nclass MyThread extends Thread {\n    public void run() {\n        System.out.println(\"Thread running\");\n    }\n}\n\n// Implementing Runnable\nclass MyRunnable implements Runnable {\n    public void run() {\n        System.out.println(\"Runnable running\");\n    }\n}"
          ],
          "practice": [
            {
              "question": "Thread banane ke do tareeke konse hain?",
              "answer": "Thread class extend karke ya Runnable interface implement karke"
            },
            {
              "question": "start() aur run() method mein kya antar hai?",
              "answer": "start(): new thread start karta hai, run(): thread ka code execute karta hai"
            },
            {
              "question": "Thread lifecycle ke states konse hain?",
              "answer": "New, Runnable, Running, Blocked, Waiting, Timed Waiting, Terminated"
            },
            {
              "question": "Daemon thread kya hota hai?",
              "answer": "Background thread jo JVM ke terminate hone par automatically end ho jata hai"
            }
          ],
          "detailed_explanation": {
            "example_code": "// Method 1: Extending Thread class\nclass MyThread extends Thread {\n    private String name;\n    \n    MyThread(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public void run() {\n        for(int i = 1; i <= 5; i++) {\n            System.out.println(name + \": \" + i);\n            try {\n                Thread.sleep(500);  // Pause for 500ms\n            } catch(InterruptedException e) {\n                System.out.println(name + \" interrupted\");\n            }\n        }\n    }\n}\n\n// Method 2: Implementing Runnable interface\nclass MyRunnable implements Runnable {\n    private String name;\n    \n    MyRunnable(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public void run() {\n        for(int i = 1; i <= 5; i++) {\n            System.out.println(name + \": \" + i);\n            try {\n                Thread.sleep(500);\n            } catch(InterruptedException e) {\n                System.out.println(name + \" interrupted\");\n            }\n        }\n    }\n}\n\npublic class ThreadBasics {\n    public static void main(String[] args) {\n        System.out.println(\"Main thread started: \" + Thread.currentThread().getName());\n        \n        // Creating thread by extending Thread class\n        MyThread thread1 = new MyThread(\"Thread-1\");\n        thread1.start();  // Starts new thread\n        \n        // Creating thread by implementing Runnable\n        Thread thread2 = new Thread(new MyRunnable(\"Thread-2\"));\n        thread2.start();\n        \n        // Creating thread using lambda (Java 8+)\n        Thread thread3 = new Thread(() -> {\n            for(int i = 1; i <= 5; i++) {\n                System.out.println(\"Lambda-Thread: \" + i);\n                try {\n                    Thread.sleep(500);\n                } catch(InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, \"LambdaThread\");\n        thread3.start();\n        \n        // Thread methods\n        System.out.println(\"Thread1 ID: \" + thread1.getId());\n        System.out.println(\"Thread1 Name: \" + thread1.getName());\n        System.out.println(\"Thread1 Priority: \" + thread1.getPriority());\n        System.out.println(\"Thread1 State: \" + thread1.getState());\n        \n        // Thread priority (1-10)\n        thread1.setPriority(Thread.MIN_PRIORITY);  // 1\n        thread2.setPriority(Thread.NORM_PRIORITY); // 5\n        thread3.setPriority(Thread.MAX_PRIORITY);  // 10\n        \n        // Daemon thread (background thread)\n        Thread daemonThread = new Thread(() -> {\n            while(true) {\n                System.out.println(\"Daemon working...\");\n                try {\n                    Thread.sleep(1000);\n                } catch(InterruptedException e) {\n                    break;\n                }\n            }\n        });\n        daemonThread.setDaemon(true);  // Set as daemon before start\n        daemonThread.start();\n        \n        // join() - Wait for thread to complete\n        try {\n            thread1.join();  // Main thread waits for thread1\n            thread2.join();  // Main thread waits for thread2\n            thread3.join();  // Main thread waits for thread3\n        } catch(InterruptedException e) {\n            e.printStackTrace();\n        }\n        \n        // yield() - Hint to scheduler\n        Thread.yield();  // Current thread willing to yield processor\n        \n        System.out.println(\"All threads completed\");\n        \n        // Thread states during lifecycle\n        Thread demoThread = new Thread(() -> {\n            try {\n                Thread.sleep(2000);  // TIMED_WAITING state\n            } catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        System.out.println(\"Before start: \" + demoThread.getState());  // NEW\n        demoThread.start();\n        System.out.println(\"After start: \" + demoThread.getState());   // RUNNABLE\n        \n        try {\n            Thread.sleep(100);\n            System.out.println(\"During sleep: \" + demoThread.getState());  // TIMED_WAITING\n            demoThread.join();\n            System.out.println(\"After completion: \" + demoThread.getState());  // TERMINATED\n        } catch(InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}",
            "components": [
              {
                "name": "Runnable Interface",
                "english": "Preferred way to create threads",
                "hinglish": "Threads banane ka preferred tarika",
                "importance": "High",
                "tip": "Use Runnable over extending Thread for better design",
                "role": "Define thread task without inheritance",
                "pros": "Flexible, can extend other classes",
                "cons": "Extra step to create Thread object",
                "example": "Thread t = new Thread(new MyRunnable());",
                "use_case": "Most thread creation scenarios"
              }
            ],
            "comparison_table": {
              "headers": ["Aspect", "Extending Thread", "Implementing Runnable"],
              "rows": [
                ["Inheritance", "Uses inheritance", "Uses interface"],
                ["Flexibility", "Cannot extend other class", "Can extend other class"],
                ["Code separation", "Thread and task combined", "Thread and task separate"],
                ["Reusability", "Less reusable", "More reusable"],
                ["Recommended", "No", "Yes"]
              ]
            },
            "decision_table": {
              "headers": ["Requirement", "Approach"],
              "rows": [
                ["Simple thread", "Extend Thread"],
                ["Better design", "Implement Runnable"],
                ["Thread pool", "Implement Runnable/Callable"],
                ["Return value needed", "Implement Callable"],
                ["Lambda expression", "Runnable with lambda"]
              ]
            },
            "best_practices": [
              {
                "practice": "Thread creation ke liye Runnable interface prefer karein",
                "reason": "Better design, more flexible",
                "hinglish": "Threads banane ke liye Runnable interface use karo"
              }
            ]
          }
        },
        {
          "id": 8,
          "title": "Thread Synchronization",
          "english": "Managing shared resources and thread coordination",
          "hinglish": "Shared resources manage karna aur thread coordination",
          "examples": [
            "// Synchronized method\nsynchronized void increment() {\n    count++;\n}\n\n// Synchronized block\nsynchronized(this) {\n    count++;\n}\n\n// wait() and notify()\nsynchronized(obj) {\n    obj.wait();\n    obj.notify();\n}"
          ],
          "practice": [
            {
              "question": "Synchronization kyun zaroori hai?",
              "answer": "Multiple threads ke shared resource access ko control karne ke liye"
            },
            {
              "question": "synchronized method aur synchronized block mein kya antar hai?",
              "answer": "Method: whole method synchronized, Block: specific code section synchronized"
            },
            {
              "question": "wait(), notify(), notifyAll() ka use kya hai?",
              "answer": "Threads ke beech communication ke liye"
            },
            {
              "question": "Deadlock kya hota hai?",
              "answer": "Do threads ek dusre ka wait kar rahe hain, dono block ho jate hain"
            }
          ],
          "detailed_explanation": {
            "example_code": "// Problem: Shared counter without synchronization\nclass Counter {\n    private int count = 0;\n    \n    // Unsafe method\n    public void increment() {\n        count++;  // Not thread-safe\n    }\n    \n    // Synchronized method\n    public synchronized void incrementSync() {\n        count++;\n    }\n    \n    // Synchronized block\n    public void incrementBlock() {\n        synchronized(this) {\n            count++;\n        }\n    }\n    \n    public int getCount() {\n        return count;\n    }\n}\n\n// Producer-Consumer with wait-notify\nclass SharedResource {\n    private int data;\n    private boolean available = false;\n    \n    public synchronized void produce(int value) {\n        while(available) {  // Wait if data not consumed\n            try {\n                wait();  // Releases lock and waits\n            } catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        data = value;\n        available = true;\n        System.out.println(\"Produced: \" + value);\n        notify();  // Notify consumer\n    }\n    \n    public synchronized int consume() {\n        while(!available) {  // Wait if data not produced\n            try {\n                wait();\n            } catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        available = false;\n        System.out.println(\"Consumed: \" + data);\n        notify();  // Notify producer\n        return data;\n    }\n}\n\npublic class ThreadSyncExample {\n    public static void main(String[] args) throws InterruptedException {\n        // Synchronization example\n        Counter counter = new Counter();\n        \n        // Create multiple threads that increment counter\n        Thread[] threads = new Thread[10];\n        for(int i = 0; i < threads.length; i++) {\n            threads[i] = new Thread(() -> {\n                for(int j = 0; j < 1000; j++) {\n                    counter.incrementSync();  // Using synchronized method\n                }\n            });\n            threads[i].start();\n        }\n        \n        // Wait for all threads to complete\n        for(Thread t : threads) {\n            t.join();\n        }\n        \n        System.out.println(\"Final count (should be 10000): \" + counter.getCount());\n        \n        // Producer-Consumer example\n        SharedResource resource = new SharedResource();\n        \n        Thread producer = new Thread(() -> {\n            for(int i = 1; i <= 5; i++) {\n                resource.produce(i);\n                try {\n                    Thread.sleep(1000);\n                } catch(InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        \n        Thread consumer = new Thread(() -> {\n            for(int i = 1; i <= 5; i++) {\n                int value = resource.consume();\n                try {\n                    Thread.sleep(1500);\n                } catch(InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        \n        producer.start();\n        consumer.start();\n        \n        producer.join();\n        consumer.join();\n        \n        // Deadlock example\n        Object lock1 = new Object();\n        Object lock2 = new Object();\n        \n        Thread thread1 = new Thread(() -> {\n            synchronized(lock1) {\n                System.out.println(\"Thread1: Holding lock1...\");\n                try { Thread.sleep(100); } catch(InterruptedException e) {}\n                System.out.println(\"Thread1: Waiting for lock2...\");\n                synchronized(lock2) {\n                    System.out.println(\"Thread1: Acquired both locks\");\n                }\n            }\n        });\n        \n        Thread thread2 = new Thread(() -> {\n            synchronized(lock2) {\n                System.out.println(\"Thread2: Holding lock2...\");\n                try { Thread.sleep(100); } catch(InterruptedException e) {}\n                System.out.println(\"Thread2: Waiting for lock1...\");\n                synchronized(lock1) {\n                    System.out.println(\"Thread2: Acquired both locks\");\n                }\n            }\n        });\n        \n        thread1.start();\n        thread2.start();\n        \n        // ReentrantLock example (java.util.concurrent)\n        java.util.concurrent.locks.ReentrantLock lock = new java.util.concurrent.locks.ReentrantLock();\n        \n        Thread reentrantThread = new Thread(() -> {\n            lock.lock();  // Acquire lock\n            try {\n                System.out.println(\"ReentrantLock: Critical section\");\n                Thread.sleep(1000);\n            } catch(InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();  // Always unlock in finally\n            }\n        });\n        \n        reentrantThread.start();\n        reentrantThread.join();\n        \n        System.out.println(\"All synchronization examples completed\");\n    }\n}",
            "components": [
              {
                "name": "synchronized keyword",
                "english": "Creates mutually exclusive sections of code",
                "hinglish": "Code ke mutually exclusive sections banata hai",
                "importance": "High",
                "tip": "Synchronize on the smallest possible code section",
                "role": "Prevent race conditions",
                "pros": "Simple, built-in",
                "cons": "Performance overhead, deadlock risk",
                "example": "synchronized void method() { } or synchronized(obj) { }",
                "use_case": "When multiple threads access shared data"
              }
            ],
            "comparison_table": {
              "headers": ["Synchronization", "synchronized", "ReentrantLock"],
              "rows": [
                ["Implementation", "Language keyword", "Class in java.util.concurrent"],
                ["Flexibility", "Basic", "Advanced (tryLock, fairness)"],
                ["Performance", "Good", "Better in contention"],
                ["Lock acquisition", "Automatic", "Manual lock()/unlock()"],
                ["Try lock", "No", "Yes (tryLock())"],
                ["Interruption", "No", "Yes (lockInterruptibly())"]
              ]
            },
            "decision_table": {
              "headers": ["Requirement", "Use"],
              "rows": [
                ["Simple synchronization", "synchronized"],
                ["Advanced features needed", "ReentrantLock"],
                ["Try-acquire lock", "ReentrantLock.tryLock()"],
                ["Fairness needed", "ReentrantLock with fairness"],
                ["Basic mutual exclusion", "synchronized"]
              ]
            },
            "best_practices": [
              {
                "practice": "synchronized block use karein, synchronized method se bachne ki koshish karein",
                "reason": "Better performance, smaller lock scope",
                "hinglish": "synchronized method ki jagah synchronized block use karo"
              }
            ]
          }
        },
        {
          "id": 9,
          "title": "java.util.concurrent Package",
          "english": "High-level concurrency utilities",
          "hinglish": "High-level concurrency utilities",
          "examples": [
            "// ExecutorService\nExecutorService executor = Executors.newFixedThreadPool(5);\nexecutor.submit(() -> System.out.println(\"Task\"));\n\n// Concurrent collections\nConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\n\n// CountDownLatch\nCountDownLatch latch = new CountDownLatch(3);"
          ],
          "practice": [
            {
              "question": "ExecutorService kya hota hai?",
              "answer": "Thread pool manage karne ka high-level API"
            },
            {
              "question": "Callable aur Runnable mein kya antar hai?",
              "answer": "Callable value return karta hai aur exception throw kar sakta hai"
            },
            {
              "question": "ConcurrentHashMap regular HashMap se kaise different hai?",
              "answer": "Thread-safe hai aur better performance deti hai concurrent access mein"
            },
            {
              "question": "CountDownLatch ka use kya hai?",
              "answer": "Threads ko wait karana jab tak specific count zero na ho jaye"
            }
          ],
          "detailed_explanation": {
            "example_code": "import java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\nimport java.util.concurrent.locks.*;\n\npublic class ConcurrentExamples {\n    public static void main(String[] args) throws Exception {\n        // 1. Executor Framework\n        System.out.println(\"=== Executor Framework ===\");\n        ExecutorService executor = Executors.newFixedThreadPool(3);\n        \n        // Runnable task (no return value)\n        executor.submit(() -> {\n            System.out.println(\"Runnable task executed by \" + Thread.currentThread().getName());\n        });\n        \n        // Callable task (returns value)\n        Future<Integer> future = executor.submit(() -> {\n            System.out.println(\"Callable task calculating...\");\n            Thread.sleep(1000);\n            return 42;\n        });\n        \n        // Get result from Future\n        System.out.println(\"Callable result: \" + future.get());\n        \n        // Multiple tasks\n        List<Callable<String>> tasks = new ArrayList<>();\n        for(int i = 1; i <= 5; i++) {\n            final int taskId = i;\n            tasks.add(() -> {\n                return \"Task \" + taskId + \" completed by \" + Thread.currentThread().getName();\n            });\n        }\n        \n        // Invoke all tasks\n        List<Future<String>> results = executor.invokeAll(tasks);\n        for(Future<String> result : results) {\n            System.out.println(result.get());\n        }\n        \n        executor.shutdown();\n        \n        // 2. Concurrent Collections\n        System.out.println(\"\\n=== Concurrent Collections ===\");\n        ConcurrentHashMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();\n        concurrentMap.put(\"A\", 1);\n        concurrentMap.put(\"B\", 2);\n        concurrentMap.putIfAbsent(\"A\", 100);  // Won't replace\n        System.out.println(\"ConcurrentMap: \" + concurrentMap);\n        \n        // Concurrent modification is safe\n        concurrentMap.forEach(2, (k, v) -> \n            System.out.println(\"Key: \" + k + \", Value: \" + v + \" by \" + Thread.currentThread().getName()));\n        \n        // 3. Atomic Variables\n        System.out.println(\"\\n=== Atomic Variables ===\");\n        AtomicInteger atomicInt = new AtomicInteger(0);\n        \n        // Thread-safe increment\n        atomicInt.incrementAndGet();\n        atomicInt.addAndGet(5);\n        System.out.println(\"Atomic Integer: \" + atomicInt.get());\n        \n        // Compare and set\n        boolean updated = atomicInt.compareAndSet(6, 10);\n        System.out.println(\"CAS updated: \" + updated + \", Value: \" + atomicInt.get());\n        \n        // 4. CountDownLatch\n        System.out.println(\"\\n=== CountDownLatch ===\");\n        CountDownLatch latch = new CountDownLatch(3);\n        \n        for(int i = 1; i <= 3; i++) {\n            new Thread(() -> {\n                System.out.println(Thread.currentThread().getName() + \" working...\");\n                try {\n                    Thread.sleep(1000);\n                } catch(InterruptedException e) {\n                    e.printStackTrace();\n                }\n                latch.countDown();\n                System.out.println(Thread.currentThread().getName() + \" finished\");\n            }).start();\n        }\n        \n        latch.await();  // Main thread waits for count to reach 0\n        System.out.println(\"All threads completed, main continues\");\n        \n        // 5. CyclicBarrier\n        System.out.println(\"\\n=== CyclicBarrier ===\");\n        CyclicBarrier barrier = new CyclicBarrier(3, () -> {\n            System.out.println(\"All parties reached barrier, proceeding together\");\n        });\n        \n        for(int i = 1; i <= 3; i++) {\n            final int id = i;\n            new Thread(() -> {\n                try {\n                    System.out.println(\"Thread \" + id + \" reached barrier\");\n                    barrier.await();  // Wait for others\n                    System.out.println(\"Thread \" + id + \" passed barrier\");\n                } catch(Exception e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        }\n        \n        Thread.sleep(2000);\n        \n        // 6. Semaphore\n        System.out.println(\"\\n=== Semaphore ===\");\n        Semaphore semaphore = new Semaphore(2);  // Only 2 permits\n        \n        for(int i = 1; i <= 5; i++) {\n            final int id = i;\n            new Thread(() -> {\n                try {\n                    semaphore.acquire();\n                    System.out.println(\"Thread \" + id + \" acquired permit, available: \" + semaphore.availablePermits());\n                    Thread.sleep(2000);\n                    System.out.println(\"Thread \" + id + \" releasing permit\");\n                    semaphore.release();\n                } catch(InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        }\n        \n        Thread.sleep(7000);\n        \n        // 7. ReadWriteLock\n        System.out.println(\"\\n=== ReadWriteLock ===\");\n        ReadWriteLock rwLock = new ReentrantReadWriteLock();\n        List<String> data = new ArrayList<>();\n        \n        // Multiple readers can read simultaneously\n        for(int i = 1; i <= 3; i++) {\n            final int id = i;\n            new Thread(() -> {\n                rwLock.readLock().lock();\n                try {\n                    System.out.println(\"Reader \" + id + \" reading, size: \" + data.size());\n                    Thread.sleep(1000);\n                } catch(InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    rwLock.readLock().unlock();\n                }\n            }).start();\n        }\n        \n        // Only one writer at a time\n        new Thread(() -> {\n            rwLock.writeLock().lock();\n            try {\n                System.out.println(\"Writer writing...\");\n                data.add(\"New Item\");\n                Thread.sleep(2000);\n                System.out.println(\"Writer finished\");\n            } catch(InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                rwLock.writeLock().unlock();\n            }\n        }).start();\n        \n        Thread.sleep(5000);\n        System.out.println(\"\\nAll concurrent examples completed\");\n    }\n}",
            "components": [
              {
                "name": "ExecutorService",
                "english": "Higher-level replacement for working directly with threads",
                "hinglish": "Direct threads ki jagah use karne ka higher-level API",
                "importance": "High",
                "tip": "Always shutdown executor when done",
                "role": "Thread pool management, task execution",
                "pros": "Efficient, manageable, feature-rich",
                "cons": "Learning curve",
                "example": "Executors.newFixedThreadPool(5)",
                "use_case": "Most concurrent programming needs"
              }
            ],
            "comparison_table": {
              "headers": ["Utility", "Purpose", "When to Use"],
              "rows": [
                ["ExecutorService", "Thread pool management", "Task execution, thread reuse"],
                ["ConcurrentHashMap", "Thread-safe map", "Concurrent key-value storage"],
                ["CountDownLatch", "Wait for completion", "One-time synchronization"],
                ["CyclicBarrier", "Wait at barrier point", "Reusable synchronization"],
                ["Semaphore", "Limit resource access", "Pool of resources"],
                ["Atomic variables", "Lock-free updates", "Counter, flags"],
                ["ReadWriteLock", "Multiple reads/single write", "Read-heavy data structures"]
              ]
            },
            "decision_table": {
              "headers": ["Requirement", "Concurrent Utility"],
              "rows": [
                ["Thread pool needed", "ExecutorService"],
                ["Thread-safe map", "ConcurrentHashMap"],
                ["Wait for N tasks", "CountDownLatch"],
                ["Meet at barrier", "CyclicBarrier"],
                ["Limit concurrent access", "Semaphore"],
                ["Lock-free counter", "AtomicInteger"],
                ["Read-heavy shared data", "ReadWriteLock"]
              ]
            },
            "best_practices": [
              {
                "practice": "ExecutorService ko hamesha shutdown karein",
                "reason": "Resource leak se bachne ke liye",
                "hinglish": "ExecutorService use karne ke baad hamesha shutdown karo"
              }
            ]
          }
        },
        {
          "id": 10,
          "title": "Java I/O Streams",
          "english": "Input/Output operations using streams",
          "hinglish": "Streams ka use karke Input/Output operations",
          "examples": [
            "// Byte stream\nFileInputStream fis = new FileInputStream(\"file.txt\");\n\n// Character stream\nFileReader reader = new FileReader(\"file.txt\");\n\n// Buffered stream\nBufferedReader br = new BufferedReader(new FileReader(\"file.txt\"));"
          ],
          "practice": [
            {
              "question": "Byte streams aur character streams mein kya antar hai?",
              "answer": "Byte: raw data (images), Character: text data (16-bit Unicode)"
            },
            {
              "question": "Buffered streams ka fayda kya hai?",
              "answer": "Performance improve karta hai by reducing physical I/O operations"
            },
            {
              "question": "Serialization kya hota hai?",
              "answer": "Object ko byte stream mein convert karna for storage/transmission"
            },
            {
              "question": "transient keyword ka use kya hai?",
              "answer": "Variables ko serialization se exclude karne ke liye"
            }
          ],
          "detailed_explanation": {
            "example_code": "import java.io.*;\nimport java.nio.file.*;\nimport java.util.*;\n\n// Serializable class\nclass Employee implements Serializable {\n    private static final long serialVersionUID = 1L;\n    \n    private String name;\n    private int id;\n    private transient double salary;  // Won't be serialized\n    private static String company = \"ABC Corp\";  // Static not serialized\n    \n    public Employee(String name, int id, double salary) {\n        this.name = name;\n        this.id = id;\n        this.salary = salary;\n    }\n    \n    @Override\n    public String toString() {\n        return \"Employee[name=\" + name + \", id=\" + id + \", salary=\" + salary + \", company=\" + company + \"]\";\n    }\n}\n\npublic class IOStreamsExample {\n    public static void main(String[] args) {\n        // 1. Byte Streams (for binary data)\n        try (FileInputStream fis = new FileInputStream(\"test.txt\");\n             FileOutputStream fos = new FileOutputStream(\"copy.txt\")) {\n            \n            int byteData;\n            while((byteData = fis.read()) != -1) {\n                fos.write(byteData);\n            }\n            System.out.println(\"File copied using byte streams\");\n            \n        } catch(IOException e) {\n            System.out.println(\"Using default file operations\");\n        }\n        \n        // 2. Character Streams (for text data)\n        try (FileReader reader = new FileReader(\"test.txt\");\n             FileWriter writer = new FileWriter(\"text_copy.txt\")) {\n            \n            int charData;\n            while((charData = reader.read()) != -1) {\n                writer.write(charData);\n            }\n            System.out.println(\"Text file copied using character streams\");\n            \n        } catch(IOException e) {\n            // Continue with examples\n        }\n        \n        // 3. Buffered Streams (better performance)\n        try (BufferedReader br = new BufferedReader(new FileReader(\"test.txt\"));\n             BufferedWriter bw = new BufferedWriter(new FileWriter(\"buffered_copy.txt\"))) {\n            \n            String line;\n            while((line = br.readLine()) != null) {\n                bw.write(line);\n                bw.newLine();\n            }\n            System.out.println(\"File copied using buffered streams\");\n            \n        } catch(IOException e) {\n            // Continue\n        }\n        \n        // 4. Serialization and Deserialization\n        Employee emp = new Employee(\"John Doe\", 101, 50000.0);\n        \n        // Serialize object\n        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"employee.ser\"))) {\n            oos.writeObject(emp);\n            System.out.println(\"Employee object serialized\");\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n        \n        // Deserialize object\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"employee.ser\"))) {\n            Employee deserializedEmp = (Employee) ois.readObject();\n            System.out.println(\"Deserialized: \" + deserializedEmp);\n            // Note: salary will be 0.0 (transient), company will be null (static)\n        } catch(IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n        \n        // 5. Scanner for input\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"\\nEnter your name: \");\n        String name = scanner.nextLine();\n        System.out.println(\"Hello, \" + name);\n        scanner.close();\n        \n        // 6. File class operations\n        File file = new File(\"example.txt\");\n        System.out.println(\"\\nFile operations:\");\n        System.out.println(\"Exists: \" + file.exists());\n        System.out.println(\"Name: \" + file.getName());\n        System.out.println(\"Path: \" + file.getPath());\n        System.out.println(\"Absolute Path: \" + file.getAbsolutePath());\n        System.out.println(\"Is Directory: \" + file.isDirectory());\n        System.out.println(\"Size: \" + file.length() + \" bytes\");\n        \n        // 7. NIO (New I/O) - Java 7+\n        try {\n            // Read all lines from file\n            List<String> lines = Files.readAllLines(Paths.get(\"test.txt\"));\n            System.out.println(\"\\nFile content (NIO):\");\n            lines.forEach(System.out::println);\n            \n            // Write to file\n            Files.write(Paths.get(\"nio_output.txt\"), \n                       Arrays.asList(\"Line 1\", \"Line 2\", \"Line 3\"),\n                       StandardOpenOption.CREATE);\n            \n            // Copy file\n            Files.copy(Paths.get(\"test.txt\"), \n                      Paths.get(\"nio_copy.txt\"),\n                      StandardCopyOption.REPLACE_EXISTING);\n            \n            System.out.println(\"NIO operations completed\");\n            \n        } catch(IOException e) {\n            System.out.println(\"NIO examples skipped - files not found\");\n        }\n        \n        // 8. Try-with-resources (Auto-closeable)\n        try (PrintWriter pw = new PrintWriter(new FileWriter(\"auto_close.txt\"))) {\n            pw.println(\"This file will auto-close\");\n            pw.printf(\"Formatted: %s %d %f\", \"text\", 100, 99.99);\n            System.out.println(\"\\nTry-with-resources example completed\");\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n        \n        // Clean up created files\n        try {\n            Files.deleteIfExists(Paths.get(\"copy.txt\"));\n            Files.deleteIfExists(Paths.get(\"text_copy.txt\"));\n            Files.deleteIfExists(Paths.get(\"buffered_copy.txt\"));\n            Files.deleteIfExists(Paths.get(\"employee.ser\"));\n            Files.deleteIfExists(Paths.get(\"nio_output.txt\"));\n            Files.deleteIfExists(Paths.get(\"nio_copy.txt\"));\n            Files.deleteIfExists(Paths.get(\"auto_close.txt\"));\n        } catch(IOException e) {\n            // Ignore cleanup errors\n        }\n        \n        System.out.println(\"\\nAll I/O examples completed\");\n    }\n}",
            "components": [
              {
                "name": "Serialization",
                "english": "Converting objects to byte stream for storage/transmission",
                "hinglish": "Objects ko byte stream mein convert karna storage/transmission ke liye",
                "importance": "Medium",
                "tip": "Always declare serialVersionUID for version control",
                "role": "Object persistence, network transmission",
                "pros": "Easy object storage, RMI support",
                "cons": "Versioning issues, security concerns",
                "example": "implements Serializable, ObjectOutputStream, ObjectInputStream",
                "use_case": "Saving objects to file, sending over network"
              }
            ],
            "comparison_table": {
              "headers": ["Stream Type", "For Data Type", "Example Classes"],
              "rows": [
                ["Byte Streams", "Binary data (images, audio)", "FileInputStream, FileOutputStream"],
                ["Character Streams", "Text data", "FileReader, FileWriter"],
                ["Buffered Streams", "Performance improvement", "BufferedReader, BufferedWriter"],
                ["Object Streams", "Java objects", "ObjectInputStream, ObjectOutputStream"],
                ["Data Streams", "Primitive types", "DataInputStream, DataOutputStream"]
              ]
            },
            "decision_table": {
              "headers": ["Requirement", "Use"],
              "rows": [
                ["Binary file processing", "Byte streams"],
                ["Text file processing", "Character streams"],
                ["Performance critical", "Buffered streams"],
                ["Object storage", "Object streams"],
                ["Primitive type I/O", "Data streams"],
                ["Modern file operations", "NIO (Files, Paths)"]
              ]
            },
            "best_practices": [
              {
                "practice": "Try-with-resources ka use karein streams ke liye",
                "reason": "Automatic resource management, no memory leaks",
                "hinglish": "Streams ke liye try-with-resources use karo, automatic close hoga"
              }
            ]
          }
        },
        {
          "id": 11,
          "title": "Java 8+ Features - Lambda aur Streams",
          "english": "Modern Java features - Lambdas and Stream API",
          "hinglish": "Modern Java features - Lambdas aur Stream API",
          "examples": [
            "// Lambda expression\nRunnable r = () -> System.out.println(\"Hello Lambda\");\n\n// Stream API\nList<String> filtered = list.stream()\n    .filter(s -> s.startsWith(\"A\"))\n    .collect(Collectors.toList());\n\n// Optional\nOptional<String> opt = Optional.ofNullable(null);"
          ],
          "practice": [
            {
              "question": "Lambda expression kya hota hai?",
              "answer": "Anonymous function - parameter list, arrow, body"
            },
            {
              "question": "Functional interface kya hota hai?",
              "answer": "Interface jisme sirf ek abstract method ho"
            },
            {
              "question": "Stream API ke intermediate aur terminal operations kya hote hain?",
              "answer": "Intermediate: lazy (filter, map), Terminal: eager (collect, forEach)"
            },
            {
              "question": "Optional class kyun use karte hain?",
              "answer": "NullPointerException se bachne ke liye, explicitly handle null values"
            }
          ],
          "detailed_explanation": {
            "example_code": "import java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport java.time.*;\nimport java.time.format.*;\n\npublic class Java8Features {\n    public static void main(String[] args) {\n        System.out.println(\"=== LAMBDA EXPRESSIONS ===\");\n        \n        // 1. Lambda Expressions\n        // Old way: Anonymous class\n        Runnable oldRunnable = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"Old way\");\n            }\n        };\n        \n        // Lambda way\n        Runnable lambdaRunnable = () -> System.out.println(\"Lambda way\");\n        oldRunnable.run();\n        lambdaRunnable.run();\n        \n        // Lambda with parameters\n        Comparator<String> stringComparator = (s1, s2) -> s1.compareTo(s2);\n        System.out.println(\"Compare: \" + stringComparator.compare(\"Apple\", \"Banana\"));\n        \n        // 2. Functional Interfaces\n        // Predicate - boolean test(T t)\n        Predicate<Integer> isEven = n -> n % 2 == 0;\n        System.out.println(\"Is 10 even? \" + isEven.test(10));\n        \n        // Function - R apply(T t)\n        Function<String, Integer> stringLength = s -> s.length();\n        System.out.println(\"Length of 'Hello': \" + stringLength.apply(\"Hello\"));\n        \n        // Consumer - void accept(T t)\n        Consumer<String> printer = s -> System.out.println(\"Consuming: \" + s);\n        printer.accept(\"Test\");\n        \n        // Supplier - T get()\n        Supplier<Double> randomSupplier = () -> Math.random();\n        System.out.println(\"Random: \" + randomSupplier.get());\n        \n        System.out.println(\"\\n=== STREAM API ===\");\n        \n        // 3. Stream API\n        List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\", \"Anna\");\n        \n        // Intermediate operations (lazy)\n        List<String> result = names.stream()\n            .filter(name -> name.startsWith(\"A\"))  // Filter names starting with A\n            .map(String::toUpperCase)               // Convert to uppercase\n            .sorted()                               // Sort\n            .collect(Collectors.toList());          // Terminal operation\n        \n        System.out.println(\"Names starting with A: \" + result);\n        \n        // More stream operations\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n        \n        int sum = numbers.stream()\n            .filter(n -> n % 2 == 0)           // Even numbers\n            .mapToInt(n -> n * 2)              // Double each\n            .sum();                            // Sum all\n        \n        System.out.println(\"Sum of doubled evens: \" + sum);\n        \n        // Grouping\n        Map<Integer, List<String>> lengthGroups = names.stream()\n            .collect(Collectors.groupingBy(String::length));\n        System.out.println(\"Grouped by length: \" + lengthGroups);\n        \n        // Parallel stream\n        long count = names.parallelStream()\n            .filter(name -> name.length() > 3)\n            .count();\n        System.out.println(\"Names longer than 3 chars: \" + count);\n        \n        System.out.println(\"\\n=== METHOD REFERENCES ===\");\n        \n        // 4. Method References\n        // Static method reference\n        Function<String, Integer> parser = Integer::parseInt;\n        System.out.println(\"Parsed: \" + parser.apply(\"123\"));\n        \n        // Instance method reference\n        names.forEach(System.out::println);\n        \n        // Constructor reference\n        Supplier<List<String>> listSupplier = ArrayList::new;\n        List<String> newList = listSupplier.get();\n        newList.add(\"New item\");\n        System.out.println(\"New list: \" + newList);\n        \n        System.out.println(\"\\n=== OPTIONAL CLASS ===\");\n        \n        // 5. Optional - Avoid NullPointerException\n        Optional<String> optionalName = Optional.ofNullable(getName());\n        \n        // Old way\n        String name = getName();\n        if(name != null) {\n            System.out.println(\"Name length: \" + name.length());\n        }\n        \n        // Optional way\n        optionalName.ifPresent(n -> System.out.println(\"Optional name length: \" + n.length()));\n        \n        String defaultValue = optionalName.orElse(\"Default Name\");\n        System.out.println(\"Name or default: \" + defaultValue);\n        \n        // Chain operations safely\n        Optional<Integer> length = optionalName\n            .map(String::length)\n            .filter(l -> l > 3);\n        System.out.println(\"Filtered length: \" + length.orElse(0));\n        \n        System.out.println(\"\\n=== DEFAULT METHODS ===\");\n        \n        // 6. Default methods in interfaces\n        Calculator calc = new BasicCalculator();\n        System.out.println(\"Add: \" + calc.add(5, 3));\n        System.out.println(\"Multiply: \" + calc.multiply(5, 3));\n        \n        System.out.println(\"\\n=== DATE TIME API ===\");\n        \n        // 7. New Date-Time API (java.time)\n        // Current date\n        LocalDate today = LocalDate.now();\n        System.out.println(\"Today: \" + today);\n        \n        // Specific date\n        LocalDate independenceDay = LocalDate.of(1947, Month.AUGUST, 15);\n        System.out.println(\"Independence Day: \" + independenceDay);\n        \n        // Date manipulation\n        LocalDate nextWeek = today.plusWeeks(1);\n        System.out.println(\"Next week: \" + nextWeek);\n        \n        // Date difference\n        Period period = Period.between(independenceDay, today);\n        System.out.println(\"Years since independence: \" + period.getYears());\n        \n        // Time\n        LocalTime now = LocalTime.now();\n        System.out.println(\"Current time: \" + now);\n        \n        // DateTime\n        LocalDateTime dateTime = LocalDateTime.now();\n        System.out.println(\"Current date-time: \" + dateTime);\n        \n        // Formatting\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd-MMM-yyyy HH:mm\");\n        System.out.println(\"Formatted: \" + dateTime.format(formatter));\n        \n        System.out.println(\"\\n=== COMPLETABLEFUTURE ===\");\n        \n        // 8. CompletableFuture (async programming)\n        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n            try {\n                Thread.sleep(1000);\n            } catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n            return \"Async Result\";\n        });\n        \n        future.thenAccept(result -> System.out.println(\"Future completed: \" + result));\n        \n        // Chain async operations\n        CompletableFuture<Integer> chainFuture = CompletableFuture.supplyAsync(() -> \"Hello\")\n            .thenApplyAsync(String::length)\n            .thenApply(len -> len * 2);\n        \n        chainFuture.thenAccept(len -> System.out.println(\"Chained result: \" + len));\n        \n        // Wait for completion\n        try {\n            Thread.sleep(2000);\n        } catch(InterruptedException e) {\n            e.printStackTrace();\n        }\n        \n        System.out.println(\"\\nAll Java 8+ features demonstrated\");\n    }\n    \n    private static String getName() {\n        return Math.random() > 0.5 ? \"John\" : null;\n    }\n}\n\n// Interface with default method\ninterface Calculator {\n    int add(int a, int b);\n    \n    // Default method (Java 8)\n    default int multiply(int a, int b) {\n        return a * b;\n    }\n    \n    // Static method (Java 8)\n    static void info() {\n        System.out.println(\"Calculator Interface\");\n    }\n}\n\nclass BasicCalculator implements Calculator {\n    @Override\n    public int add(int a, int b) {\n        return a + b;\n    }\n}",
            "components": [
              {
                "name": "Stream API",
                "english": "Functional-style operations on collections",
                "hinglish": "Collections par functional-style operations",
                "importance": "High",
                "tip": "Streams are lazy - nothing happens until terminal operation",
                "role": "Process collections declaratively",
                "pros": "Concise, parallelizable, functional",
                "cons": "Learning curve, debugging harder",
                "example": "list.stream().filter().map().collect()",
                "use_case": "Collection processing, data transformation"
              }
            ],
            "comparison_table": {
              "headers": ["Feature", "Java 7 (Old)", "Java 8+ (New)"],
              "rows": [
                ["Collections processing", "Loops, iterators", "Stream API"],
                ["Anonymous classes", "Verbose syntax", "Lambda expressions"],
                ["Null handling", "Null checks", "Optional class"],
                ["Date/Time", "java.util.Date (mutable)", "java.time (immutable)"],
                ["Interface methods", "Only abstract", "Default/static methods"],
                ["Async programming", "Thread/Runnable", "CompletableFuture"]
              ]
            },
            "decision_table": {
              "headers": ["Requirement", "Java 8+ Feature"],
              "rows": [
                ["Collection processing", "Stream API"],
                ["Functional programming", "Lambda expressions"],
                ["Null safety", "Optional class"],
                ["Date manipulation", "java.time package"],
                ["Async operations", "CompletableFuture"],
                ["Interface evolution", "Default methods"]
              ]
            },
            "best_practices": [
              {
                "practice": "Streams use karte time method references prefer karein",
                "reason": "Cleaner, more readable code",
                "hinglish": "Streams mein method references use karo, code clean rahega"
              }
            ]
          }
        }
      ]
    },
    {
      "level": "Advanced to Professional",
      "order": 4,
      "description": "Generics, Annotations, JDBC, Networking, Web Technologies, Spring Framework, Hibernate",
      "topics": [
        {
          "id": 1,
          "title": "Generics",
          "english": "Type-safe collections and methods using generics",
          "hinglish": "Generics ka use karke type-safe collections aur methods",
          "examples": [
            "// Generic class\nclass Box<T> {\n    private T content;\n    public void set(T content) { this.content = content; }\n    public T get() { return content; }\n}\n\n// Generic method\n<T> void printArray(T[] array) {\n    for(T item : array) System.out.println(item);\n}"
          ],
          "practice": [
            {
              "question": "Generics ka main fayda kya hai?",
              "answer": "Type safety - compile time par type checking"
            },
            {
              "question": "Wildcards (?, ? extends, ? super) ka use kya hai?",
              "answer": "Unknown types handle karne ke liye"
            },
            {
              "question": "Type erasure kya hota hai?",
              "answer": "Compile time par generic type information remove ho jata hai"
            },
            {
              "question": "Bounded type parameters kaise define karte hain?",
              "answer": "<T extends Class> ya <T extends Interface>"
            }
          ],
          "detailed_explanation": {
            "example_code": "import java.util.*;\n\n// Generic class\nclass Container<T> {\n    private T value;\n    \n    public Container(T value) {\n        this.value = value;\n    }\n    \n    public T getValue() {\n        return value;\n    }\n    \n    public void setValue(T value) {\n        this.value = value;\n    }\n}\n\n// Multiple type parameters\nclass Pair<K, V> {\n    private K key;\n    private V value;\n    \n    public Pair(K key, V value) {\n        this.key = key;\n        this.value = value;\n    }\n    \n    public K getKey() { return key; }\n    public V getValue() { return value; }\n}\n\n// Bounded type parameter\nclass NumberContainer<T extends Number> {\n    private T number;\n    \n    public NumberContainer(T number) {\n        this.number = number;\n    }\n    \n    public double square() {\n        return number.doubleValue() * number.doubleValue();\n    }\n}\n\n// Generic method\nclass Utility {\n    // Generic method\n    public static <T> void printArray(T[] array) {\n        for(T element : array) {\n            System.out.print(element + \" \");\n        }\n        System.out.println();\n    }\n    \n    // Bounded generic method\n    public static <T extends Comparable<T>> T max(T a, T b, T c) {\n        T max = a;\n        if(b.compareTo(max) > 0) max = b;\n        if(c.compareTo(max) > 0) max = c;\n        return max;\n    }\n}\n\npublic class GenericsExample {\n    public static void main(String[] args) {\n        // Generic class usage\n        Container<String> stringContainer = new Container<>(\"Hello\");\n        System.out.println(\"String Container: \" + stringContainer.getValue());\n        \n        Container<Integer> intContainer = new Container<>(100);\n        System.out.println(\"Integer Container: \" + intContainer.getValue());\n        \n        // Multiple type parameters\n        Pair<String, Integer> pair = new Pair<>(\"Age\", 25);\n        System.out.println(\"Pair: \" + pair.getKey() + \" = \" + pair.getValue());\n        \n        // Bounded type parameter\n        NumberContainer<Integer> intNum = new NumberContainer<>(5);\n        System.out.println(\"Square: \" + intNum.square());\n        \n        // NumberContainer<String> strNum = new NumberContainer<>(\"5\"); // Compile error\n        \n        // Generic method\n        Integer[] intArray = {1, 2, 3, 4, 5};\n        String[] strArray = {\"A\", \"B\", \"C\"};\n        \n        Utility.printArray(intArray);\n        Utility.printArray(strArray);\n        \n        // Wildcards\n        List<Integer> intList = Arrays.asList(1, 2, 3);\n        List<Double> doubleList = Arrays.asList(1.1, 2.2, 3.3);\n        List<String> strList = Arrays.asList(\"A\", \"B\", \"C\");\n        \n        printList(intList);\n        printList(doubleList);\n        // printList(strList); // Compile error - ? extends Number\n        \n        // Upper bounded wildcard\n        System.out.println(\"Sum of ints: \" + sumOfList(intList));\n        System.out.println(\"Sum of doubles: \" + sumOfList(doubleList));\n        \n        // Lower bounded wildcard\n        List<Number> numbers = new ArrayList<>();\n        addNumbers(numbers);\n        System.out.println(\"Numbers: \" + numbers);\n    }\n    \n    // Unbounded wildcard\n    public static void printList(List<?> list) {\n        for(Object elem : list) {\n            System.out.print(elem + \" \");\n        }\n        System.out.println();\n    }\n    \n    // Upper bounded wildcard\n    public static double sumOfList(List<? extends Number> list) {\n        double sum = 0.0;\n        for(Number num : list) {\n            sum += num.doubleValue();\n        }\n        return sum;\n    }\n    \n    // Lower bounded wildcard\n    public static void addNumbers(List<? super Integer> list) {\n        for(int i = 1; i <= 5; i++) {\n            list.add(i);\n        }\n    }\n}",
            "components": [
              {
                "name": "Type Parameters",
                "english": "Placeholder for types in generic code",
                "hinglish": "Generic code mein types ke liye placeholder",
                "importance": "High",
                "tip": "Use single uppercase letters: T (Type), K (Key), V (Value), E (Element)",
                "role": "Create type-safe reusable code",
                "pros": "Type safety, code reuse, compile-time checking",
                "cons": "Complexity, type erasure limitations",
                "example": "class Box<T> { }, interface List<E> { }",
                "use_case": "Collections framework, utility classes"
              }
            ],
            "comparison_table": {
              "headers": ["Wildcard Type", "Meaning", "Use When"],
              "rows": [
                ["?", "Unknown type", "Any type acceptable"],
                ["? extends T", "T or its subtypes", "Reading from structure"],
                ["? super T", "T or its supertypes", "Writing to structure"],
                ["T", "Exact type T", "Both reading and writing"]
              ]
            },
            "decision_table": {
              "headers": ["Scenario", "Generics Approach"],
              "rows": [
                ["Type-safe collections", "Generic classes"],
                ["Type-independent algorithms", "Generic methods"],
                ["Flexible parameter types", "Wildcards"],
                ["Restricted type parameters", "Bounded type parameters"],
                ["Multiple related types", "Multiple type parameters"]
              ]
            },
            "best_practices": [
              {
                "practice": "Wildcards use karein jab possible ho",
                "reason": "Maximum flexibility ke liye",
                "hinglish": "Jab bhi possible ho, wildcards use karo"
              }
            ]
          }
        },
        {
          "id": 2,
          "title": "Annotations aur Reflection",
          "english": "Metadata programming using annotations and reflection",
          "hinglish": "Annotations aur reflection ka use karke metadata programming",
          "examples": [
            "// Custom annotation\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@interface MyAnnotation {\n    String value() default \"\";\n}\n\n// Using annotation\n@MyAnnotation(\"test\")\npublic void myMethod() { }\n\n// Reflection\nMethod method = obj.getClass().getMethod(\"myMethod\");"
          ],
          "practice": [
            {
              "question": "@Override annotation ka use kya hai?",
              "answer": "Compiler ko batana ki method parent class se override kar raha hai"
            },
            {
              "question": "Reflection API se kya kar sakte hain?",
              "answer": "Runtime par classes, methods, fields inspect aur modify kar sakte hain"
            },
            {
              "question": "@Retention annotation ka use?",
              "answer": "Define karta hai annotation kitni der tak retain rahega"
            },
            {
              "question": "Dynamic Proxy kya hota hai?",
              "answer": "Runtime par interface ka implementation create karna"
            }
          ],
          "detailed_explanation": {
            "example_code": "import java.lang.annotation.*;\nimport java.lang.reflect.*;\n\n// 1. Custom Annotation\n@Retention(RetentionPolicy.RUNTIME)  // Available at runtime\n@Target(ElementType.METHOD)          // Can be used on methods\n@interface Author {\n    String name();\n    String date() default \"2024-01-01\";\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\n@interface Version {\n    double number();\n    String description() default \"\";\n}\n\n// 2. Class using annotations\n@Version(number = 1.0, description = \"Main service class\")\nclass Service {\n    @Author(name = \"John Doe\", date = \"2024-03-15\")\n    @Deprecated\n    public void oldMethod() {\n        System.out.println(\"Old method implementation\");\n    }\n    \n    @Author(name = \"Jane Smith\")\n    public void newMethod() {\n        System.out.println(\"New method implementation\");\n    }\n    \n    private String secretData = \"Confidential\";\n}\n\n// 3. Annotation Processor\nclass AnnotationProcessor {\n    public static void processAnnotations(Object obj) throws Exception {\n        Class<?> clazz = obj.getClass();\n        \n        // Class level annotations\n        if(clazz.isAnnotationPresent(Version.class)) {\n            Version version = clazz.getAnnotation(Version.class);\n            System.out.println(\"Class Version: \" + version.number());\n            System.out.println(\"Description: \" + version.description());\n        }\n        \n        // Method level annotations\n        for(Method method : clazz.getDeclaredMethods()) {\n            if(method.isAnnotationPresent(Author.class)) {\n                Author author = method.getAnnotation(Author.class);\n                System.out.println(\"\\nMethod: \" + method.getName());\n                System.out.println(\"Author: \" + author.name());\n                System.out.println(\"Date: \" + author.date());\n                \n                // Invoke method using reflection\n                method.setAccessible(true);\n                method.invoke(obj);\n            }\n            \n            if(method.isAnnotationPresent(Deprecated.class)) {\n                System.out.println(\"WARNING: \" + method.getName() + \" is deprecated!\");\n            }\n        }\n    }\n}\n\n// 4. Dynamic Proxy Example\ninterface Calculator {\n    int add(int a, int b);\n    int multiply(int a, int b);\n}\n\nclass CalculatorImpl implements Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n    \n    public int multiply(int a, int b) {\n        return a * b;\n    }\n}\n\nclass LoggingHandler implements InvocationHandler {\n    private Object target;\n    \n    public LoggingHandler(Object target) {\n        this.target = target;\n    }\n    \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"Before method: \" + method.getName());\n        if(args != null) {\n            System.out.print(\"Arguments: \");\n            for(Object arg : args) {\n                System.out.print(arg + \" \");\n            }\n            System.out.println();\n        }\n        \n        Object result = method.invoke(target, args);\n        \n        System.out.println(\"After method: \" + method.getName());\n        System.out.println(\"Result: \" + result);\n        return result;\n    }\n}\n\npublic class AnnotationsReflectionExample {\n    public static void main(String[] args) throws Exception {\n        System.out.println(\"=== ANNOTATIONS EXAMPLE ===\");\n        Service service = new Service();\n        AnnotationProcessor.processAnnotations(service);\n        \n        System.out.println(\"\\n=== REFLECTION EXAMPLE ===\");\n        Class<?> serviceClass = Service.class;\n        \n        // Get class information\n        System.out.println(\"Class Name: \" + serviceClass.getName());\n        System.out.println(\"Simple Name: \" + serviceClass.getSimpleName());\n        System.out.println(\"Package: \" + serviceClass.getPackage().getName());\n        \n        // Get methods\n        System.out.println(\"\\nMethods:\");\n        for(Method method : serviceClass.getDeclaredMethods()) {\n            System.out.println(\" - \" + method.getName() + \": \" + \n                             Modifier.toString(method.getModifiers()));\n        }\n        \n        // Get fields (including private)\n        System.out.println(\"\\nFields:\");\n        for(Field field : serviceClass.getDeclaredFields()) {\n            System.out.println(\" - \" + field.getName() + \": \" + \n                             Modifier.toString(field.getModifiers()));\n            \n            // Access private field\n            if(field.getName().equals(\"secretData\")) {\n                field.setAccessible(true);\n                String value = (String) field.get(service);\n                System.out.println(\"   Value: \" + value);\n            }\n        }\n        \n        // Create instance using reflection\n        Constructor<?> constructor = serviceClass.getDeclaredConstructor();\n        Service newInstance = (Service) constructor.newInstance();\n        System.out.println(\"\\nNew instance created: \" + newInstance);\n        \n        System.out.println(\"\\n=== DYNAMIC PROXY EXAMPLE ===\");\n        Calculator realCalculator = new CalculatorImpl();\n        \n        // Create proxy with logging\n        Calculator proxyCalculator = (Calculator) Proxy.newProxyInstance(\n            Calculator.class.getClassLoader(),\n            new Class[]{Calculator.class},\n            new LoggingHandler(realCalculator)\n        );\n        \n        // Use proxy\n        int sum = proxyCalculator.add(10, 20);\n        int product = proxyCalculator.multiply(5, 6);\n        \n        System.out.println(\"\\nFinal Results:\");\n        System.out.println(\"Sum: \" + sum);\n        System.out.println(\"Product: \" + product);\n    }\n}",
            "components": [
              {
                "name": "@Retention Annotation",
                "english": "Specifies how long annotation is retained",
                "hinglish": "Define karta hai annotation kitni der tak retain rahega",
                "importance": "High",
                "tip": "Use RetentionPolicy.RUNTIME for reflection",
                "role": "Control annotation lifecycle",
                "pros": "Flexible annotation processing",
                "cons": "Memory overhead for RUNTIME",
                "example": "@Retention(RetentionPolicy.RUNTIME)",
                "use_case": "Annotations used by frameworks"
              }
            ],
            "comparison_table": {
              "headers": ["RetentionPolicy", "Available At", "Use Case"],
              "rows": [
                ["SOURCE", "Source code only", "@Override, @SuppressWarnings"],
                ["CLASS", "Class file (default)", "Bytecode tools"],
                ["RUNTIME", "Runtime (reflection)", "Spring, Hibernate annotations"]
              ]
            },
            "decision_table": {
              "headers": ["Requirement", "Use"],
              "rows": [
                ["Compile-time checking", "@Override style annotations"],
                ["Runtime processing", "RUNTIME retention annotations"],
                ["Dynamic behavior", "Reflection API"],
                ["AOP, logging", "Dynamic Proxy"],
                ["Framework development", "Custom annotations + reflection"]
              ]
            },
            "best_practices": [
              {
                "practice": "Reflection ka minimal use karein",
                "reason": "Performance overhead, security risks",
                "hinglish": "Reflection kam se kam use karo, performance par asar padta hai"
              }
            ]
          }
        },
        {
          "id": 3,
          "title": "JDBC (Java Database Connectivity)",
          "english": "Database operations using JDBC",
          "hinglish": "JDBC ka use karke database operations",
          "examples": [
            "// Load driver\nClass.forName(\"com.mysql.cj.jdbc.Driver\");\n\n// Create connection\nConnection conn = DriverManager.getConnection(url, user, pass);\n\n// Create statement\nStatement stmt = conn.createStatement();\nResultSet rs = stmt.executeQuery(\"SELECT * FROM users\");"
          ],
          "practice": [
            {
              "question": "JDBC ke 4 types ke drivers konse hain?",
              "answer": "Type 1: JDBC-ODBC, Type 2: Native API, Type 3: Network Protocol, Type 4: Pure Java"
            },
            {
              "question": "Statement aur PreparedStatement mein kya antar hai?",
              "answer": "PreparedStatement precompiled hai aur SQL injection se protect karta hai"
            },
            {
              "question": "Transaction management kaise karte hain?",
              "answer": "conn.setAutoCommit(false), conn.commit(), conn.rollback()"
            },
            {
              "question": "DAO pattern kya hota hai?",
              "answer": "Data Access Object - database operations ko encapsulate karta hai"
            }
          ],
          "detailed_explanation": {
            "example_code": "import java.sql.*;\nimport java.util.*;\n\n// Model class\nclass Employee {\n    private int id;\n    private String name;\n    private double salary;\n    \n    public Employee() {}\n    \n    public Employee(int id, String name, double salary) {\n        this.id = id;\n        this.name = name;\n        this.salary = salary;\n    }\n    \n    // Getters and setters\n    public int getId() { return id; }\n    public void setId(int id) { this.id = id; }\n    \n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n    \n    public double getSalary() { return salary; }\n    public void setSalary(double salary) { this.salary = salary; }\n    \n    @Override\n    public String toString() {\n        return \"Employee[id=\" + id + \", name=\" + name + \", salary=\" + salary + \"]\";\n    }\n}\n\n// DAO Interface\ninterface EmployeeDAO {\n    void addEmployee(Employee emp) throws SQLException;\n    Employee getEmployee(int id) throws SQLException;\n    List<Employee> getAllEmployees() throws SQLException;\n    void updateEmployee(Employee emp) throws SQLException;\n    void deleteEmployee(int id) throws SQLException;\n}\n\n// DAO Implementation\nclass EmployeeDAOImpl implements EmployeeDAO {\n    private Connection connection;\n    \n    public EmployeeDAOImpl(Connection connection) {\n        this.connection = connection;\n    }\n    \n    @Override\n    public void addEmployee(Employee emp) throws SQLException {\n        String sql = \"INSERT INTO employees(name, salary) VALUES(?, ?)\";\n        try (PreparedStatement pstmt = connection.prepareStatement(sql, \n                Statement.RETURN_GENERATED_KEYS)) {\n            \n            pstmt.setString(1, emp.getName());\n            pstmt.setDouble(2, emp.getSalary());\n            pstmt.executeUpdate();\n            \n            // Get generated ID\n            ResultSet rs = pstmt.getGeneratedKeys();\n            if(rs.next()) {\n                emp.setId(rs.getInt(1));\n            }\n        }\n    }\n    \n    @Override\n    public Employee getEmployee(int id) throws SQLException {\n        String sql = \"SELECT * FROM employees WHERE id = ?\";\n        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n            pstmt.setInt(1, id);\n            ResultSet rs = pstmt.executeQuery();\n            \n            if(rs.next()) {\n                return extractEmployee(rs);\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public List<Employee> getAllEmployees() throws SQLException {\n        List<Employee> employees = new ArrayList<>();\n        String sql = \"SELECT * FROM employees\";\n        \n        try (Statement stmt = connection.createStatement();\n             ResultSet rs = stmt.executeQuery(sql)) {\n            \n            while(rs.next()) {\n                employees.add(extractEmployee(rs));\n            }\n        }\n        return employees;\n    }\n    \n    @Override\n    public void updateEmployee(Employee emp) throws SQLException {\n        String sql = \"UPDATE employees SET name = ?, salary = ? WHERE id = ?\";\n        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n            pstmt.setString(1, emp.getName());\n            pstmt.setDouble(2, emp.getSalary());\n            pstmt.setInt(3, emp.getId());\n            pstmt.executeUpdate();\n        }\n    }\n    \n    @Override\n    public void deleteEmployee(int id) throws SQLException {\n        String sql = \"DELETE FROM employees WHERE id = ?\";\n        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n            pstmt.setInt(1, id);\n            pstmt.executeUpdate();\n        }\n    }\n    \n    private Employee extractEmployee(ResultSet rs) throws SQLException {\n        Employee emp = new Employee();\n        emp.setId(rs.getInt(\"id\"));\n        emp.setName(rs.getString(\"name\"));\n        emp.setSalary(rs.getDouble(\"salary\"));\n        return emp;\n    }\n}\n\n// Connection Manager\nclass ConnectionManager {\n    private static final String URL = \"jdbc:h2:mem:testdb\"; // H2 in-memory database\n    private static final String USER = \"sa\";\n    private static final String PASSWORD = \"\";\n    \n    public static Connection getConnection() throws SQLException {\n        return DriverManager.getConnection(URL, USER, PASSWORD);\n    }\n    \n    public static void initializeDatabase() throws SQLException {\n        try (Connection conn = getConnection();\n             Statement stmt = conn.createStatement()) {\n            \n            // Create table\n            String createTable = \"CREATE TABLE IF NOT EXISTS employees (\" +\n                                \"id INT PRIMARY KEY AUTO_INCREMENT, \" +\n                                \"name VARCHAR(50) NOT NULL, \" +\n                                \"salary DECIMAL(10, 2)\" +\n                                \")\";\n            stmt.execute(createTable);\n            \n            // Insert sample data\n            stmt.execute(\"INSERT INTO employees(name, salary) VALUES('John Doe', 50000)\");\n            stmt.execute(\"INSERT INTO employees(name, salary) VALUES('Jane Smith', 60000)\");\n        }\n    }\n}\n\npublic class JDBCExample {\n    public static void main(String[] args) {\n        try {\n            // Load driver (not needed for H2, automatically loaded)\n            // Class.forName(\"org.h2.Driver\");\n            \n            // Initialize database\n            ConnectionManager.initializeDatabase();\n            \n            // Get connection\n            Connection connection = ConnectionManager.getConnection();\n            \n            // Create DAO\n            EmployeeDAO employeeDAO = new EmployeeDAOImpl(connection);\n            \n            // Transaction management\n            connection.setAutoCommit(false);\n            \n            try {\n                System.out.println(\"=== ALL EMPLOYEES ===\");\n                List<Employee> employees = employeeDAO.getAllEmployees();\n                employees.forEach(System.out::println);\n                \n                System.out.println(\"\\n=== ADD NEW EMPLOYEE ===\");\n                Employee newEmp = new Employee(0, \"Bob Wilson\", 75000);\n                employeeDAO.addEmployee(newEmp);\n                System.out.println(\"Added: \" + newEmp);\n                \n                System.out.println(\"\\n=== GET EMPLOYEE BY ID ===\");\n                Employee emp = employeeDAO.getEmployee(1);\n                System.out.println(\"Found: \" + emp);\n                \n                System.out.println(\"\\n=== UPDATE EMPLOYEE ===\");\n                if(emp != null) {\n                    emp.setSalary(emp.getSalary() + 5000);\n                    employeeDAO.updateEmployee(emp);\n                    System.out.println(\"Updated: \" + emp);\n                }\n                \n                System.out.println(\"\\n=== BATCH PROCESSING ===\");\n                try (PreparedStatement pstmt = connection.prepareStatement(\n                        \"INSERT INTO employees(name, salary) VALUES(?, ?)\")) {\n                    \n                    for(int i = 1; i <= 3; i++) {\n                        pstmt.setString(1, \"Batch Employee \" + i);\n                        pstmt.setDouble(2, 30000 + i * 1000);\n                        pstmt.addBatch();\n                    }\n                    \n                    int[] results = pstmt.executeBatch();\n                    System.out.println(\"Batch insert completed. Rows: \" + Arrays.toString(results));\n                }\n                \n                // Commit transaction\n                connection.commit();\n                System.out.println(\"\\nTransaction committed successfully\");\n                \n                // Display all employees again\n                System.out.println(\"\\n=== FINAL EMPLOYEE LIST ===\");\n                employeeDAO.getAllEmployees().forEach(System.out::println);\n                \n                // ResultSetMetaData example\n                System.out.println(\"\\n=== RESULT SET METADATA ===\");\n                try (Statement stmt = connection.createStatement();\n                     ResultSet rs = stmt.executeQuery(\"SELECT * FROM employees\")) {\n                    \n                    ResultSetMetaData metaData = rs.getMetaData();\n                    int columnCount = metaData.getColumnCount();\n                    \n                    System.out.println(\"Table: \" + metaData.getTableName(1));\n                    System.out.println(\"Column Count: \" + columnCount);\n                    \n                    for(int i = 1; i <= columnCount; i++) {\n                        System.out.println(\"Column \" + i + \": \" + \n                                          metaData.getColumnName(i) + \" (\" + \n                                          metaData.getColumnTypeName(i) + \")\");\n                    }\n                }\n                \n            } catch(SQLException e) {\n                // Rollback on error\n                connection.rollback();\n                System.out.println(\"Transaction rolled back due to error: \" + e.getMessage());\n                throw e;\n            } finally {\n                connection.setAutoCommit(true);\n                connection.close();\n            }\n            \n            System.out.println(\"\\n=== CONNECTION POOLING EXAMPLE ===\");\n            System.out.println(\"In production, use libraries like HikariCP, Apache DBCP\");\n            \n        } catch(SQLException e) {\n            e.printStackTrace();\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
            "components": [
              {
                "name": "PreparedStatement",
                "english": "Precompiled SQL statement for repeated execution",
                "hinglish": "Repeated execution ke liye precompiled SQL statement",
                "importance": "High",
                "tip": "Always use PreparedStatement to prevent SQL injection",
                "role": "Execute parameterized SQL queries",
                "pros": "SQL injection protection, better performance",
                "cons": "Slightly more code",
                "example": "PreparedStatement pstmt = conn.prepareStatement(\"SELECT * FROM users WHERE id = ?\");",
                "use_case": "All database operations with parameters"
              }
            ],
            "comparison_table": {
              "headers": ["Statement Type", "Use When", "Security", "Performance"],
              "rows": [
                ["Statement", "Static SQL queries", "Low", "Good"],
                ["PreparedStatement", "Parameterized queries", "High", "Better"],
                ["CallableStatement", "Stored procedures", "High", "Good"]
              ]
            },
            "decision_table": {
              "headers": ["Scenario", "JDBC Approach"],
              "rows": [
                ["Simple static query", "Statement"],
                ["Parameterized query", "PreparedStatement"],
                ["Stored procedure", "CallableStatement"],
                ["Multiple operations", "Transaction management"],
                ["Multiple inserts/updates", "Batch processing"],
                ["Production application", "Connection pooling + DAO"]
              ]
            },
            "best_practices": [
              {
                "practice": "Resources (Connection, Statement, ResultSet) hamesha close karein try-with-resources se",
                "reason": "Resource leaks se bachne ke liye",
                "hinglish": "JDBC resources ko try-with-resources se hamesha close karo"
              }
            ]
          }
        },
        {
          "id": 4,
          "title": "Networking",
          "english": "Network programming using sockets",
          "hinglish": "Sockets ka use karke network programming",
          "examples": [
            "// Server socket\nServerSocket serverSocket = new ServerSocket(8080);\nSocket socket = serverSocket.accept();\n\n// Client socket\nSocket clientSocket = new Socket(\"localhost\", 8080);\n\n// URL connection\nURL url = new URL(\"http://example.com\");\nHttpURLConnection conn = (HttpURLConnection) url.openConnection();"
          ],
          "practice": [
            {
              "question": "TCP aur UDP mein kya antar hai?",
              "answer": "TCP: reliable, connection-oriented; UDP: unreliable, connectionless"
            },
            {
              "question": "ServerSocket.accept() method kya karta hai?",
              "answer": "Client connections wait karta hai aur Socket return karta hai"
            },
            {
              "question": "InetAddress class ka use kya hai?",
              "answer": "IP addresses represent karne ke liye"
            },
            {
              "question": "HttpURLConnection ka use kaise karte hain?",
              "answer": "HTTP requests send karne ke liye"
            }
          ],
          "detailed_explanation": {
            "example_code": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\n\n// Simple Echo Server\nclass EchoServer {\n    private ServerSocket serverSocket;\n    \n    public EchoServer(int port) throws IOException {\n        serverSocket = new ServerSocket(port);\n        System.out.println(\"Server started on port \" + port);\n    }\n    \n    public void start() {\n        while(true) {\n            try {\n                Socket clientSocket = serverSocket.accept();\n                System.out.println(\"Client connected: \" + clientSocket.getInetAddress());\n                \n                // Handle client in separate thread\n                new ClientHandler(clientSocket).start();\n                \n            } catch(IOException e) {\n                System.out.println(\"Server error: \" + e.getMessage());\n                break;\n            }\n        }\n    }\n    \n    public void stop() throws IOException {\n        serverSocket.close();\n    }\n}\n\nclass ClientHandler extends Thread {\n    private Socket clientSocket;\n    \n    public ClientHandler(Socket socket) {\n        this.clientSocket = socket;\n    }\n    \n    @Override\n    public void run() {\n        try (BufferedReader in = new BufferedReader(\n                new InputStreamReader(clientSocket.getInputStream()));\n             PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n            \n            String inputLine;\n            while((inputLine = in.readLine()) != null) {\n                System.out.println(\"Received: \" + inputLine);\n                \n                if(inputLine.equalsIgnoreCase(\"exit\")) {\n                    out.println(\"Goodbye!\");\n                    break;\n                }\n                \n                // Echo back\n                out.println(\"Echo: \" + inputLine);\n            }\n            \n            clientSocket.close();\n            System.out.println(\"Client disconnected\");\n            \n        } catch(IOException e) {\n            System.out.println(\"Client handler error: \" + e.getMessage());\n        }\n    }\n}\n\n// Simple Client\nclass EchoClient {\n    private Socket socket;\n    private BufferedReader in;\n    private PrintWriter out;\n    private BufferedReader consoleInput;\n    \n    public EchoClient(String host, int port) throws IOException {\n        socket = new Socket(host, port);\n        in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        out = new PrintWriter(socket.getOutputStream(), true);\n        consoleInput = new BufferedReader(new InputStreamReader(System.in));\n        \n        System.out.println(\"Connected to server at \" + host + \":\" + port);\n    }\n    \n    public void start() {\n        try {\n            // Thread for reading server responses\n            new Thread(this::readResponses).start();\n            \n            // Main thread for sending messages\n            String userInput;\n            while((userInput = consoleInput.readLine()) != null) {\n                out.println(userInput);\n                \n                if(userInput.equalsIgnoreCase(\"exit\")) {\n                    break;\n                }\n            }\n            \n        } catch(IOException e) {\n            System.out.println(\"Client error: \" + e.getMessage());\n        } finally {\n            close();\n        }\n    }\n    \n    private void readResponses() {\n        try {\n            String response;\n            while((response = in.readLine()) != null) {\n                System.out.println(\"Server: \" + response);\n            }\n        } catch(IOException e) {\n            System.out.println(\"Disconnected from server\");\n        }\n    }\n    \n    private void close() {\n        try {\n            in.close();\n            out.close();\n            socket.close();\n            consoleInput.close();\n        } catch(IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\npublic class NetworkingExample {\n    public static void main(String[] args) throws Exception {\n        System.out.println(\"=== SOCKET PROGRAMMING ===\");\n        \n        // Start server in separate thread\n        Thread serverThread = new Thread(() -> {\n            try {\n                EchoServer server = new EchoServer(8080);\n                server.start();\n            } catch(IOException e) {\n                e.printStackTrace();\n            }\n        });\n        serverThread.setDaemon(true);\n        serverThread.start();\n        \n        // Wait for server to start\n        Thread.sleep(1000);\n        \n        // Start client\n        System.out.println(\"\\nStarting client...\");\n        System.out.println(\"Type messages to send to server. Type 'exit' to quit.\");\n        \n        try {\n            EchoClient client = new EchoClient(\"localhost\", 8080);\n            client.start();\n        } catch(ConnectException e) {\n            System.out.println(\"Could not connect to server. Starting demo without client.\");\n        }\n        \n        Thread.sleep(2000);\n        \n        System.out.println(\"\\n=== URL AND HTTP CONNECTIONS ===\");\n        \n        // URL class examples\n        try {\n            URL url = new URL(\"https://jsonplaceholder.typicode.com/posts/1\");\n            \n            System.out.println(\"Protocol: \" + url.getProtocol());\n            System.out.println(\"Host: \" + url.getHost());\n            System.out.println(\"Port: \" + url.getPort());\n            System.out.println(\"Path: \" + url.getPath());\n            \n            // HTTP GET request\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"User-Agent\", \"Java-Networking-Example\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            \n            int responseCode = connection.getResponseCode();\n            System.out.println(\"\\nHTTP GET Response Code: \" + responseCode);\n            System.out.println(\"Response Message: \" + connection.getResponseMessage());\n            \n            // Read response\n            if(responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader reader = new BufferedReader(\n                    new InputStreamReader(connection.getInputStream()));\n                \n                String line;\n                StringBuilder response = new StringBuilder();\n                while((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                reader.close();\n                \n                System.out.println(\"Response Body (first 100 chars): \" + \n                    response.substring(0, Math.min(response.length(), 100)) + \"...\");\n            }\n            \n            connection.disconnect();\n            \n        } catch(Exception e) {\n            System.out.println(\"HTTP request failed: \" + e.getMessage());\n        }\n        \n        System.out.println(\"\\n=== INETADDRESS EXAMPLES ===\");\n        \n        // InetAddress examples\n        try {\n            // Get localhost address\n            InetAddress localhost = InetAddress.getLocalHost();\n            System.out.println(\"Local Host: \" + localhost);\n            System.out.println(\"Host Name: \" + localhost.getHostName());\n            System.out.println(\"Host Address: \" + localhost.getHostAddress());\n            System.out.println(\"Canonical Name: \" + localhost.getCanonicalHostName());\n            \n            // Get address by name\n            InetAddress googleAddress = InetAddress.getByName(\"www.google.com\");\n            System.out.println(\"\\nGoogle IP: \" + googleAddress.getHostAddress());\n            \n            // Check reachability\n            boolean reachable = googleAddress.isReachable(5000);\n            System.out.println(\"Is Google reachable? \" + reachable);\n            \n            // Get all IPs for a host\n            System.out.println(\"\\nAll IPs for Google:\");\n            InetAddress[] allGoogleIps = InetAddress.getAllByName(\"www.google.com\");\n            for(InetAddress addr : allGoogleIps) {\n                System.out.println(\" - \" + addr.getHostAddress());\n            }\n            \n        } catch(Exception e) {\n            System.out.println(\"InetAddress error: \" + e.getMessage());\n        }\n        \n        // UDP Example (Datagram)\n        System.out.println(\"\\n=== UDP DATAGRAM EXAMPLE ===\");\n        System.out.println(\"UDP is connectionless and uses DatagramSocket/DatagramPacket\");\n        \n        Thread.sleep(1000);\n        System.out.println(\"\\nNetworking examples completed\");\n    }\n}",
            "components": [
              {
                "name": "Socket",
                "english": "Endpoint for communication between machines",
                "hinglish": "Machines ke beech communication ka endpoint",
                "importance": "High",
                "tip": "Always close sockets in finally block or use try-with-resources",
                "role": "TCP network communication",
                "pros": "Reliable, stream-based",
                "cons": "Connection overhead",
                "example": "Socket socket = new Socket(\"localhost\", 8080);",
                "use_case": "Client-server applications"
              }
            ],
            "comparison_table": {
              "headers": ["Protocol", "Connection", "Reliability", "Use Case"],
              "rows": [
                ["TCP", "Connection-oriented", "High (guaranteed delivery)", "Web, email, file transfer"],
                ["UDP", "Connectionless", "Low (no guarantee)", "Video streaming, DNS, games"],
                ["HTTP", "Application layer", "High (over TCP)", "Web services, APIs"]
              ]
            },
            "decision_table": {
              "headers": ["Requirement", "Network Approach"],
              "rows": [
                ["Reliable data transfer", "TCP sockets"],
                ["Low latency, real-time", "UDP datagrams"],
                ["Web services", "HTTPURLConnection"],
                ["Simple file transfer", "TCP sockets"],
                ["Broadcast messages", "UDP multicast"]
              ]
            },
            "best_practices": [
              {
                "practice": "Network operations ke liye separate threads use karein",
                "reason": "UI/main thread block nahi hoga",
                "hinglish": "Network operations ke liye alag threads use karo"
              }
            ]
          }
        },
        {
          "id": 5,
          "title": "Servlets aur JSP",
          "english": "Java web applications using Servlets and JSP",
          "hinglish": "Servlets aur JSP ka use karke Java web applications",
          "examples": [
            "// Servlet\n@WebServlet(\"/hello\")\npublic class HelloServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) {\n        res.getWriter().write(\"Hello World\");\n    }\n}\n\n// JSP\n<%@ page contentType=\"text/html\" %>\n<html><body>Hello <%= request.getParameter(\"name\") %></body></html>"
          ],
          "practice": [
            {
              "question": "Servlet lifecycle ke methods konse hain?",
              "answer": "init(), service(), doGet()/doPost(), destroy()"
            },
            {
              "question": "Session management ke tareeke konse hain?",
              "answer": "Cookies, HttpSession, URL rewriting, hidden form fields"
            },
            {
              "question": "JSTL kya hota hai?",
              "answer": "JSP Standard Tag Library - custom tags for common operations"
            },
            {
              "question": "Servlet Filter ka use kya hai?",
              "answer": "Request/response modify karne ke liye, logging, authentication"
            }
          ],
          "detailed_explanation": {
            "example_code": "// Note: Actual servlet/JSP code requires web container (Tomcat)\n// This is example structure\n\n/*\n// 1. Servlet Example (HelloServlet.java)\n@WebServlet(\"/hello\")\npublic class HelloServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, \n                         HttpServletResponse response) \n            throws ServletException, IOException {\n        \n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        \n        String name = request.getParameter(\"name\");\n        if(name == null || name.trim().isEmpty()) {\n            name = \"Guest\";\n        }\n        \n        out.println(\"<html><body>\");\n        out.println(\"<h1>Hello \" + name + \"!</h1>\");\n        out.println(\"<p>Servlet executed at: \" + new Date() + \"</p>\");\n        out.println(\"</body></html>\");\n    }\n}\n*/\n\n/*\n// 2. Servlet with Session (LoginServlet.java)\n@WebServlet(\"/login\")\npublic class LoginServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request,\n                         HttpServletResponse response)\n            throws ServletException, IOException {\n        \n        String username = request.getParameter(\"username\");\n        String password = request.getParameter(\"password\");\n        \n        // Simple authentication\n        if(\"admin\".equals(username) && \"password\".equals(password)) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"username\", username);\n            session.setAttribute(\"loginTime\", new Date());\n            \n            // Set session timeout to 30 minutes\n            session.setMaxInactiveInterval(30 * 60);\n            \n            response.sendRedirect(\"welcome.jsp\");\n        } else {\n            request.setAttribute(\"error\", \"Invalid credentials\");\n            request.getRequestDispatcher(\"login.jsp\").forward(request, response);\n        }\n    }\n}\n*/\n\n/*\n// 3. Servlet Filter (LoggingFilter.java)\n@WebFilter(\"/*\")\npublic class LoggingFilter implements Filter {\n    public void doFilter(ServletRequest request,\n                        ServletResponse response,\n                        FilterChain chain)\n            throws IOException, ServletException {\n        \n        HttpServletRequest req = (HttpServletRequest) request;\n        System.out.println(\"Request URL: \" + req.getRequestURL());\n        System.out.println(\"Client IP: \" + req.getRemoteAddr());\n        System.out.println(\"Method: \" + req.getMethod());\n        \n        long startTime = System.currentTimeMillis();\n        chain.doFilter(request, response);\n        long endTime = System.currentTimeMillis();\n        \n        System.out.println(\"Request processed in: \" + (endTime - startTime) + \"ms\");\n    }\n}\n*/\n\n/*\n// 4. JSP Example (welcome.jsp)\n<%-- welcome.jsp --%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\n\n<html>\n<head>\n    <title>Welcome</title>\n</head>\n<body>\n    <h1>Welcome ${sessionScope.username}!</h1>\n    \n    <%-- Scriptlet (old way) --%>\n    <% \n        Date loginTime = (Date) session.getAttribute(\"loginTime\");\n        if(loginTime != null) {\n    %>\n            <p>You logged in at: <%= loginTime %></p>\n    <% \n        } \n    %>\n    \n    <%-- JSTL (new way) --%>\n    <c:if test=\"${not empty sessionScope.loginTime}\">\n        <p>Session started: <c:out value=\"${sessionScope.loginTime}\" /></p>\n    </c:if>\n    \n    <%-- JSTL Loop --%>\n    <h3>User List:</h3>\n    <c:forEach var=\"user\" items=\"${requestScope.userList}\">\n        <p>${user.name} - ${user.email}</p>\n    </c:forEach>\n    \n    <form action=\"logout\" method=\"post\">\n        <input type=\"submit\" value=\"Logout\">\n    </form>\n</body>\n</html>\n*/\n\n/*\n// 5. MVC Architecture\n// Controller (Servlet)\n@WebServlet(\"/user\")\npublic class UserController extends HttpServlet {\n    private UserService userService = new UserService();\n    \n    protected void doGet(HttpServletRequest request,\n                        HttpServletResponse response)\n            throws ServletException, IOException {\n        \n        String action = request.getParameter(\"action\");\n        \n        if(\"list\".equals(action)) {\n            List<User> users = userService.getAllUsers();\n            request.setAttribute(\"users\", users);\n            request.getRequestDispatcher(\"/userList.jsp\").forward(request, response);\n            \n        } else if(\"edit\".equals(action)) {\n            int id = Integer.parseInt(request.getParameter(\"id\"));\n            User user = userService.getUser(id);\n            request.setAttribute(\"user\", user);\n            request.getRequestDispatcher(\"/userForm.jsp\").forward(request, response);\n        }\n    }\n}\n\n// Service Layer (Business logic)\nclass UserService {\n    public List<User> getAllUsers() {\n        // Business logic + DAO call\n        return userDAO.getAllUsers();\n    }\n}\n\n// View (JSP - userList.jsp)\n<%-- Display users in table --%>\n*/\n\npublic class ServletJSPExample {\n    public static void main(String[] args) {\n        System.out.println(\"=== SERVLET & JSP CONCEPTS ===\");\n        System.out.println(\"\\nServlet Lifecycle:\");\n        System.out.println(\"1. Loading & Instantiation\");\n        System.out.println(\"2. Initialization (init())\");\n        System.out.println(\"3. Request Handling (service() -> doGet()/doPost())\");\n        System.out.println(\"4. Destruction (destroy())\");\n        \n        System.out.println(\"\\nSession Management Techniques:\");\n        System.out.println(\"1. Cookies - Client-side storage\");\n        System.out.println(\"2. HttpSession - Server-side storage\");\n        System.out.println(\"3. URL Rewriting - Append session ID to URLs\");\n        System.out.println(\"4. Hidden Form Fields\");\n        \n        System.out.println(\"\\nJSP Elements:\");\n        System.out.println(\"1. Directives - <%@ page ... %>\");\n        System.out.println(\"2. Declarations - <%! ... %>\");\n        System.out.println(\"3. Scriptlets - <% ... %> (avoid in modern apps)\");\n        System.out.println(\"4. Expressions - <%= ... %>\");\n        System.out.println(\"5. EL (Expression Language) - ${...}\");\n        \n        System.out.println(\"\\nJSTL Libraries:\");\n        System.out.println(\"1. Core (c:) - <c:forEach>, <c:if>, <c:choose>\");\n        System.out.println(\"2. Formatting (fmt:) - Dates, numbers\");\n        System.out.println(\"3. SQL (sql:) - Database operations\");\n        System.out.println(\"4. XML (x:) - XML processing\");\n        \n        System.out.println(\"\\nBest Practices:\");\n        System.out.println(\"1. Use MVC architecture\");\n        System.out.println(\"2. Prefer JSTL/EL over scriptlets\");\n        System.out.println(\"3. Use filters for cross-cutting concerns\");\n        System.out.println(\"4. Implement proper error handling\");\n        System.out.println(\"5. Secure against common web vulnerabilities\");\n        \n        System.out.println(\"\\nNote: To run actual servlets/JSP, you need:\");\n        System.out.println(\"1. Apache Tomcat or similar container\");\n        System.out.println(\"2. web.xml configuration (or annotations)\");\n        System.out.println(\"3. Proper directory structure (WEB-INF, classes)\");\n    }\n}",
            "components": [
              {
                "name": "HttpSession",
                "english": "Server-side session management for web applications",
                "hinglish": "Web applications ke liye server-side session management",
                "importance": "High",
                "tip": "Store minimal data in session for scalability",
                "role": "Maintain user state across requests",
                "pros": "Secure, server-controlled",
                "cons": "Memory usage, scalability challenges",
                "example": "HttpSession session = request.getSession(); session.setAttribute(\"user\", user);",
                "use_case": "User authentication, shopping carts"
              }
            ],
            "comparison_table": {
              "headers": ["Technology", "Role", "When to Use"],
              "rows": [
                ["Servlet", "Controller", "Request handling, business logic"],
                ["JSP", "View", "Presentation layer"],
                ["JSTL", "View helpers", "Avoid scriptlets, cleaner JSP"],
                ["Filters", "Cross-cutting", "Logging, authentication, compression"],
                ["Listeners", "Events", "Application lifecycle, session tracking"]
              ]
            },
            "decision_table": {
              "headers": ["Web Requirement", "Servlet/JSP Feature"],
              "rows": [
                ["Request handling", "Servlet doGet()/doPost()"],
                ["Presentation", "JSP with JSTL"],
                ["User state", "HttpSession"],
                ["Cross-cutting concerns", "Filters"],
                ["Event handling", "Listeners"],
                ["Clean architecture", "MVC pattern"]
              ]
            },
            "best_practices": [
              {
                "practice": "JSP mein scriptlets avoid karein, JSTL aur EL use karein",
                "reason": "Clean separation of concerns, maintainability",
                "hinglish": "JSP mein scriptlets use mat karo, JSTL aur EL use karo"
              }
            ]
          }
        },
        {
          "id": 6,
          "title": "Spring Framework - Core",
          "english": "Dependency Injection and Spring Core",
          "hinglish": "Dependency Injection aur Spring Core",
          "examples": [
            "// Spring Bean\n@Component\npublic class UserService {\n    @Autowired\n    private UserRepository repository;\n}\n\n// Configuration\n@Configuration\n@ComponentScan(\"com.example\")\npublic class AppConfig {\n    @Bean\n    public DataSource dataSource() {\n        return new DriverManagerDataSource();\n    }\n}"
          ],
          "practice": [
            {
              "question": "Dependency Injection kya hota hai?",
              "answer": "Objects apne dependencies khud nahi create karte, bahar se inject hote hain"
            },
            {
              "question": "IoC container kya hota hai?",
              "answer": "Spring ka core jaha bean lifecycle manage hota hai"
            },
            {
              "question": "@Autowired ka use kya hai?",
              "answer": "Automatic dependency injection ke liye"
            },
            {
              "question": "Bean scopes konse hote hain?",
              "answer": "singleton, prototype, request, session, global-session"
            }
          ],
          "detailed_explanation": {
            "example_code": "// Note: Spring requires dependencies and proper setup\n// This shows structure and concepts\n\n/*\n// 1. Maven Dependencies (pom.xml)\n<dependencies>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.3.23</version>\n    </dependency>\n</dependencies>\n*/\n\n/*\n// 2. Model Class\npublic class User {\n    private Long id;\n    private String name;\n    private String email;\n    \n    // Constructors, getters, setters\n}\n*/\n\n/*\n// 3. Repository Interface\npublic interface UserRepository {\n    User findById(Long id);\n    List<User> findAll();\n    void save(User user);\n}\n*/\n\n/*\n// 4. Repository Implementation\n@Repository  // Stereotype annotation\npublic class UserRepositoryImpl implements UserRepository {\n    \n    private Map<Long, User> store = new HashMap<>();\n    \n    public UserRepositoryImpl() {\n        // Initialize with sample data\n        store.put(1L, new User(1L, \"John\", \"john@example.com\"));\n        store.put(2L, new User(2L, \"Jane\", \"jane@example.com\"));\n    }\n    \n    @Override\n    public User findById(Long id) {\n        return store.get(id);\n    }\n    \n    @Override\n    public List<User> findAll() {\n        return new ArrayList<>(store.values());\n    }\n    \n    @Override\n    public void save(User user) {\n        store.put(user.getId(), user);\n    }\n}\n*/\n\n/*\n// 5. Service Layer\n@Service  // Stereotype annotation\npublic class UserService {\n    \n    private final UserRepository userRepository;\n    \n    // Constructor injection (recommended)\n    @Autowired\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n    \n    public User getUserById(Long id) {\n        return userRepository.findById(id);\n    }\n    \n    public List<User> getAllUsers() {\n        return userRepository.findAll();\n    }\n    \n    public void registerUser(User user) {\n        // Business logic\n        if(user.getEmail() == null || user.getEmail().isEmpty()) {\n            throw new IllegalArgumentException(\"Email is required\");\n        }\n        userRepository.save(user);\n    }\n}\n*/\n\n/*\n// 6. Configuration Class\n@Configuration\n@ComponentScan(\"com.example\")  // Scan for components\npublic class AppConfig {\n    \n    // Bean definition using Java configuration\n    @Bean\n    @Scope(\"singleton\")  // Default scope\n    public DataSource dataSource() {\n        DriverManagerDataSource dataSource = new DriverManagerDataSource();\n        dataSource.setDriverClassName(\"org.h2.Driver\");\n        dataSource.setUrl(\"jdbc:h2:mem:testdb\");\n        dataSource.setUsername(\"sa\");\n        dataSource.setPassword(\"\");\n        return dataSource;\n    }\n    \n    @Bean\n    public PlatformTransactionManager transactionManager(DataSource dataSource) {\n        return new DataSourceTransactionManager(dataSource);\n    }\n}\n*/\n\n/*\n// 7. XML Configuration (alternative)\n<!-- applicationContext.xml -->\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"...\">\n    \n    <context:component-scan base-package=\"com.example\" />\n    \n    <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n        <property name=\"driverClassName\" value=\"org.h2.Driver\" />\n        <property name=\"url\" value=\"jdbc:h2:mem:testdb\" />\n        <property name=\"username\" value=\"sa\" />\n        <property name=\"password\" value=\"\" />\n    </bean>\n    \n</beans>\n*/\n\n/*\n// 8. Main Application\npublic class SpringCoreExample {\n    public static void main(String[] args) {\n        // Java configuration way\n        AnnotationConfigApplicationContext context = \n            new AnnotationConfigApplicationContext(AppConfig.class);\n        \n        // XML configuration way\n        // ClassPathXmlApplicationContext context = \n        //     new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        \n        // Get beans from container\n        UserService userService = context.getBean(UserService.class);\n        \n        // Use the service\n        List<User> users = userService.getAllUsers();\n        users.forEach(u -> System.out.println(u.getName()));\n        \n        // Create new user\n        User newUser = new User(3L, \"Bob\", \"bob@example.com\");\n        userService.registerUser(newUser);\n        \n        // Bean scopes demonstration\n        UserRepository repo1 = context.getBean(UserRepository.class);\n        UserRepository repo2 = context.getBean(UserRepository.class);\n        System.out.println(\"Same repository instance? \" + (repo1 == repo2)); // true (singleton)\n        \n        // Close context\n        context.close();\n    }\n}\n*/\n\n/*\n// 9. Bean Lifecycle\n@Component\npublic class LifecycleBean implements InitializingBean, DisposableBean {\n    \n    public LifecycleBean() {\n        System.out.println(\"1. Constructor called\");\n    }\n    \n    @PostConstruct\n    public void postConstruct() {\n        System.out.println(\"3. @PostConstruct called\");\n    }\n    \n    @Override\n    public void afterPropertiesSet() {\n        System.out.println(\"4. afterPropertiesSet() called\");\n    }\n    \n    public void customInit() {\n        System.out.println(\"5. Custom init method called\");\n    }\n    \n    @PreDestroy\n    public void preDestroy() {\n        System.out.println(\"6. @PreDestroy called\");\n    }\n    \n    @Override\n    public void destroy() {\n        System.out.println(\"7. destroy() called\");\n    }\n    \n    public void customDestroy() {\n        System.out.println(\"8. Custom destroy method called\");\n    }\n}\n*/\n\npublic class SpringCoreConcepts {\n    public static void main(String[] args) {\n        System.out.println(\"=== SPRING CORE CONCEPTS ===\");\n        \n        System.out.println(\"\\n1. Dependency Injection Types:\");\n        System.out.println(\"   a. Constructor Injection (Recommended)\");\n        System.out.println(\"   b. Setter Injection\");\n        System.out.println(\"   c. Field Injection (Using @Autowired)\");\n        \n        System.out.println(\"\\n2. Stereotype Annotations:\");\n        System.out.println(\"   @Component - Generic component\");\n        System.out.println(\"   @Service - Business service layer\");\n        System.out.println(\"   @Repository - Data access layer\");\n        System.out.println(\"   @Controller - Web controller layer\");\n        \n        System.out.println(\"\\n3. Bean Scopes:\");\n        System.out.println(\"   singleton - One bean per container (default)\");\n        System.out.println(\"   prototype - New bean each time requested\");\n        System.out.println(\"   request - One bean per HTTP request\");\n        System.out.println(\"   session - One bean per HTTP session\");\n        System.out.println(\"   global-session - One bean per global HTTP session\");\n        \n        System.out.println(\"\\n4. Configuration Styles:\");\n        System.out.println(\"   XML Configuration - Traditional\");\n        System.out.println(\"   Java Configuration - Modern (using @Configuration)\");\n        System.out.println(\"   Annotation Configuration - Using stereotypes\");\n        \n        System.out.println(\"\\n5. Autowiring Modes:\");\n        System.out.println(\"   byType - Match by type\");\n        System.out.println(\"   byName - Match by bean name\");\n        System.out.println(\"   constructor - Constructor arguments\");\n        System.out.println(\"   @Qualifier - Specify which bean\");\n        \n        System.out.println(\"\\n6. Bean Lifecycle:\");\n        System.out.println(\"   1. Instantiation\");\n        System.out.println(\"   2. Population of properties\");\n        System.out.println(\"   3. BeanNameAware callbacks\");\n        System.out.println(\"   4. BeanFactoryAware callbacks\");\n        System.out.println(\"   5. Pre-initialization (BeanPostProcessors)\");\n        System.out.println(\"   6. Initialization (@PostConstruct, afterPropertiesSet)\");\n        System.out.println(\"   7. Post-initialization (BeanPostProcessors)\");\n        System.out.println(\"   8. Bean is ready for use\");\n        System.out.println(\"   9. Destruction (@PreDestroy, destroy())\");\n        \n        System.out.println(\"\\nBest Practices:\");\n        System.out.println(\"1. Use constructor injection for mandatory dependencies\");\n        System.out.println(\"2. Prefer Java configuration over XML\");\n        System.out.println(\"3. Use appropriate stereotype annotations\");\n        System.out.println(\"4. Keep beans stateless when possible\");\n        System.out.println(\"5. Use profiles for environment-specific config\");\n    }\n}",
            "components": [
              {
                "name": "IoC Container",
                "english": "Inversion of Control container that manages beans",
                "hinglish": "Inversion of Control container jo beans manage karta hai",
                "importance": "High",
                "tip": "ApplicationContext is the Spring IoC container implementation",
                "role": "Create, configure, and manage bean lifecycle",
                "pros": "Loose coupling, easier testing, configuration centralization",
                "cons": "Learning curve, runtime overhead",
                "example": "ApplicationContext context = new ClassPathXmlApplicationContext(...);",
                "use_case": "All Spring-based applications"
              }
            ],
            "comparison_table": {
              "headers": ["Injection Type", "When to Use", "Pros", "Cons"],
              "rows": [
                ["Constructor", "Mandatory dependencies", "Immutable, testable", "Verbose with many dependencies"],
                ["Setter", "Optional dependencies", "Flexible", "Mutable, can be in inconsistent state"],
                ["Field", "Simple cases", "Concise", "Hard to test, hidden dependencies"]
              ]
            },
            "decision_table": {
              "headers": ["Spring Requirement", "Approach"],
              "rows": [
                ["Basic DI", "@Component + @Autowired"],
                ["Enterprise app", "Layered architecture (@Controller, @Service, @Repository)"],
                ["External configuration", "@Configuration classes"],
                ["Multiple bean implementations", "@Qualifier"],
                ["Environment-specific config", "@Profile"],
                ["AOP needs", "@Aspect, @Around, etc."]
              ]
            },
            "best_practices": [
              {
                "practice": "Constructor injection use karein mandatory dependencies ke liye",
                "reason": "Better testability, immutability",
                "hinglish": "Mandatory dependencies ke liye constructor injection use karo"
              }
            ]
          }
        },
        {
          "id": 7,
          "title": "Spring Boot aur Spring MVC",
          "english": "Rapid development with Spring Boot and MVC",
          "hinglish": "Spring Boot aur MVC se rapid development",
          "examples": [
            "// Spring Boot Application\n@SpringBootApplication\npublic class MyApp {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApp.class, args);\n    }\n}\n\n// Spring MVC Controller\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    @GetMapping\n    public List<User> getUsers() {\n        return userService.getAllUsers();\n    }\n}"
          ],
          "practice": [
            {
              "question": "Spring Boot ka main advantage kya hai?",
              "answer": "Auto-configuration - minimal configuration needed"
            },
            {
              "question": "@RestController aur @Controller mein kya antar hai?",
              "answer": "@RestController @Controller + @ResponseBody, directly returns data"
            },
            {
              "question": "Spring Boot starters kya hote hain?",
              "answer": "Pre-configured dependencies for common use cases"
            },
            {
              "question": "Actuator endpoints kya provide karte hain?",
              "answer": "Application monitoring and management endpoints"
            }
          ],
          "detailed_explanation": {
            "example_code": "/*\n// 1. Spring Boot Application\n@SpringBootApplication  // = @Configuration + @EnableAutoConfiguration + @ComponentScan\npublic class MySpringBootApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MySpringBootApplication.class, args);\n    }\n}\n*/\n\n/*\n// 2. Maven pom.xml for Spring Boot\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.7.8</version>\n</parent>\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n    <dependency>\n        <groupId>com.h2database</groupId>\n        <artifactId>h2</artifactId>\n        <scope>runtime</scope>\n    </dependency>\n</dependencies>\n*/\n\n/*\n// 3. REST Controller\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    private final UserService userService;\n    \n    @Autowired\n    public UserController(UserService userService) {\n        this.userService = userService;\n    }\n    \n    // GET /api/users\n    @GetMapping\n    public ResponseEntity<List<User>> getAllUsers() {\n        return ResponseEntity.ok(userService.getAllUsers());\n    }\n    \n    // GET /api/users/{id}\n    @GetMapping(\"/{id}\")\n    public ResponseEntity<User> getUserById(@PathVariable Long id) {\n        User user = userService.getUserById(id);\n        return user != null ? ResponseEntity.ok(user) : ResponseEntity.notFound().build();\n    }\n    \n    // POST /api/users\n    @PostMapping\n    public ResponseEntity<User> createUser(@Valid @RequestBody User user) {\n        User createdUser = userService.createUser(user);\n        return ResponseEntity.created(URI.create(\"/api/users/\" + createdUser.getId()))\n                           .body(createdUser);\n    }\n    \n    // PUT /api/users/{id}\n    @PutMapping(\"/{id}\")\n    public ResponseEntity<User> updateUser(@PathVariable Long id, \n                                          @Valid @RequestBody User user) {\n        user.setId(id);\n        User updatedUser = userService.updateUser(user);\n        return ResponseEntity.ok(updatedUser);\n    }\n    \n    // DELETE /api/users/{id}\n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {\n        userService.deleteUser(id);\n        return ResponseEntity.noContent().build();\n    }\n    \n    // Exception handling\n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ResponseEntity<String> handleNotFound(ResourceNotFoundException ex) {\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());\n    }\n}\n*/\n\n/*\n// 4. Spring MVC Controller (Traditional)\n@Controller\n@RequestMapping(\"/web\")\npublic class WebUserController {\n    \n    @GetMapping(\"/users\")\n    public String listUsers(Model model) {\n        model.addAttribute(\"users\", userService.getAllUsers());\n        return \"users/list\";  // Returns view name\n    }\n    \n    @GetMapping(\"/users/{id}\")\n    public String viewUser(@PathVariable Long id, Model model) {\n        model.addAttribute(\"user\", userService.getUserById(id));\n        return \"users/view\";\n    }\n    \n    @GetMapping(\"/users/new\")\n    public String showUserForm(Model model) {\n        model.addAttribute(\"user\", new User());\n        return \"users/form\";\n    }\n    \n    @PostMapping(\"/users\")\n    public String saveUser(@Valid @ModelAttribute(\"user\") User user,\n                          BindingResult result) {\n        if(result.hasErrors()) {\n            return \"users/form\";\n        }\n        userService.saveUser(user);\n        return \"redirect:/web/users\";\n    }\n}\n*/\n\n/*\n// 5. application.properties/yml Configuration\n# application.properties\nserver.port=8080\nspring.application.name=myapp\n\n# Database\nspring.datasource.url=jdbc:h2:mem:testdb\nspring.datasource.driver-class-name=org.h2.Driver\nspring.datasource.username=sa\nspring.datasource.password=\n\n# JPA\nspring.jpa.show-sql=true\nspring.jpa.hibernate.ddl-auto=update\n\n# Actuator\nmanagement.endpoints.web.exposure.include=*\nmanagement.endpoint.health.show-details=always\n*/\n\n/*\n// 6. Profiles\n@Configuration\n@Profile(\"dev\")\npublic class DevConfig {\n    @Bean\n    public DataSource dataSource() {\n        // Development database\n    }\n}\n\n@Configuration\n@Profile(\"prod\")\npublic class ProdConfig {\n    @Bean\n    public DataSource dataSource() {\n        // Production database\n    }\n}\n*/\n\n/*\n// 7. Validation\npublic class User {\n    @NotNull(message = \"Name is required\")\n    @Size(min = 2, max = 50)\n    private String name;\n    \n    @Email(message = \"Invalid email\")\n    @NotBlank\n    private String email;\n    \n    @Min(18)\n    @Max(100)\n    private Integer age;\n}\n*/\n\npublic class SpringBootMVCConcepts {\n    public static void main(String[] args) {\n        System.out.println(\"=== SPRING BOOT & SPRING MVC ===\");\n        \n        System.out.println(\"\\n1. Spring Boot Features:\");\n        System.out.println(\"   • Auto-configuration\");\n        System.out.println(\"   • Starter dependencies\");\n        System.out.println(\"   • Embedded servers (Tomcat, Jetty, Undertow)\");\n        System.out.println(\"   • Production-ready features (Actuator)\");\n        System.out.println(\"   • Externalized configuration\");\n        \n        System.out.println(\"\\n2. Common Starters:\");\n        System.out.println(\"   spring-boot-starter-web - Web applications\");\n        System.out.println(\"   spring-boot-starter-data-jpa - JPA with Hibernate\");\n        System.out.println(\"   spring-boot-starter-security - Security\");\n        System.out.println(\"   spring-boot-starter-test - Testing\");\n        System.out.println(\"   spring-boot-starter-thymeleaf - Thymeleaf templates\");\n        \n        System.out.println(\"\\n3. Spring MVC Annotations:\");\n        System.out.println(\"   @Controller - MVC controller\");\n        System.out.println(\"   @RestController - REST controller\");\n        System.out.println(\"   @RequestMapping - Request mapping\");\n        System.out.println(\"   @GetMapping, @PostMapping, etc. - HTTP methods\");\n        System.out.println(\"   @PathVariable - URL path variables\");\n        System.out.println(\"   @RequestParam - Query parameters\");\n        System.out.println(\"   @RequestBody - Request body\");\n        System.out.println(\"   @ResponseBody - Response body\");\n        System.out.println(\"   @ModelAttribute - Form binding\");\n        \n        System.out.println(\"\\n4. Spring Boot Actuator Endpoints:\");\n        System.out.println(\"   /actuator/health - Application health\");\n        System.out.println(\"   /actuator/info - Application info\");\n        System.out.println(\"   /actuator/metrics - Application metrics\");\n        System.out.println(\"   /actuator/env - Environment properties\");\n        System.out.println(\"   /actuator/beans - Spring beans\");\n        \n        System.out.println(\"\\n5. Configuration Properties:\");\n        System.out.println(\"   • application.properties / application.yml\");\n        System.out.println(\"   • Profile-specific: application-{profile}.properties\");\n        System.out.println(\"   • Command line arguments\");\n        System.out.println(\"   • Environment variables\");\n        System.out.println(\"   • @ConfigurationProperties\");\n        \n        System.out.println(\"\\n6. Common Project Structure:\");\n        System.out.println(\"   src/main/java/com/example/\");\n        System.out.println(\"     ├── Application.java (main class)\");\n        System.out.println(\"     ├── controller/ (REST/MVC controllers)\");\n        System.out.println(\"     ├── service/ (Business logic)\");\n        System.out.println(\"     ├── repository/ (Data access)\");\n        System.out.println(\"     └── model/ (Entity classes)\");\n        System.out.println(\"   src/main/resources/\");\n        System.out.println(\"     ├── application.properties\");\n        System.out.println(\"     └── templates/ (Thymeleaf/HTML)\");\n        \n        System.out.println(\"\\nBest Practices:\");\n        System.out.println(\"1. Use @RestController for APIs, @Controller for web pages\");\n        System.out.println(\"2. Implement proper exception handling\");\n        System.out.println(\"3. Use DTOs for API responses\");\n        System.out.println(\"4. Enable Actuator for monitoring\");\n        System.out.println(\"5. Use profiles for environment-specific config\");\n        System.out.println(\"6. Implement validation\");\n        System.out.println(\"7. Write unit and integration tests\");\n    }\n}",
            "components": [
              {
                "name": "@SpringBootApplication",
                "english": "Primary annotation for Spring Boot applications",
                "hinglish": "Spring Boot applications ke liye primary annotation",
                "importance": "High",
                "tip": "Combines @Configuration, @EnableAutoConfiguration, and @ComponentScan",
                "role": "Bootstrap Spring Boot application",
                "pros": "Simplified configuration, auto-setup",
                "cons": "Magic happening behind scenes",
                "example": "@SpringBootApplication\npublic class MyApp { public static void main(String[] args) { SpringApplication.run(MyApp.class, args); } }",
                "use_case": "All Spring Boot applications"
              }
            ],
            "comparison_table": {
              "headers": ["Feature", "Traditional Spring", "Spring Boot"],
              "rows": [
                ["Configuration", "XML/Java config files", "Auto-configuration"],
                ["Setup Time", "Hours/days", "Minutes"],
                ["Embedded Server", "Manual setup", "Built-in (Tomcat/Jetty)"],
                ["Dependency Mgmt", "Manual version management", "Starter POMs"],
                ["Deployment", "WAR to external server", "JAR with embedded server"],
                ["Monitoring", "Manual setup", "Actuator built-in"]
              ]
            },
            "decision_table": {
              "headers": ["Project Type", "Spring Boot Approach"],
              "rows": [
                ["Microservices", "Spring Boot + Spring Cloud"],
                ["REST API", "Spring Boot Web + Spring Data"],
                ["Web Application", "Spring Boot Web + Thymeleaf"],
                ["Batch Processing", "Spring Boot Batch"],
                ["Enterprise Integration", "Spring Boot Integration"]
              ]
            },
            "best_practices": [
              {
                "practice": "Spring Boot ke liye starter dependencies use karein",
                "reason": "Dependency management aur auto-configuration ke liye",
                "hinglish": "Spring Boot mein starter dependencies use karo"
              }
            ]
          }
        },
        {
          "id": 8,
          "title": "Spring Data JPA aur Hibernate",
          "english": "Database operations with Spring Data JPA and Hibernate",
          "hinglish": "Spring Data JPA aur Hibernate se database operations",
          "examples": [
            "// Entity\n@Entity\npublic class User {\n    @Id @GeneratedValue\n    private Long id;\n    private String name;\n}\n\n// Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    List<User> findByName(String name);\n}\n\n// Hibernate Query\n@Query(\"SELECT u FROM User u WHERE u.age > :age\")\nList<User> findUsersOlderThan(@Param(\"age\") int age);"
          ],
          "practice": [
            {
              "question": "JPA aur Hibernate mein kya sambandh hai?",
              "answer": "JPA specification hai, Hibernate uska implementation hai"
            },
            {
              "question": "@Entity annotation ka use kya hai?",
              "answer": "Class ko database table map karne ke liye"
            },
            {
              "question": "Spring Data JPA repository methods kaise automatically kaam karte hain?",
              "answer": "Method names parse karke queries generate karta hai"
            },
            {
              "question": "Hibernate caching ke levels konse hain?",
              "answer": "First level (session), Second level (session factory), Query cache"
            }
          ],
          "detailed_explanation": {
            "example_code": "/*\n// 1. Entity Class\n@Entity\n@Table(name = \"users\")  // Maps to \"users\" table\npublic class User {\n    \n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(name = \"user_name\", nullable = false, length = 100)\n    private String name;\n    \n    @Column(unique = true)\n    private String email;\n    \n    @Temporal(TemporalType.DATE)\n    private Date birthDate;\n    \n    @Enumerated(EnumType.STRING)\n    private UserStatus status;\n    \n    @OneToMany(mappedBy = \"user\", cascade = CascadeType.ALL)\n    private List<Order> orders = new ArrayList<>();\n    \n    @ManyToMany\n    @JoinTable(\n        name = \"user_roles\",\n        joinColumns = @JoinColumn(name = \"user_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"role_id\")\n    )\n    private Set<Role> roles = new HashSet<>();\n    \n    @CreationTimestamp\n    private LocalDateTime createdAt;\n    \n    @UpdateTimestamp\n    private LocalDateTime updatedAt;\n    \n    // Constructors, getters, setters\n}\n\nenum UserStatus {\n    ACTIVE, INACTIVE, SUSPENDED\n}\n*/\n\n/*\n// 2. Repository Interface\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    \n    // Derived query methods\n    List<User> findByName(String name);\n    \n    List<User> findByNameContainingIgnoreCase(String name);\n    \n    List<User> findByEmailEndingWith(String domain);\n    \n    List<User> findByStatus(UserStatus status);\n    \n    List<User> findByBirthDateBetween(Date start, Date end);\n    \n    Long countByStatus(UserStatus status);\n    \n    @Query(\"SELECT u FROM User u WHERE u.email LIKE %:domain\")\n    List<User> findUsersByEmailDomain(@Param(\"domain\") String domain);\n    \n    @Query(value = \"SELECT * FROM users WHERE user_name = :name\", nativeQuery = true)\n    List<User> findUsersByNameNative(@Param(\"name\") String name);\n    \n    @Modifying\n    @Query(\"UPDATE User u SET u.status = :status WHERE u.id = :id\")\n    int updateUserStatus(@Param(\"id\") Long id, @Param(\"status\") UserStatus status);\n    \n    // Pageable and Sort\n    Page<User> findByStatus(UserStatus status, Pageable pageable);\n    \n    List<User> findAll(Sort sort);\n}\n*/\n\n/*\n// 3. Service Layer\n@Service\n@Transactional\npublic class UserService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    public User createUser(User user) {\n        return userRepository.save(user);\n    }\n    \n    public Optional<User> getUserById(Long id) {\n        return userRepository.findById(id);\n    }\n    \n    public List<User> searchUsers(String keyword) {\n        return userRepository.findByNameContainingIgnoreCase(keyword);\n    }\n    \n    public Page<User> getActiveUsers(int page, int size) {\n        Pageable pageable = PageRequest.of(page, size, Sort.by(\"name\").ascending());\n        return userRepository.findByStatus(UserStatus.ACTIVE, pageable);\n    }\n    \n    public void updateStatus(Long userId, UserStatus status) {\n        userRepository.updateUserStatus(userId, status);\n    }\n}\n*/\n\n/*\n// 4. Hibernate Configuration (hibernate.cfg.xml)\n<hibernate-configuration>\n    <session-factory>\n        <!-- Database connection settings -->\n        <property name=\"connection.driver_class\">org.h2.Driver</property>\n        <property name=\"connection.url\">jdbc:h2:mem:testdb</property>\n        <property name=\"connection.username\">sa</property>\n        <property name=\"connection.password\"></property>\n        \n        <!-- JDBC connection pool settings -->\n        <property name=\"connection.pool_size\">10</property>\n        \n        <!-- SQL dialect -->\n        <property name=\"dialect\">org.hibernate.dialect.H2Dialect</property>\n        \n        <!-- Echo all executed SQL to stdout -->\n        <property name=\"show_sql\">true</property>\n        \n        <!-- Drop and re-create the database schema on startup -->\n        <property name=\"hbm2ddl.auto\">update</property>\n        \n        <!-- Entity mappings -->\n        <mapping class=\"com.example.User\"/>\n        \n        <!-- Second-level cache settings -->\n        <property name=\"cache.use_second_level_cache\">true</property>\n        <property name=\"cache.region.factory_class\">\n            org.hibernate.cache.ehcache.EhCacheRegionFactory\n        </property>\n        \n    </session-factory>\n</hibernate-configuration>\n*/\n\n/*\n// 5. HQL (Hibernate Query Language) Examples\npublic class HQLExamples {\n    \n    private SessionFactory sessionFactory;\n    \n    public List<User> getUsersByName(String name) {\n        Session session = sessionFactory.getCurrentSession();\n        Query<User> query = session.createQuery(\n            \"FROM User u WHERE u.name = :name\", User.class);\n        query.setParameter(\"name\", name);\n        return query.getResultList();\n    }\n    \n    public List<Object[]> getUserStats() {\n        Session session = sessionFactory.getCurrentSession();\n        Query<Object[]> query = session.createQuery(\n            \"SELECT u.status, COUNT(u) FROM User u GROUP BY u.status\", \n            Object[].class);\n        return query.getResultList();\n    }\n    \n    public List<User> getUsersWithOrders() {\n        Session session = sessionFactory.getCurrentSession();\n        Query<User> query = session.createQuery(\n            \"SELECT DISTINCT u FROM User u JOIN FETCH u.orders\", \n            User.class);\n        return query.getResultList();\n    }\n}\n*/\n\n/*\n// 6. Criteria API (Type-safe queries)\npublic class CriteriaExamples {\n    \n    private SessionFactory sessionFactory;\n    \n    public List<User> searchUsers(String name, UserStatus status, Date minBirthDate) {\n        Session session = sessionFactory.getCurrentSession();\n        CriteriaBuilder cb = session.getCriteriaBuilder();\n        CriteriaQuery<User> query = cb.createQuery(User.class);\n        Root<User> root = query.from(User.class);\n        \n        List<Predicate> predicates = new ArrayList<>();\n        \n        if(name != null) {\n            predicates.add(cb.like(root.get(\"name\"), \"%\" + name + \"%\"));\n        }\n        \n        if(status != null) {\n            predicates.add(cb.equal(root.get(\"status\"), status));\n        }\n        \n        if(minBirthDate != null) {\n            predicates.add(cb.greaterThanOrEqualTo(root.get(\"birthDate\"), minBirthDate));\n        }\n        \n        query.where(predicates.toArray(new Predicate[0]));\n        query.orderBy(cb.asc(root.get(\"name\")));\n        \n        return session.createQuery(query).getResultList();\n    }\n}\n*/\n\npublic class SpringDataHibernateConcepts {\n    public static void main(String[] args) {\n        System.out.println(\"=== SPRING DATA JPA & HIBERNATE ===\");\n        \n        System.out.println(\"\\n1. JPA Annotations:\");\n        System.out.println(\"   @Entity - Marks class as entity\");\n        System.out.println(\"   @Table - Specifies table name\");\n        System.out.println(\"   @Id - Primary key\");\n        System.out.println(\"   @GeneratedValue - ID generation strategy\");\n        System.out.println(\"   @Column - Column mapping\");\n        System.out.println(\"   @OneToMany, @ManyToOne - Relationships\");\n        \n        System.out.println(\"\\n2. Spring Data Repository Interfaces:\");\n        System.out.println(\"   CrudRepository - Basic CRUD operations\");\n        System.out.println(\"   PagingAndSortingRepository - Pagination and sorting\");\n        System.out.println(\"   JpaRepository - JPA specific operations\");\n        \n        System.out.println(\"\\n3. Query Method Keywords:\");\n        System.out.println(\"   findBy - Basic query\");\n        System.out.println(\"   find...By - Specific fields\");\n        System.out.println(\"   ...Containing - Like %value%\");\n        System.out.println(\"   ...Like - Like pattern\");\n        System.out.println(\"   ...Between - Between values\");\n        System.out.println(\"   ...LessThan / ...GreaterThan\");\n        System.out.println(\"   ...IsNull / ...IsNotNull\");\n        System.out.println(\"   ...OrderBy...Asc/Desc\");\n        \n        System.out.println(\"\\n4. Hibernate Query Languages:\");\n        System.out.println(\"   HQL - Hibernate Query Language (object-oriented)\");\n        System.out.println(\"   Criteria API - Type-safe queries\");\n        System.out.println(\"   Native SQL - Database-specific SQL\");\n        \n        System.out.println(\"\\n5. Hibernate Caching Levels:\");\n        System.out.println(\"   First Level Cache - Session level (enabled by default)\");\n        System.out.println(\"   Second Level Cache - SessionFactory level (needs config)\");\n        System.out.println(\"   Query Cache - Caches query results\");\n        \n        System.out.println(\"\\n6. Common Hibernate Properties:\");\n        System.out.println(\"   hibernate.hbm2ddl.auto - Schema generation\");\n        System.out.println(\"     • create - Drops and creates\");\n        System.out.println(\"     • update - Updates schema\");\n        System.out.println(\"     • validate - Validates schema\");\n        System.out.println(\"     • create-drop - Creates, drops on shutdown\");\n        System.out.println(\"   hibernate.show_sql - Log SQL statements\");\n        System.out.println(\"   hibernate.format_sql - Format SQL\");\n        \n        System.out.println(\"\\n7. Transaction Management:\");\n        System.out.println(\"   @Transactional - Declarative transactions\");\n        System.out.println(\"   Propagation.REQUIRED - Default (participates in existing or creates new)\");\n        System.out.println(\"   Propagation.REQUIRES_NEW - Always creates new\");\n        System.out.println(\"   Isolation levels - READ_COMMITTED, SERIALIZABLE, etc.\");\n        \n        System.out.println(\"\\nBest Practices:\");\n        System.out.println(\"1. Use lazy loading for relationships\");\n        System.out.println(\"2. Implement equals() and hashCode() for entities\");\n        System.out.println(\"3. Use DTOs for API responses\");\n        System.out.println(\"4. Enable second-level cache for read-heavy data\");\n        System.out.println(\"5. Use @Transactional at service layer\");\n        System.out.println(\"6. Avoid N+1 query problem with JOIN FETCH\");\n        System.out.println(\"7. Use pagination for large result sets\");\n    }\n}",
            "components": [
              {
                "name": "@Entity",
                "english": "Marks a class as a JPA entity mapped to a database table",
                "hinglish": "Class ko JPA entity banata hai jo database table se map hoti hai",
                "importance": "High",
                "tip": "Entity classes should have a no-arg constructor",
                "role": "Object-relational mapping",
                "pros": "Object-oriented database access, type safety",
                "cons": "Learning curve, performance overhead",
                "example": "@Entity\n@Table(name=\"users\")\npublic class User { @Id private Long id; }",
                "use_case": "All database entities in JPA/Hibernate applications"
              }
            ],
            "comparison_table": {
              "headers": ["Query Method", "Use Case", "Example"],
              "rows": [
                ["Derived Methods", "Simple queries", "findByName(String name)"],
                ["@Query Annotation", "Complex queries", "@Query(\"SELECT u FROM User u WHERE...\")"],
                ["Native Queries", "DB-specific SQL", "@Query(nativeQuery = true, value = \"SELECT * FROM...\")"],
                ["Criteria API", "Dynamic queries", "CriteriaBuilder, dynamic where clauses"],
                ["QueryDSL", "Type-safe complex queries", "QUser.user.name.eq(\"John\")"]
              ]
            },
            "decision_table": {
              "headers": ["Database Operation", "Recommended Approach"],
              "rows": [
                ["Simple CRUD", "Spring Data JPA repository methods"],
                ["Complex queries", "@Query with JPQL"],
                ["Dynamic queries", "Criteria API or QueryDSL"],
                ["Stored procedures", "@Procedure annotation"],
                ["Native SQL features", "Native queries"],
                ["Performance critical", "Native queries with optimization"]
              ]
            },
            "best_practices": [
              {
                "practice": "Lazy loading use karein relationships ke liye",
                "reason": "Performance optimization, N+1 problem se bachne ke liye",
                "hinglish": "Relationships ke liye lazy loading use karo"
              }
            ]
          }
        }
      ]
    },
    {
      "level": "Expert to Production",
      "order": 5,
      "description": "Build Tools, Testing, Microservices, Performance, Security, DevOps, Cloud",
      "topics": [
        {
          "id": 1,
          "title": "Build Tools - Maven aur Gradle",
          "english": "Project building and dependency management",
          "hinglish": "Project building aur dependency management",
          "examples": [
            "<!-- Maven pom.xml -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-core</artifactId>\n    <version>5.3.23</version>\n</dependency>",
            "// Gradle build.gradle\nimplementation 'org.springframework:spring-core:5.3.23'"
          ],
          "practice": [
            {
              "question": "Maven lifecycle ke phases konse hain?",
              "answer": "clean, validate, compile, test, package, verify, install, deploy, site"
            },
            {
              "question": "Gradle aur Maven mein kya antar hai?",
              "answer": "Maven XML-based, Gradle Groovy/Kotlin DSL, Gradle faster aur flexible"
            },
            {
              "question": "Dependency scope kya hota hai?",
              "answer": "compile, provided, runtime, test, system - define karta hai kab dependency needed hai"
            },
            {
              "question": "Transitive dependencies kya hote hain?",
              "answer": "Jin dependencies ki jarurat aapki dependency ko hoti hai, automatically include ho jati hain"
            }
          ],
          "detailed_explanation": {
            "example_code": "<!-- Sample Maven pom.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    \n    <groupId>com.example</groupId>\n    <artifactId>my-project</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n    \n    <properties>\n        <java.version>11</java.version>\n        <spring.version>5.3.23</spring.version>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n    </properties>\n    \n    <dependencies>\n        <!-- Compile scope (default) -->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-core</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        \n        <!-- Test scope -->\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.13.2</version>\n            <scope>test</scope>\n        </dependency>\n        \n        <!-- Provided scope -->\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>javax.servlet-api</artifactId>\n            <version>4.0.1</version>\n            <scope>provided</scope>\n        </dependency>\n        \n        <!-- Runtime scope -->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>8.0.33</version>\n            <scope>runtime</scope>\n        </dependency>\n    </dependencies>\n    \n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.10.1</version>\n                <configuration>\n                    <source>${java.version}</source>\n                    <target>${java.version}</target>\n                </configuration>\n            </plugin>\n            \n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-plugin</artifactId>\n                <version>2.22.2</version>\n                <configuration>\n                    <skipTests>false</skipTests>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n    \n    <profiles>\n        <profile>\n            <id>dev</id>\n            <activation>\n                <activeByDefault>true</activeByDefault>\n            </activation>\n            <properties>\n                <environment>dev</environment>\n            </properties>\n        </profile>\n        <profile>\n            <id>prod</id>\n            <properties>\n                <environment>prod</environment>\n            </properties>\n        </profile>\n    </profiles>\n</project>\n\n// Gradle build.gradle\nplugins {\n    id 'java'\n    id 'org.springframework.boot' version '2.7.8'\n}\n\ngroup = 'com.example'\nversion = '1.0.0'\nsourceCompatibility = '11'\n\ndependencies {\n    // Implementation dependencies\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'\n    \n    // Runtime dependencies\n    runtimeOnly 'mysql:mysql-connector-java:8.0.33'\n    \n    // Test dependencies\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n    testImplementation 'junit:junit:4.13.2'\n    \n    // Development only\n    developmentOnly 'org.springframework.boot:spring-boot-devtools'\n}\n\ntest {\n    useJUnitPlatform()\n}\n\n// Task customization\ntask hello {\n    doLast {\n        println 'Hello from Gradle!'\n    }\n}",
            "components": [
              {
                "name": "Maven POM",
                "english": "Project Object Model - Maven configuration file",
                "hinglish": "Project Object Model - Maven configuration file",
                "importance": "High",
                "tip": "Use dependencyManagement for version management in multi-module projects",
                "role": "Define project structure, dependencies, build process",
                "pros": "Standard, widely used, good IDE support",
                "cons": "XML verbose, slower than Gradle",
                "example": "pom.xml with dependencies, plugins, profiles",
                "use_case": "Java project build and dependency management"
              }
            ],
            "comparison_table": {
              "headers": ["Feature", "Maven", "Gradle"],
              "rows": [
                ["Configuration", "XML (pom.xml)", "Groovy/Kotlin DSL (build.gradle)"],
                ["Performance", "Slower", "Faster (incremental builds)"],
                ["Flexibility", "Less flexible", "Highly flexible"],
                ["Learning Curve", "Easier", "Steeper"],
                ["Plugins", "Large ecosystem", "Large ecosystem"],
                ["Build Script", "Declarative", "Imperative + Declarative"]
              ]
            },
            "decision_table": {
              "headers": ["Project Requirement", "Build Tool"],
              "rows": [
                ["Simple Java project", "Maven"],
                ["Complex build logic", "Gradle"],
                ["Android development", "Gradle"],
                ["Large multi-module", "Gradle (better performance)"],
                ["Corporate standard", "Maven (more established)"]
              ]
            },
            "best_practices": [
              {
                "practice": "Dependency versions properties mein define karein",
                "reason": "Centralized version management, easy updates",
                "hinglish": "Dependency versions properties mein rakho, manage karna easy rahega"
              }
            ]
          }
        },
        {
          "id": 2,
          "title": "Testing - JUnit, Mockito, TDD",
          "english": "Unit testing, mocking, and test-driven development",
          "hinglish": "Unit testing, mocking, aur test-driven development",
          "examples": [
            "@Test\npublic void testAddition() {\n    Calculator calc = new Calculator();\n    assertEquals(5, calc.add(2, 3));\n}",
            "@Mock\nprivate UserRepository userRepository;\n\n@InjectMocks\nprivate UserService userService;\n\n@Test\npublic void testGetUser() {\n    when(userRepository.findById(1L)).thenReturn(new User(\"John\"));\n    User user = userService.getUser(1L);\n    assertEquals(\"John\", user.getName());\n}"
          ],
          "practice": [
            {
              "question": "JUnit 4 aur JUnit 5 mein kya antar hai?",
              "answer": "JUnit 5: @BeforeEach/@AfterEach, @DisplayName, extensions, better parameterized tests"
            },
            {
              "question": "Mockito ka use kyun karte hain?",
              "answer": "Dependencies mock karne ke liye taki unit tests isolated rahe"
            },
            {
              "question": "TDD ka process kya hai?",
              "answer": "Red → Green → Refactor: Pehle test likho (fail), phir code likho (pass), phir refactor"
            },
            {
              "question": "Integration testing kya hoti hai?",
              "answer": "Multiple components ek saath test karna, actual database, network calls ke saath"
            }
          ],
          "detailed_explanation": {
            "example_code": "import org.junit.jupiter.api.*;\nimport org.junit.jupiter.params.*;\nimport org.junit.jupiter.params.provider.*;\nimport org.mockito.*;\nimport java.util.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\n// 1. Unit Testing Example\nclass Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n    \n    public int divide(int a, int b) {\n        if(b == 0) {\n            throw new IllegalArgumentException(\"Cannot divide by zero\");\n        }\n        return a / b;\n    }\n}\n\n// JUnit 5 Tests\nclass CalculatorTest {\n    private Calculator calculator;\n    \n    @BeforeEach\n    void setUp() {\n        calculator = new Calculator();\n        System.out.println(\"Setup before each test\");\n    }\n    \n    @AfterEach\n    void tearDown() {\n        System.out.println(\"Cleanup after each test\");\n    }\n    \n    @Test\n    @DisplayName(\"Test addition of two numbers\")\n    void testAddition() {\n        // Act\n        int result = calculator.add(2, 3);\n        \n        // Assert\n        assertEquals(5, result, \"2 + 3 should equal 5\");\n    }\n    \n    @Test\n    @DisplayName(\"Test division by zero throws exception\")\n    void testDivisionByZero() {\n        // Assert exception\n        IllegalArgumentException exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> calculator.divide(10, 0)\n        );\n        \n        assertEquals(\"Cannot divide by zero\", exception.getMessage());\n    }\n    \n    @ParameterizedTest\n    @ValueSource(ints = {1, 2, 3, 4, 5})\n    @DisplayName(\"Parameterized test for addition\")\n    void testAdditionParameterized(int number) {\n        assertEquals(number + 10, calculator.add(number, 10));\n    }\n    \n    @Test\n    @Disabled(\"Temporarily disabled for refactoring\")\n    void disabledTest() {\n        fail(\"This test should be disabled\");\n    }\n}\n\n// 2. Mocking Example\nclass UserService {\n    private UserRepository userRepository;\n    private EmailService emailService;\n    \n    public UserService(UserRepository userRepository, EmailService emailService) {\n        this.userRepository = userRepository;\n        this.emailService = emailService;\n    }\n    \n    public User registerUser(String name, String email) {\n        User user = new User(name, email);\n        User savedUser = userRepository.save(user);\n        emailService.sendWelcomeEmail(email);\n        return savedUser;\n    }\n    \n    public User getUser(Long id) {\n        return userRepository.findById(id)\n            .orElseThrow(() -> new RuntimeException(\"User not found\"));\n    }\n}\n\ninterface UserRepository {\n    User save(User user);\n    Optional<User> findById(Long id);\n}\n\ninterface EmailService {\n    void sendWelcomeEmail(String email);\n}\n\nclass User {\n    private Long id;\n    private String name;\n    private String email;\n    \n    public User(String name, String email) {\n        this.name = name;\n        this.email = email;\n    }\n    // getters, setters\n}\n\nclass UserServiceTest {\n    @Mock\n    private UserRepository userRepository;\n    \n    @Mock\n    private EmailService emailService;\n    \n    @InjectMocks\n    private UserService userService;\n    \n    @BeforeEach\n    void setUp() {\n        MockitoAnnotations.openMocks(this);\n    }\n    \n    @Test\n    void testRegisterUser() {\n        // Arrange\n        User user = new User(\"John\", \"john@example.com\");\n        when(userRepository.save(any(User.class))).thenReturn(user);\n        \n        // Act\n        User result = userService.registerUser(\"John\", \"john@example.com\");\n        \n        // Assert\n        assertEquals(\"John\", result.getName());\n        assertEquals(\"john@example.com\", result.getEmail());\n        \n        // Verify interactions\n        verify(userRepository, times(1)).save(any(User.class));\n        verify(emailService, times(1)).sendWelcomeEmail(\"john@example.com\");\n    }\n    \n    @Test\n    void testGetUserNotFound() {\n        // Arrange\n        when(userRepository.findById(999L)).thenReturn(Optional.empty());\n        \n        // Act & Assert\n        RuntimeException exception = assertThrows(\n            RuntimeException.class,\n            () -> userService.getUser(999L)\n        );\n        \n        assertEquals(\"User not found\", exception.getMessage());\n        verify(userRepository, times(1)).findById(999L);\n    }\n}\n\n// 3. TDD Example (Calculator)\nclass TDDCalculator {\n    // Step 1: Write failing test\n    // Step 2: Implement minimum code to pass\n    // Step 3: Refactor\n    \n    public int multiply(int a, int b) {\n        // Initial implementation\n        return a * b;\n    }\n    \n    public int factorial(int n) {\n        if(n < 0) throw new IllegalArgumentException(\"Negative numbers not allowed\");\n        if(n == 0) return 1;\n        return n * factorial(n - 1);\n    }\n}\n\nclass TDDCalculatorTest {\n    private TDDCalculator calculator;\n    \n    @BeforeEach\n    void setUp() {\n        calculator = new TDDCalculator();\n    }\n    \n    @Test\n    void testMultiply() {\n        assertEquals(6, calculator.multiply(2, 3));\n        assertEquals(0, calculator.multiply(5, 0));\n        assertEquals(-10, calculator.multiply(2, -5));\n    }\n    \n    @Test\n    void testFactorial() {\n        assertEquals(1, calculator.factorial(0));\n        assertEquals(1, calculator.factorial(1));\n        assertEquals(120, calculator.factorial(5));\n    }\n    \n    @Test\n    void testFactorialNegative() {\n        assertThrows(IllegalArgumentException.class, \n            () -> calculator.factorial(-1));\n    }\n}\n\n// 4. Spring Boot Testing\n/*\n@SpringBootTest\nclass UserControllerIntegrationTest {\n    @Autowired\n    private TestRestTemplate restTemplate;\n    \n    @Test\n    void testGetAllUsers() {\n        ResponseEntity<List> response = restTemplate.getForEntity(\"/api/users\", List.class);\n        assertEquals(HttpStatus.OK, response.getStatusCode());\n    }\n}\n*/\n\npublic class TestingExamples {\n    public static void main(String[] args) {\n        System.out.println(\"=== TESTING CONCEPTS ===\");\n        \n        System.out.println(\"\\n1. JUnit 5 Annotations:\");\n        System.out.println(\"   @Test - Marks test method\");\n        System.out.println(\"   @BeforeEach/@AfterEach - Before/after each test\");\n        System.out.println(\"   @BeforeAll/@AfterAll - Before/after all tests\");\n        System.out.println(\"   @DisplayName - Custom test name\");\n        System.out.println(\"   @ParameterizedTest - Parameterized tests\");\n        System.out.println(\"   @Tag - Tag tests for filtering\");\n        \n        System.out.println(\"\\n2. Mockito Annotations:\");\n        System.out.println(\"   @Mock - Creates mock object\");\n        System.out.println(\"   @Spy - Creates spy (partial mock)\");\n        System.out.println(\"   @InjectMocks - Injects mocks into test object\");\n        System.out.println(\"   @Captor - Argument captor\");\n        \n        System.out.println(\"\\n3. Common Assertions:\");\n        System.out.println(\"   assertEquals(expected, actual)\");\n        System.out.println(\"   assertTrue(condition)\");\n        System.out.println(\"   assertFalse(condition)\");\n        System.out.println(\"   assertNull(object)\");\n        System.out.println(\"   assertNotNull(object)\");\n        System.out.println(\"   assertThrows(Exception.class, executable)\");\n        System.out.println(\"   assertTimeout(duration, executable)\");\n        \n        System.out.println(\"\\n4. Test Categories:\");\n        System.out.println(\"   Unit Tests - Single component in isolation\");\n        System.out.println(\"   Integration Tests - Multiple components together\");\n        System.out.println(\"   End-to-End Tests - Complete user flows\");\n        System.out.println(\"   Performance Tests - Load, stress testing\");\n        System.out.println(\"   Security Tests - Vulnerability testing\");\n        \n        System.out.println(\"\\n5. TDD Cycle:\");\n        System.out.println(\"   1. Write failing test (Red)\");\n        System.out.println(\"   2. Write minimum code to pass (Green)\");\n        System.out.println(\"   3. Refactor code while tests pass (Refactor)\");\n        \n        System.out.println(\"\\nBest Practices:\");\n        System.out.println(\"1. Test names should describe behavior\");\n        System.out.println(\"2. Follow Arrange-Act-Assert pattern\");\n        System.out.println(\"3. Tests should be independent\");\n        System.out.println(\"4. Use meaningful assertions\");\n        System.out.println(\"5. Test edge cases and error conditions\");\n        System.out.println(\"6. Keep tests fast\");\n        System.out.println(\"7. Mock external dependencies\");\n    }\n}",
            "components": [
              {
                "name": "@Test Annotation",
                "english": "Marks a method as a test method",
                "hinglish": "Method ko test method banata hai",
                "importance": "High",
                "tip": "Use @DisplayName for readable test names",
                "role": "Identify test methods for test runner",
                "pros": "Standard, framework support, easy to use",
                "cons": "None",
                "example": "@Test\nvoid testAddition() { assertEquals(5, 2+3); }",
                "use_case": "All unit tests"
              }
            ],
            "comparison_table": {
              "headers": ["Testing Type", "Scope", "Tools", "When to Use"],
              "rows": [
                ["Unit Testing", "Single class/method", "JUnit, Mockito", "During development, refactoring"],
                ["Integration Testing", "Multiple components", "Spring Test, TestContainers", "API testing, database integration"],
                ["End-to-End Testing", "Complete system", "Selenium, Cypress", "User acceptance, regression"],
                ["Performance Testing", "System under load", "JMeter, Gatling", "Load testing, scalability"],
                ["Security Testing", "Vulnerabilities", "OWASP ZAP, Burp", "Security audits"]
              ]
            },
            "decision_table": {
              "headers": ["Testing Need", "Approach"],
              "rows": [
                ["Business logic", "Unit tests with mocks"],
                ["Database operations", "Integration tests with test DB"],
                ["REST APIs", "Integration tests with TestRestTemplate"],
                ["User interface", "E2E tests with Selenium"],
                ["Performance requirements", "Load tests with JMeter"]
              ]
            },
            "best_practices": [
              {
                "practice": "Test method names descriptive rakhein",
                "reason": "Test failures samajhne mein easy hota hai",
                "hinglish": "Test method ka naam descriptive rakho, failure ka reason samajh mein aaye"
              }
            ]
          }
        },
        {
          "id": 3,
          "title": "Microservices Architecture",
          "english": "Building distributed systems with microservices",
          "hinglish": "Microservices ke saath distributed systems banana",
          "examples": [
            "// Spring Cloud Service Discovery\n@EnableEurekaClient\n@SpringBootApplication\npublic class UserServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(UserServiceApplication.class, args);\n    }\n}",
            "// Feign Client\n@FeignClient(name = \"order-service\")\npublic interface OrderServiceClient {\n    @GetMapping(\"/orders/user/{userId}\")\n    List<Order> getOrdersByUser(@PathVariable Long userId);\n}"
          ],
          "practice": [
            {
              "question": "Microservices ke fayde kya hain?",
              "answer": "Independent deployment, technology diversity, scalability, fault isolation"
            },
            {
              "question": "Service Discovery kyun zaroori hai?",
              "answer": "Dynamic environments mein services ka location pata karne ke liye"
            },
            {
              "question": "Circuit Breaker pattern ka use kya hai?",
              "answer": "Fail fast, cascade failures rokne ke liye"
            },
            {
              "question": "API Gateway kya karta hai?",
              "answer": "Single entry point, routing, authentication, rate limiting"
            }
          ],
          "detailed_explanation": {
            "example_code": "// Note: Microservices require multiple services and configurations\n// This shows structure and concepts\n\n/*\n// 1. User Service (Spring Boot Application)\n@SpringBootApplication\n@EnableEurekaClient  // Register with Eureka\npublic class UserServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(UserServiceApplication.class, args);\n    }\n}\n\n// User Controller\n@RestController\n@RequestMapping(\"/users\")\nclass UserController {\n    @Autowired\n    private UserService userService;\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<User> getUser(@PathVariable Long id) {\n        return ResponseEntity.ok(userService.getUser(id));\n    }\n    \n    @PostMapping\n    public ResponseEntity<User> createUser(@RequestBody User user) {\n        return ResponseEntity.status(HttpStatus.CREATED)\n                           .body(userService.createUser(user));\n    }\n}\n\n// application.yml\nserver:\n  port: 8081\nspring:\n  application:\n    name: user-service\n  datasource:\n    url: jdbc:mysql://localhost:3306/userdb\n    username: root\n    password: password\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka/\n  instance:\n    prefer-ip-address: true\n*/\n\n/*\n// 2. Order Service\n@SpringBootApplication\n@EnableEurekaClient\n@EnableCircuitBreaker  // Enable Hystrix\npublic class OrderServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(OrderServiceApplication.class, args);\n    }\n}\n\n// Feign Client for calling User Service\n@FeignClient(name = \"user-service\", fallback = UserServiceFallback.class)\npublic interface UserServiceClient {\n    @GetMapping(\"/users/{id}\")\n    User getUser(@PathVariable(\"id\") Long userId);\n}\n\n// Fallback implementation\n@Component\nclass UserServiceFallback implements UserServiceClient {\n    @Override\n    public User getUser(Long userId) {\n        // Return default/stub user when user-service is down\n        User user = new User();\n        user.setId(userId);\n        user.setName(\"Fallback User\");\n        return user;\n    }\n}\n\n// Order Controller with Feign Client\n@RestController\n@RequestMapping(\"/orders\")\nclass OrderController {\n    @Autowired\n    private UserServiceClient userServiceClient;\n    \n    @GetMapping(\"/user/{userId}\")\n    public ResponseEntity<List<Order>> getOrdersByUser(@PathVariable Long userId) {\n        // Call user-service via Feign\n        User user = userServiceClient.getUser(userId);\n        \n        // Business logic\n        List<Order> orders = orderService.getOrdersByUser(userId);\n        return ResponseEntity.ok(orders);\n    }\n}\n\n// Hystrix Command\n@Service\nclass OrderService {\n    @HystrixCommand(\n        fallbackMethod = \"getDefaultOrders\",\n        commandProperties = {\n            @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"1000\")\n        }\n    )\n    public List<Order> getOrdersByUser(Long userId) {\n        // Simulate potential delay\n        return orderRepository.findByUserId(userId);\n    }\n    \n    public List<Order> getDefaultOrders(Long userId) {\n        return Collections.emptyList();\n    }\n}\n*/\n\n/*\n// 3. Eureka Server (Service Discovery)\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaServerApplication.class, args);\n    }\n}\n\n// application.yml for Eureka\nserver:\n  port: 8761\neureka:\n  client:\n    register-with-eureka: false\n    fetch-registry: false\n*/\n\n/*\n// 4. API Gateway (Zuul/Spring Cloud Gateway)\n@SpringBootApplication\n@EnableZuulProxy  // Or @EnableDiscoveryClient for Spring Cloud Gateway\npublic class ApiGatewayApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ApiGatewayApplication.class, args);\n    }\n}\n\n// Gateway routes configuration\nzuul:\n  routes:\n    user-service:\n      path: /api/users/**\n      serviceId: user-service\n      stripPrefix: false\n    order-service:\n      path: /api/orders/**\n      serviceId: order-service\n      stripPrefix: false\n*/\n\n/*\n// 5. Config Server (Centralized Configuration)\n@SpringBootApplication\n@EnableConfigServer\npublic class ConfigServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConfigServerApplication.class, args);\n    }\n}\n\n// Services fetch config from config server\nspring:\n  cloud:\n    config:\n      uri: http://localhost:8888\n      name: user-service\n      profile: dev\n*/\n\n/*\n// 6. Dockerfile for Microservice\nFROM openjdk:11-jre-slim\nWORKDIR /app\nCOPY target/user-service.jar app.jar\nEXPOSE 8081\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n*/\n\n/*\n// 7. Docker Compose for local development\nversion: '3.8'\nservices:\n  eureka-server:\n    image: eureka-server:latest\n    ports:\n      - \"8761:8761\"\n  \n  user-service:\n    image: user-service:latest\n    environment:\n      - SPRING_PROFILES_ACTIVE=docker\n      - EUREKA_CLIENT_SERVICEURL_DEFAULTZONE=http://eureka-server:8761/eureka/\n    depends_on:\n      - eureka-server\n      - mysql\n  \n  mysql:\n    image: mysql:8.0\n    environment:\n      - MYSQL_ROOT_PASSWORD=password\n      - MYSQL_DATABASE=userdb\n*/\n\npublic class MicroservicesConcepts {\n    public static void main(String[] args) {\n        System.out.println(\"=== MICROSERVICES ARCHITECTURE ===\");\n        \n        System.out.println(\"\\n1. Key Microservices Patterns:\");\n        System.out.println(\"   • Service Discovery - Eureka, Consul\");\n        System.out.println(\"   • API Gateway - Zuul, Spring Cloud Gateway\");\n        System.out.println(\"   • Circuit Breaker - Hystrix, Resilience4j\");\n        System.out.println(\"   • Distributed Configuration - Config Server\");\n        System.out.println(\"   • Distributed Tracing - Sleuth, Zipkin\");\n        System.out.println(\"   • Load Balancing - Ribbon, Spring Cloud LoadBalancer\");\n        \n        System.out.println(\"\\n2. Spring Cloud Components:\");\n        System.out.println(\"   spring-cloud-starter-netflix-eureka-client - Service registration\");\n        System.out.println(\"   spring-cloud-starter-netflix-zuul - API Gateway\");\n        System.out.println(\"   spring-cloud-starter-netflix-hystrix - Circuit breaker\");\n        System.out.println(\"   spring-cloud-starter-openfeign - Declarative REST client\");\n        System.out.println(\"   spring-cloud-config-server - Configuration server\");\n        \n        System.out.println(\"\\n3. Communication Patterns:\");\n        System.out.println(\"   Synchronous - REST, gRPC\");\n        System.out.println(\"   Asynchronous - Message queues (Kafka, RabbitMQ)\");\n        System.out.println(\"   Service-to-Service - Direct HTTP calls\");\n        System.out.println(\"   Event-Driven - Publish/subscribe\");\n        \n        System.out.println(\"\\n4. Data Management:\");\n        System.out.println(\"   Database per service\");\n        System.out.println(\"   Saga pattern for distributed transactions\");\n        System.out.println(\"   CQRS (Command Query Responsibility Segregation)\");\n        System.out.println(\"   Event sourcing\");\n        \n        System.out.println(\"\\n5. Deployment & Orchestration:\");\n        System.out.println(\"   Docker - Containerization\");\n        System.out.println(\"   Kubernetes - Container orchestration\");\n        System.out.println(\"   Helm - Kubernetes package manager\");\n        System.out.println(\"   Service mesh - Istio, Linkerd\");\n        \n        System.out.println(\"\\n6. Monitoring & Observability:\");\n        System.out.println(\"   Metrics - Prometheus, Micrometer\");\n        System.out.println(\"   Logging - ELK Stack, Graylog\");\n        System.out.println(\"   Tracing - Jaeger, Zipkin\");\n        System.out.println(\"   Health checks - Spring Boot Actuator\");\n        \n        System.out.println(\"\\nBest Practices:\");\n        System.out.println(\"1. Design services around business capabilities\");\n        System.out.println(\"2. Implement circuit breakers for resilience\");\n        System.out.println(\"3. Use API Gateway for edge services\");\n        System.out.println(\"4. Implement distributed tracing\");\n        System.out.println(\"5. Monitor all services centrally\");\n        System.out.println(\"6. Implement proper security (OAuth2, JWT)\");\n        System.out.println(\"7. Use containers for deployment consistency\");\n    }\n}",
            "components": [
              {
                "name": "Service Discovery",
                "english": "Automatically detects network locations of service instances",
                "hinglish": "Service instances ke network locations automatically detect karta hai",
                "importance": "High",
                "tip": "Use Eureka for Spring Cloud, Consul for more features",
                "role": "Dynamic service registration and discovery",
                "pros": "Flexibility, scalability, fault tolerance",
                "cons": "Additional complexity, single point of failure risk",
                "example": "@EnableEurekaClient, @EnableEurekaServer",
                "use_case": "All microservices architectures"
              }
            ],
            "comparison_table": {
              "headers": ["Component", "Spring Cloud", "Alternatives", "Purpose"],
              "rows": [
                ["Service Discovery", "Eureka", "Consul, Zookeeper", "Service registration/lookup"],
                ["API Gateway", "Zuul/Gateway", "Kong, Apigee", "Routing, security, rate limiting"],
                ["Circuit Breaker", "Hystrix", "Resilience4j", "Fault tolerance"],
                ["Config Server", "Config Server", "Consul, etcd", "Centralized configuration"],
                ["Load Balancer", "Ribbon", "Nginx, HAProxy", "Distribute traffic"],
                ["Tracing", "Sleuth/Zipkin", "Jaeger", "Distributed tracing"]
              ]
            },
            "decision_table": {
              "headers": ["Microservices Requirement", "Spring Cloud Solution"],
              "rows": [
                ["Service registration", "Eureka"],
                ["API routing", "Spring Cloud Gateway"],
                ["Fault tolerance", "Resilience4j"],
                ["External calls", "Feign clients"],
                ["Configuration management", "Config Server"],
                ["Distributed tracing", "Sleuth + Zipkin"]
              ]
            },
            "best_practices": [
              {
                "practice": "Circuit breakers implement karein external service calls ke liye",
                "reason": "Cascade failures se bachne ke liye",
                "hinglish": "External service calls ke liye circuit breakers zaroor implement karo"
              }
            ]
          }
        },
        {
          "id": 4,
          "title": "Messaging aur Caching",
          "english": "Asynchronous communication and caching strategies",
          "hinglish": "Asynchronous communication aur caching strategies",
          "examples": [
            "// JMS Message Producer\n@JmsTemplate\npublic void sendOrder(Order order) {\n    jmsTemplate.convertAndSend(\"orders.queue\", order);\n}",
            "// Redis Caching\n@Cacheable(value = \"users\", key = \"#userId\")\npublic User getUser(Long userId) {\n    return userRepository.findById(userId);\n}",
            "// Kafka Producer\n@KafkaListener(topics = \"orders\", groupId = \"order-group\")\npublic void listen(Order order) {\n    orderService.process(order);\n}"
          ],
          "practice": [
            {
              "question": "JMS aur Kafka mein kya antar hai?",
              "answer": "JMS API specification hai, Kafka distributed streaming platform hai"
            },
            {
              "question": "Redis data structures konse support karta hai?",
              "answer": "Strings, Lists, Sets, Hashes, Sorted Sets, Bitmaps, HyperLogLogs, Streams"
            },
            {
              "question": "Message queuing ke models konse hain?",
              "answer": "Point-to-Point (Queue) aur Publish-Subscribe (Topic)"
            },
            {
              "question": "Cache eviction policies kya hote hain?",
              "answer": "LRU (Least Recently Used), LFU (Least Frequently Used), FIFO, Random"
            }
          ],
          "detailed_explanation": {
            "example_code": "import org.springframework.cache.annotation.*;\nimport org.springframework.data.redis.core.*;\nimport org.springframework.jms.core.*;\nimport org.springframework.kafka.annotation.*;\nimport org.springframework.kafka.core.*;\nimport javax.jms.*;\nimport java.util.concurrent.TimeUnit;\n\n// 1. Spring Cache Abstraction\n@Service\nclass ProductService {\n    \n    @Cacheable(value = \"products\", key = \"#id\", unless = \"#result == null\")\n    public Product getProductById(Long id) {\n        System.out.println(\"Fetching product from database: \" + id);\n        // Simulate database call\n        return productRepository.findById(id);\n    }\n    \n    @CachePut(value = \"products\", key = \"#product.id\")\n    public Product updateProduct(Product product) {\n        System.out.println(\"Updating product: \" + product.getId());\n        return productRepository.save(product);\n    }\n    \n    @CacheEvict(value = \"products\", key = \"#id\")\n    public void deleteProduct(Long id) {\n        System.out.println(\"Deleting product: \" + id);\n        productRepository.deleteById(id);\n    }\n    \n    @CacheEvict(value = \"products\", allEntries = true)\n    public void clearProductCache() {\n        System.out.println(\"Clearing all product cache\");\n    }\n}\n\n// Cache Configuration\n/*\n@Configuration\n@EnableCaching\nclass CacheConfig {\n    \n    @Bean\n    public CacheManager cacheManager() {\n        ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager();\n        cacheManager.setCacheNames(Arrays.asList(\"products\", \"users\"));\n        return cacheManager;\n    }\n    \n    // For Redis cache\n    @Bean\n    public RedisCacheManager redisCacheManager(RedisConnectionFactory factory) {\n        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()\n            .entryTtl(Duration.ofMinutes(10))\n            .serializeValuesWith(SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));\n        \n        return RedisCacheManager.builder(factory)\n            .cacheDefaults(config)\n            .build();\n    }\n}\n*/\n\n// 2. Redis Operations\nclass RedisExample {\n    \n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n    \n    private ValueOperations<String, Object> valueOps;\n    private HashOperations<String, String, String> hashOps;\n    private ListOperations<String, Object> listOps;\n    \n    public void redisOperations() {\n        valueOps = redisTemplate.opsForValue();\n        hashOps = redisTemplate.opsForHash();\n        listOps = redisTemplate.opsForList();\n        \n        // String operations\n        valueOps.set(\"user:1:name\", \"John Doe\");\n        valueOps.set(\"user:1:email\", \"john@example.com\", 10, TimeUnit.MINUTES); // TTL\n        \n        String name = (String) valueOps.get(\"user:1:name\");\n        \n        // Hash operations\n        hashOps.put(\"user:1\", \"name\", \"John\");\n        hashOps.put(\"user:1\", \"age\", \"30\");\n        \n        String userName = hashOps.get(\"user:1\", \"name\");\n        \n        // List operations\n        listOps.rightPush(\"tasks\", \"Task 1\");\n        listOps.rightPush(\"tasks\", \"Task 2\");\n        \n        Object firstTask = listOps.leftPop(\"tasks\");\n        \n        // Set operations\n        redisTemplate.opsForSet().add(\"unique:users\", \"user1\", \"user2\", \"user3\");\n        \n        // Sorted set operations\n        redisTemplate.opsForZSet().add(\"leaderboard\", \"player1\", 100);\n        redisTemplate.opsForZSet().add(\"leaderboard\", \"player2\", 200);\n    }\n}\n\n// 3. JMS (Java Message Service)\nclass JMSExample {\n    \n    @Autowired\n    private JmsTemplate jmsTemplate;\n    \n    // Point-to-Point (Queue)\n    public void sendToQueue(Order order) {\n        jmsTemplate.convertAndSend(\"orders.queue\", order, message -> {\n            message.setStringProperty(\"OrderType\", \"PREMIUM\");\n            message.setJMSPriority(9);\n            return message;\n        });\n    }\n    \n    // Publish-Subscribe (Topic)\n    public void publishToTopic(Notification notification) {\n        jmsTemplate.convertAndSend(\"notifications.topic\", notification);\n    }\n    \n    // Message listener\n    @JmsListener(destination = \"orders.queue\")\n    public void receiveOrder(Order order) {\n        System.out.println(\"Received order: \" + order.getId());\n        // Process order\n    }\n}\n\n// 4. Kafka\nclass KafkaExample {\n    \n    @Autowired\n    private KafkaTemplate<String, String> kafkaTemplate;\n    \n    public void sendMessage(String topic, String message) {\n        kafkaTemplate.send(topic, message);\n        \n        // With key\n        kafkaTemplate.send(topic, \"key1\", message);\n        \n        // With callback\n        kafkaTemplate.send(topic, message).addCallback(\n            result -> System.out.println(\"Message sent successfully\"),\n            ex -> System.out.println(\"Failed to send message: \" + ex.getMessage())\n        );\n    }\n    \n    @KafkaListener(topics = \"orders\", groupId = \"order-processor\")\n    public void listen(String message) {\n        System.out.println(\"Received Message: \" + message);\n    }\n    \n    @KafkaListener(topics = \"users\", groupId = \"user-group\",\n                   containerFactory = \"kafkaListenerContainerFactory\")\n    public void listenUser(User user) {\n        System.out.println(\"Received User: \" + user.getName());\n    }\n}\n\n// 5. ActiveMQ/RabbitMQ\n/*\n// RabbitMQ Configuration\n@Configuration\nclass RabbitMQConfig {\n    \n    @Bean\n    public Queue orderQueue() {\n        return new Queue(\"orders\", true); // durable\n    }\n    \n    @Bean\n    public TopicExchange orderExchange() {\n        return new TopicExchange(\"order-exchange\");\n    }\n    \n    @Bean\n    public Binding binding(Queue orderQueue, TopicExchange orderExchange) {\n        return BindingBuilder.bind(orderQueue)\n            .to(orderExchange)\n            .with(\"order.#\");\n    }\n}\n\n// RabbitMQ Listener\n@Component\nclass RabbitMQListener {\n    \n    @RabbitListener(queues = \"orders\")\n    public void processOrder(Order order) {\n        System.out.println(\"Processing order: \" + order.getId());\n    }\n}\n*/\n\npublic class MessagingCachingConcepts {\n    public static void main(String[] args) {\n        System.out.println(\"=== MESSAGING & CACHING ===\");\n        \n        System.out.println(\"\\n1. Caching Strategies:\");\n        System.out.println(\"   • Cache-Aside (Lazy Loading) - Check cache first, then DB\");\n        System.out.println(\"   • Write-Through - Write to cache and DB simultaneously\");\n        System.out.println(\"   • Write-Behind - Write to cache, later to DB\");\n        System.out.println(\"   • Read-Through - Cache automatically loads from DB\");\n        \n        System.out.println(\"\\n2. Cache Eviction Policies:\");\n        System.out.println(\"   • LRU - Least Recently Used\");\n        System.out.println(\"   • LFU - Least Frequently Used\");\n        System.out.println(\"   • FIFO - First In First Out\");\n        System.out.println(\"   • Random - Random selection\");\n        \n        System.out.println(\"\\n3. Message Queue Patterns:\");\n        System.out.println(\"   • Point-to-Point (Queue) - One consumer per message\");\n        System.out.println(\"   • Publish-Subscribe (Topic) - Multiple consumers\");\n        System.out.println(\"   • Request-Reply - Synchronous messaging\");\n        \n        System.out.println(\"\\n4. Messaging Systems Comparison:\");\n        System.out.println(\"   • ActiveMQ - JMS compliant, mature\");\n        System.out.println(\"   • RabbitMQ - AMQP protocol, flexible routing\");\n        System.out.println(\"   • Kafka - High throughput, distributed logs\");\n        System.out.println(\"   • Redis Pub/Sub - Simple, fast, in-memory\");\n        \n        System.out.println(\"\\n5. Redis Data Structures:\");\n        System.out.println(\"   • Strings - Key-value pairs\");\n        System.out.println(\"   • Hashes - Field-value maps\");\n        System.out.println(\"   • Lists - Ordered collections\");\n        System.out.println(\"   • Sets - Unique unordered\");\n        System.out.println(\"   • Sorted Sets - Ordered by score\");\n        System.out.println(\"   • Bitmaps - Bit operations\");\n        \n        System.out.println(\"\\n6. Spring Annotations for Caching:\");\n        System.out.println(\"   @Cacheable - Cache method results\");\n        System.out.println(\"   @CachePut - Update cache\");\n        System.out.println(\"   @CacheEvict - Remove from cache\");\n        System.out.println(\"   @Caching - Group multiple cache operations\");\n        \n        System.out.println(\"\\n7. Message Reliability Patterns:\");\n        System.out.println(\"   • Acknowledgments - Message confirmation\");\n        System.out.println(\"   • Dead Letter Queues - Failed messages\");\n        System.out.println(\"   • Retry mechanisms - Temporary failures\");\n        System.out.println(\"   • Idempotent consumers - Handle duplicates\");\n        \n        System.out.println(\"\\nBest Practices:\");\n        System.out.println(\"1. Use caching for read-heavy, rarely changing data\");\n        System.out.println(\"2. Set appropriate TTL (Time To Live) for cache entries\");\n        System.out.println(\"3. Use message queues for async processing\");\n        System.out.println(\"4. Implement dead letter queues for failed messages\");\n        System.out.println(\"5. Use Kafka for event streaming and log aggregation\");\n        System.out.println(\"6. Monitor cache hit/miss ratios\");\n        System.out.println(\"7. Use Redis for session storage and rate limiting\");\n    }\n}",
            "components": [
              {
                "name": "@Cacheable",
                "english": "Caches method results based on parameters",
                "hinglish": "Parameters ke basis par method results cache karta hai",
                "importance": "High",
                "tip": "Use unless attribute to conditionally cache",
                "role": "Transparent caching of method results",
                "pros": "Simple, declarative, reduces database load",
                "cons": "Cache invalidation complexity",
                "example": "@Cacheable(value=\"users\", key=\"#id\")\npublic User getUser(Long id)",
                "use_case": "Frequently accessed, expensive to compute data"
              }
            ],
            "comparison_table": {
              "headers": ["Technology", "Primary Use", "Pros", "Cons"],
              "rows": [
                ["Redis", "Caching, session storage", "Fast, data structures", "Memory limited"],
                ["Kafka", "Event streaming, logs", "High throughput, durable", "Complex setup"],
                ["RabbitMQ", "Message queuing", "Flexible routing, reliable", "Slower than Kafka"],
                ["ActiveMQ", "JMS messaging", "JMS standard, feature-rich", "Performance issues at scale"],
                ["Memcached", "Simple caching", "Simple, fast", "No persistence, limited features"]
              ]
            },
            "decision_table": {
              "headers": ["Requirement", "Technology"],
              "rows": [
                ["Simple caching", "Redis or Memcached"],
                ["Message queue with complex routing", "RabbitMQ"],
                ["Event streaming/log aggregation", "Kafka"],
                ["JMS compliance needed", "ActiveMQ"],
                ["Session storage", "Redis"],
                ["Real-time analytics", "Kafka Streams"]
              ]
            },
            "best_practices": [
              {
                "practice": "Cache invalidation strategy soch samajh kar plan karein",
                "reason": "Stale data se bachne ke liye",
                "hinglish": "Cache invalidation ka strategy pehle se plan karo"
              }
            ]
          }
        },
        {
          "id": 5,
          "title": "Performance Optimization aur JVM",
          "english": "JVM tuning and performance optimization",
          "hinglish": "JVM tuning aur performance optimization",
          "examples": [
            "// JVM Parameters\n// -Xms512m -Xmx2g -XX:+UseG1GC -XX:MaxGCPauseMillis=200",
            "// Memory leak detection\njmap -dump:live,format=b,file=heap.bin <pid>",
            "// Thread dump\njstack <pid> > thread_dump.txt"
          ],
          "practice": [
            {
              "question": "Heap memory ke sections konse hain?",
              "answer": "Young Generation (Eden, S0, S1), Old Generation, Metaspace (PermGen in Java 7)"
            },
            {
              "question": "Garbage Collector types konse hain?",
              "answer": "Serial, Parallel, CMS, G1, ZGC, Shenandoah"
            },
            {
              "question": "Memory leak kaise detect karte hain?",
              "answer": "Heap dumps analyze karke, memory profiling tools use karke"
            },
            {
              "question": "JVM tuning ke important parameters konse hain?",
              "answer": "-Xms, -Xmx, -XX:MaxMetaspaceSize, -XX:+UseG1GC, -XX:MaxGCPauseMillis"
            }
          ],
          "detailed_explanation": {
            "example_code": "// Performance related code examples and concepts\n\nimport java.lang.management.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\n// 1. Memory Management Example\nclass MemoryIntensiveApp {\n    \n    // Potential memory leak\n    private static final List<byte[]> LEAK_LIST = new ArrayList<>();\n    \n    public void simulateMemoryLeak() {\n        for(int i = 0; i < 1000; i++) {\n            // Allocate 1MB but never release\n            LEAK_LIST.add(new byte[1024 * 1024]);\n            \n            try {\n                Thread.sleep(10);\n            } catch(InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n    \n    public void properMemoryManagement() {\n        List<byte[]> tempList = new ArrayList<>();\n        \n        for(int i = 0; i < 100; i++) {\n            // Use local list that gets GCed\n            tempList.add(new byte[1024 * 1024]);\n        }\n        // tempList goes out of scope and can be GCed\n    }\n}\n\n// 2. JVM Monitoring\nclass JVMMonitoring {\n    \n    public void monitorJVM() {\n        // Get Memory MXBean\n        MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();\n        MemoryUsage heapUsage = memoryMXBean.getHeapMemoryUsage();\n        MemoryUsage nonHeapUsage = memoryMXBean.getNonHeapMemoryUsage();\n        \n        System.out.println(\"Heap Memory Usage:\");\n        System.out.println(\"  Initial: \" + heapUsage.getInit() / (1024*1024) + \" MB\");\n        System.out.println(\"  Used: \" + heapUsage.getUsed() / (1024*1024) + \" MB\");\n        System.out.println(\"  Committed: \" + heapUsage.getCommitted() / (1024*1024) + \" MB\");\n        System.out.println(\"  Max: \" + heapUsage.getMax() / (1024*1024) + \" MB\");\n        \n        // Get Thread MXBean\n        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n        System.out.println(\"\\nThread Count: \" + threadMXBean.getThreadCount());\n        System.out.println(\"Peak Thread Count: \" + threadMXBean.getPeakThreadCount());\n        \n        // Get GC MXBeans\n        List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();\n        for(GarbageCollectorMXBean gcBean : gcBeans) {\n            System.out.println(\"\\nGC: \" + gcBean.getName());\n            System.out.println(\"  Collection Count: \" + gcBean.getCollectionCount());\n            System.out.println(\"  Collection Time: \" + gcBean.getCollectionTime() + \" ms\");\n        }\n    }\n}\n\n// 3. Performance Optimization Techniques\nclass PerformanceOptimizations {\n    \n    // 1. String concatenation optimization\n    public String inefficientStringConcat(List<String> strings) {\n        String result = \"\";\n        for(String str : strings) {\n            result += str; // Creates new String object each time\n        }\n        return result;\n    }\n    \n    public String efficientStringConcat(List<String> strings) {\n        StringBuilder sb = new StringBuilder();\n        for(String str : strings) {\n            sb.append(str); // Uses mutable buffer\n        }\n        return sb.toString();\n    }\n    \n    // 2. Cache expensive operations\n    private Map<Integer, Integer> factorialCache = new ConcurrentHashMap<>();\n    \n    public int factorialWithCache(int n) {\n        return factorialCache.computeIfAbsent(n, k -> {\n            if(k <= 1) return 1;\n            return k * factorialWithCache(k - 1);\n        });\n    }\n    \n    // 3. Lazy initialization\n    private ExpensiveObject expensiveObject;\n    \n    public ExpensiveObject getExpensiveObject() {\n        if(expensiveObject == null) {\n            synchronized(this) {\n                if(expensiveObject == null) { // Double-check locking\n                    expensiveObject = new ExpensiveObject();\n                }\n            }\n        }\n        return expensiveObject;\n    }\n    \n    // 4. Object pooling for expensive objects\n    private ObjectPool<DatabaseConnection> connectionPool;\n    \n    public void useConnectionPool() {\n        DatabaseConnection conn = connectionPool.borrowObject();\n        try {\n            // Use connection\n        } finally {\n            connectionPool.returnObject(conn);\n        }\n    }\n}\n\n// 4. Thread Pool Configuration\nclass ThreadPoolOptimization {\n    \n    public void optimalThreadPool() {\n        int corePoolSize = Runtime.getRuntime().availableProcessors();\n        int maxPoolSize = corePoolSize * 2;\n        \n        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n            corePoolSize,\n            maxPoolSize,\n            60L, TimeUnit.SECONDS,\n            new LinkedBlockingQueue<>(1000),\n            new ThreadPoolExecutor.CallerRunsPolicy() // Handle rejection\n        );\n        \n        // Enable core thread timeout\n        executor.allowCoreThreadTimeOut(true);\n    }\n}\n\n// 5. Profiling Example\nclass ProfilingExample {\n    \n    // Method that might be performance bottleneck\n    public void processData(List<Integer> data) {\n        // CPU intensive operation\n        data.parallelStream()\n            .map(this::expensiveOperation)\n            .collect(Collectors.toList());\n    }\n    \n    private Integer expensiveOperation(Integer n) {\n        // Simulate expensive computation\n        try {\n            Thread.sleep(10);\n        } catch(InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        return n * n;\n    }\n}\n\npublic class PerformanceConcepts {\n    public static void main(String[] args) {\n        System.out.println(\"=== PERFORMANCE OPTIMIZATION & JVM ===\");\n        \n        System.out.println(\"\\n1. JVM Memory Areas:\");\n        System.out.println(\"   • Heap - Object storage\");\n        System.out.println(\"     - Young Generation (Eden, S0, S1)\");\n        System.out.println(\"     - Old Generation\");\n        System.out.println(\"   • Non-Heap\");\n        System.out.println(\"     - Metaspace (Class metadata)\");\n        System.out.println(\"     - Code Cache (Compiled code)\");\n        System.out.println(\"     - Thread Stacks\");\n        \n        System.out.println(\"\\n2. Garbage Collectors:\");\n        System.out.println(\"   • Serial GC - Single thread, small apps\");\n        System.out.println(\"   • Parallel GC (Throughput) - Multiple threads\");\n        System.out.println(\"   • CMS (Concurrent Mark Sweep) - Low pause\");\n        System.out.println(\"   • G1 GC (Garbage First) - Balanced, default in Java 9+\");\n        System.out.println(\"   • ZGC - Low latency, large heaps\");\n        System.out.println(\"   • Shenandoah - Low pause, concurrent\");\n        \n        System.out.println(\"\\n3. Common JVM Parameters:\");\n        System.out.println(\"   -Xms512m - Initial heap size\");\n        System.out.println(\"   -Xmx2g - Maximum heap size\");\n        System.out.println(\"   -Xss256k - Thread stack size\");\n        System.out.println(\"   -XX:MaxMetaspaceSize=256m - Metaspace limit\");\n        System.out.println(\"   -XX:+UseG1GC - Use G1 garbage collector\");\n        System.out.println(\"   -XX:MaxGCPauseMillis=200 - Target max GC pause\");\n        System.out.println(\"   -XX:ParallelGCThreads=4 - GC thread count\");\n        \n        System.out.println(\"\\n4. Performance Profiling Tools:\");\n        System.out.println(\"   • VisualVM - Basic profiling\");\n        System.out.println(\"   • JProfiler - Advanced profiling\");\n        System.out.println(\"   • YourKit - Production profiling\");\n        System.out.println(\"   • Java Flight Recorder (JFR) - Low overhead\");\n        System.out.println(\"   • Java Mission Control (JMC) - JFR analysis\");\n        \n        System.out.println(\"\\n5. Diagnostic Commands:\");\n        System.out.println(\"   jps - Java process status\");\n        System.out.println(\"   jstat - JVM statistics\");\n        System.out.println(\"   jmap - Heap dump\");\n        System.out.println(\"   jstack - Thread dump\");\n        System.out.println(\"   jcmd - All-in-one tool\");\n        \n        System.out.println(\"\\n6. Common Performance Issues:\");\n        System.out.println(\"   • Memory leaks\");\n        System.out.println(\"   • GC overhead\");\n        System.out.println(\"   • Thread contention\");\n        System.out.println(\"   • Deadlocks\");\n        System.out.println(\"   • CPU spikes\");\n        System.out.println(\"   • I/O bottlenecks\");\n        \n        System.out.println(\"\\n7. Optimization Techniques:\");\n        System.out.println(\"   • Use StringBuilder for string concatenation\");\n        System.out.println(\"   • Cache expensive computations\");\n        System.out.println(\"   • Use appropriate data structures\");\n        System.out.println(\"   • Lazy initialization\");\n        System.out.println(\"   • Object pooling\");\n        System.out.println(\"   • Batch operations\");\n        \n        System.out.println(\"\\nBest Practices:\");\n        System.out.println(\"1. Start with sensible JVM defaults\");\n        System.out.println(\"2. Profile before optimizing\");\n        System.out.println(\"3. Monitor GC logs\");\n        System.out.println(\"4. Use appropriate garbage collector\");\n        System.out.println(\"5. Set heap size based on actual usage\");\n        System.out.println(\"6. Use connection/object pooling\");\n        System.out.println(\"7. Implement proper caching strategies\");\n    }\n}",
            "components": [
              {
                "name": "Garbage Collector",
                "english": "Automatic memory management system",
                "hinglish": "Automatic memory management system",
                "importance": "High",
                "tip": "Use G1GC for most applications (Java 9+ default)",
                "role": "Reclaim unused memory, prevent memory leaks",
                "pros": "Automatic, prevents manual memory errors",
                "cons": "Performance overhead, stop-the-world pauses",
                "example": "-XX:+UseG1GC -XX:MaxGCPauseMillis=200",
                "use_case": "All Java applications"
              }
            ],
            "comparison_table": {
              "headers": ["Garbage Collector", "Best For", "Pause Time", "Throughput"],
              "rows": [
                ["Serial", "Small apps, client", "High", "Low"],
                ["Parallel", "Throughput focused", "Medium", "High"],
                ["CMS", "Low pause requirements", "Low", "Medium"],
                ["G1", "Balanced (default)", "Predictable", "Good"],
                ["ZGC", "Large heaps, low latency", "Very low", "Good"],
                ["Shenandoah", "Low pause, uniform", "Very low", "Good"]
              ]
            },
            "decision_table": {
              "headers": ["Application Type", "GC Recommendation"],
              "rows": [
                ["Small command-line tool", "Serial or default"],
                ["Web application", "G1 or Parallel"],
                ["Low latency (trading)", "ZGC or Shenandoah"],
                ["Batch processing", "Parallel (throughput)"],
                ["Large heap (>32GB)", "G1 or ZGC"]
              ]
            },
            "best_practices": [
              {
                "practice": "GC logs enable karke regularly monitor karein",
                "reason": "Performance issues early detect karne ke liye",
                "hinglish": "GC logs enable karo aur regularly check karo"
              }
            ]
          }
        },
        {
          "id": 6,
          "title": "Security Best Practices",
          "english": "Application security principles and practices",
          "hinglish": "Application security principles aur practices",
          "examples": [
            "// Password hashing with BCrypt\nString hashedPassword = BCrypt.hashpw(password, BCrypt.gensalt());\nboolean valid = BCrypt.checkpw(candidatePassword, hashedPassword);",
            "// JWT Token creation\nString token = Jwts.builder()\n    .setSubject(username)\n    .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))\n    .signWith(SignatureAlgorithm.HS512, SECRET_KEY)\n    .compact();",
            "// PreparedStatement for SQL injection prevention\nPreparedStatement stmt = conn.prepareStatement(\"SELECT * FROM users WHERE id = ?\");\nstmt.setInt(1, userId);"
          ],
          "practice": [
            {
              "question": "SQL injection se kaise bachte hain?",
              "answer": "PreparedStatement use karke, input validate/sanitize karke"
            },
            {
              "question": "XSS attacks kaise prevent karte hain?",
              "answer": "Input escaping, Content Security Policy, HttpOnly cookies"
            },
            {
              "question": "OAuth 2.0 flows konse hain?",
              "answer": "Authorization Code, Implicit, Password, Client Credentials, Refresh Token"
            },
            {
              "question": "Password storage ke best practices kya hain?",
              "answer": "Strong hashing (BCrypt, Argon2), salt use karna, pepper use karna"
            }
          ],
          "detailed_explanation": {
            "example_code": "import org.springframework.security.crypto.bcrypt.*;\nimport org.springframework.security.crypto.encrypt.*;\nimport org.springframework.security.crypto.keygen.*;\nimport io.jsonwebtoken.*;\nimport java.security.*;\nimport java.util.*;\n\n// 1. Password Security\nclass PasswordSecurity {\n    \n    // BCrypt password hashing\n    public String hashPassword(String plainPassword) {\n        return BCrypt.hashpw(plainPassword, BCrypt.gensalt(12)); // 12 rounds\n    }\n    \n    public boolean verifyPassword(String plainPassword, String hashedPassword) {\n        return BCrypt.checkpw(plainPassword, hashedPassword);\n    }\n    \n    // Password strength validation\n    public boolean isPasswordStrong(String password) {\n        // At least 8 characters\n        if(password.length() < 8) return false;\n        \n        // Contains uppercase\n        if(!password.matches(\".*[A-Z].*\")) return false;\n        \n        // Contains lowercase\n        if(!password.matches(\".*[a-z].*\")) return false;\n        \n        // Contains digit\n        if(!password.matches(\".*\\\\d.*\")) return false;\n        \n        // Contains special character\n        if(!password.matches(\".*[!@#$%^&*()].*\")) return false;\n        \n        return true;\n    }\n}\n\n// 2. JWT (JSON Web Token)\nclass JWTExample {\n    private static final String SECRET_KEY = \"your-256-bit-secret-key-change-this\";\n    private static final long EXPIRATION_TIME = 86400000; // 24 hours\n    \n    public String createToken(String username, List<String> roles) {\n        return Jwts.builder()\n            .setSubject(username)\n            .claim(\"roles\", roles)\n            .setIssuedAt(new Date())\n            .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))\n            .signWith(SignatureAlgorithm.HS512, SECRET_KEY)\n            .compact();\n    }\n    \n    public Claims validateToken(String token) {\n        return Jwts.parser()\n            .setSigningKey(SECRET_KEY)\n            .parseClaimsJws(token)\n            .getBody();\n    }\n}\n\n// 3. SQL Injection Prevention\nclass SQLInjectionPrevention {\n    \n    // Vulnerable to SQL injection\n    public List<User> getUsersVulnerable(String name) throws SQLException {\n        Statement stmt = connection.createStatement();\n        // UNSAFE - Direct concatenation\n        ResultSet rs = stmt.executeQuery(\n            \"SELECT * FROM users WHERE name = '\" + name + \"'\");\n        // Attacker can input: ' OR '1'='1\n        return extractUsers(rs);\n    }\n    \n    // Safe - Using PreparedStatement\n    public List<User> getUsersSafe(String name) throws SQLException {\n        PreparedStatement pstmt = connection.prepareStatement(\n            \"SELECT * FROM users WHERE name = ?\");\n        pstmt.setString(1, name); // Parameterized query\n        ResultSet rs = pstmt.executeQuery();\n        return extractUsers(rs);\n    }\n    \n    // Input validation and sanitization\n    public String sanitizeInput(String input) {\n        // Remove SQL keywords\n        String[] sqlKeywords = {\"SELECT\", \"INSERT\", \"DELETE\", \"UPDATE\", \"DROP\", \"UNION\"};\n        String sanitized = input;\n        for(String keyword : sqlKeywords) {\n            sanitized = sanitized.replaceAll(\"(?i)\" + keyword, \"\"); // Case insensitive\n        }\n        \n        // Escape special characters\n        sanitized = sanitized.replace(\"'\", \"''\");\n        sanitized = sanitized.replace(\"\\\"\", \"\\\"\\\"\");\n        \n        return sanitized;\n    }\n}\n\n// 4. XSS (Cross-Site Scripting) Prevention\nclass XSSPrevention {\n    \n    public String escapeHtml(String input) {\n        return input.replace(\"&\", \"&amp;\")\n                   .replace(\"<\", \"&lt;\")\n                   .replace(\">\", \"&gt;\")\n                   .replace(\"\\\"\", \"&quot;\")\n                   .replace(\"'\", \"&#x27;\");\n    }\n    \n    public String sanitizeForJavaScript(String input) {\n        return input.replace(\"\\\\\", \"\\\\\\\\\")\n                   .replace(\"'\", \"\\\\'\")\n                   .replace(\"\\\"\", \"\\\\\\\"\")\n                   .replace(\"\\n\", \"\\\\n\")\n                   .replace(\"\\r\", \"\\\\r\");\n    }\n}\n\n// 5. HTTPS/SSL Configuration\nclass SSLExample {\n    /*\n    // Spring Boot SSL configuration\n    server:\n      ssl:\n        key-store: classpath:keystore.p12\n        key-store-password: changeit\n        key-store-type: PKCS12\n        key-alias: tomcat\n      port: 8443\n    \n    // Redirect HTTP to HTTPS\n    @Bean\n    public ServletWebServerFactory servletContainer() {\n        TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory() {\n            @Override\n            protected void postProcessContext(Context context) {\n                SecurityConstraint securityConstraint = new SecurityConstraint();\n                securityConstraint.setUserConstraint(\"CONFIDENTIAL\");\n                SecurityCollection collection = new SecurityCollection();\n                collection.addPattern(\"/*\");\n                securityConstraint.addCollection(collection);\n                context.addConstraint(securityConstraint);\n            }\n        };\n        tomcat.addAdditionalTomcatConnectors(redirectConnector());\n        return tomcat;\n    }\n    */\n}\n\n// 6. CSRF Protection\nclass CSRFProtection {\n    /*\n    // Spring Security CSRF configuration\n    @Configuration\n    @EnableWebSecurity\n    public class SecurityConfig extends WebSecurityConfigurerAdapter {\n        \n        @Override\n        protected void configure(HttpSecurity http) throws Exception {\n            http\n                .csrf()\n                    .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())\n                .and()\n                // other configurations\n        }\n    }\n    \n    // In HTML forms\n    <input type=\"hidden\" name=\"_csrf\" value=\"${_csrf.token}\"/>\n    */\n}\n\n// 7. Encryption/Decryption\nclass EncryptionExample {\n    \n    public String encrypt(String plainText, String key) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\n        SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n        GCMParameterSpec gcmSpec = new GCMParameterSpec(128, new byte[12]); // 96-bit IV\n        \n        cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);\n        byte[] encrypted = cipher.doFinal(plainText.getBytes());\n        \n        return Base64.getEncoder().encodeToString(encrypted);\n    }\n    \n    public String decrypt(String encryptedText, String key) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\n        SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n        GCMParameterSpec gcmSpec = new GCMParameterSpec(128, new byte[12]);\n        \n        cipher.init(Cipher.DECRYPT_MODE, keySpec, gcmSpec);\n        byte[] decrypted = cipher.doFinal(Base64.getDecoder().decode(encryptedText));\n        \n        return new String(decrypted);\n    }\n}\n\npublic class SecurityConcepts {\n    public static void main(String[] args) {\n        System.out.println(\"=== SECURITY BEST PRACTICES ===\");\n        \n        System.out.println(\"\\n1. OWASP Top 10 (2021):\");\n        System.out.println(\"   A01: Broken Access Control\");\n        System.out.println(\"   A02: Cryptographic Failures\");\n        System.out.println(\"   A03: Injection\");\n        System.out.println(\"   A04: Insecure Design\");\n        System.out.println(\"   A05: Security Misconfiguration\");\n        System.out.println(\"   A06: Vulnerable Components\");\n        System.out.println(\"   A07: Identification Failures\");\n        System.out.println(\"   A08: Software Integrity Failures\");\n        System.out.println(\"   A09: Security Logging Failures\");\n        System.out.println(\"   A10: Server-Side Request Forgery\");\n        \n        System.out.println(\"\\n2. Authentication & Authorization:\");\n        System.out.println(\"   • OAuth 2.0 - Authorization framework\");\n        System.out.println(\"   • JWT (JSON Web Tokens) - Stateless tokens\");\n        System.out.println(\"   • Spring Security - Comprehensive security framework\");\n        System.out.println(\"   • Password hashing - BCrypt, Argon2, PBKDF2\");\n        \n        System.out.println(\"\\n3. Input Validation & Sanitization:\");\n        System.out.println(\"   • SQL Injection prevention - Prepared statements\");\n        System.out.println(\"   • XSS prevention - Output encoding\");\n        System.out.println(\"   • File upload validation - File type, size limits\");\n        System.out.println(\"   • Regular expression validation\");\n        \n        System.out.println(\"\\n4. Secure Communication:\");\n        System.out.println(\"   • HTTPS/SSL/TLS - Encrypted communication\");\n        System.out.println(\"   • Certificate management\");\n        System.out.println(\"   • HSTS (HTTP Strict Transport Security)\");\n        System.out.println(\"   • CORS (Cross-Origin Resource Sharing)\");\n        \n        System.out.println(\"\\n5. Session Security:\");\n        System.out.println(\"   • Secure cookies (Secure, HttpOnly flags)\");\n        System.out.println(\"   • Session timeout\");\n        System.out.println(\"   • CSRF tokens\");\n        System.out.println(\"   • Session fixation prevention\");\n        \n        System.out.println(\"\\n6. Cryptography:\");\n        System.out.println(\"   • Symmetric encryption - AES\");\n        System.out.println(\"   • Asymmetric encryption - RSA\");\n        System.out.println(\"   • Hashing - SHA-256, SHA-512\");\n        System.out.println(\"   • Digital signatures\");\n        \n        System.out.println(\"\\n7. Security Headers:\");\n        System.out.println(\"   • Content-Security-Policy - XSS protection\");\n        System.out.println(\"   • X-Frame-Options - Clickjacking protection\");\n        System.out.println(\"   • X-Content-Type-Options - MIME sniffing\");\n        System.out.println(\"   • Referrer-Policy - Referrer information\");\n        \n        System.out.println(\"\\nBest Practices:\");\n        System.out.println(\"1. Always use HTTPS in production\");\n        System.out.println(\"2. Never store plain text passwords\");\n        System.out.println(\"3. Use parameterized queries for SQL\");\n        System.out.println(\"4. Validate and sanitize all inputs\");\n        System.out.println(\"5. Implement proper error handling\");\n        System.out.println(\"6. Keep dependencies updated\");\n        System.out.println(\"7. Regular security audits and penetration testing\");\n        System.out.println(\"8. Implement proper logging and monitoring\");\n        System.out.println(\"9. Use security headers\");\n        System.out.println(\"10. Follow principle of least privilege\");\n    }\n}",
            "components": [
              {
                "name": "PreparedStatement",
                "english": "Precompiled SQL statement that prevents SQL injection",
                "hinglish": "Precompiled SQL statement jo SQL injection se bachata hai",
                "importance": "High",
                "tip": "Always use PreparedStatement for user input in SQL",
                "role": "Secure database queries",
                "pros": "SQL injection prevention, performance",
                "cons": "Slightly more code",
                "example": "PreparedStatement pstmt = conn.prepareStatement(\"SELECT * FROM users WHERE id = ?\");\npstmt.setInt(1, userId);",
                "use_case": "All database queries with user input"
              }
            ],
            "comparison_table": {
              "headers": ["Security Threat", "Prevention Method", "Example"],
              "rows": [
                ["SQL Injection", "Prepared statements", "PreparedStatement, parameterized queries"],
                ["XSS", "Output encoding", "HTML escaping, CSP headers"],
                ["CSRF", "CSRF tokens", "Spring Security CSRF protection"],
                ["Session Hijacking", "Secure cookies", "HttpOnly, Secure flags"],
                ["Brute Force", "Rate limiting", "Login attempt limits"],
                ["Information Disclosure", "Error handling", "Generic error messages"]
              ]
            },
            "decision_table": {
              "headers": ["Security Requirement", "Implementation"],
              "rows": [
                ["User authentication", "Spring Security, OAuth2, JWT"],
                ["Data protection", "Encryption (AES), HTTPS"],
                ["Input security", "Validation, sanitization, prepared statements"],
                ["Session management", "Secure cookies, session timeout"],
                ["API security", "API keys, rate limiting, CORS"],
                ["Compliance", "Logging, auditing, regular updates"]
              ]
            },
            "best_practices": [
              {
                "practice": "Security headers always implement karein",
                "reason": "Common attacks se basic protection",
                "hinglish": "Security headers hamesha implement karo"
              }
            ]
          }
        },
        {
          "id": 7,
          "title": "DevOps Practices",
          "english": "CI/CD, Docker, Kubernetes, and DevOps tools",
          "hinglish": "CI/CD, Docker, Kubernetes, aur DevOps tools",
          "examples": [
            "// Dockerfile\nFROM openjdk:11-jre-slim\nCOPY target/app.jar app.jar\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]",
            "// Jenkinsfile (Declarative Pipeline)\npipeline {\n    agent any\n    stages {\n        stage('Build') { steps { sh 'mvn clean package' } }\n        stage('Test') { steps { sh 'mvn test' } }\n        stage('Deploy') { steps { sh './deploy.sh' } }\n    }\n}",
            "// Kubernetes Deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myapp\nspec:\n  replicas: 3\n  template:\n    spec:\n      containers:\n      - name: myapp\n        image: myapp:latest"
          ],
          "practice": [
            {
              "question": "CI/CD kya hota hai?",
              "answer": "Continuous Integration (code merge aur test) aur Continuous Deployment (production deploy)"
            },
            {
              "question": "Docker container aur VM mein kya antar hai?",
              "answer": "Container OS share karte hain, lightweight hote hain; VM har ek complete OS run karta hai"
            },
            {
              "question": "Kubernetes pods kya hote hain?",
              "answer": "Smallest deployable units, ek ya multiple containers"
            },
            {
              "question": "Git workflow ke types konse hain?",
              "answer": "Centralized, Feature Branch, GitFlow, Forking"
            }
          ],
          "detailed_explanation": {
            "example_code": "// DevOps concepts and configurations\n\n/*\n// 1. Dockerfile Example\nFROM openjdk:11-jre-slim\n\n# Set working directory\nWORKDIR /app\n\n# Copy jar file\nCOPY target/myapp-1.0.0.jar app.jar\n\n# Create non-root user\nRUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app\nUSER appuser\n\n# Expose port\nEXPOSE 8080\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n    CMD curl -f http://localhost:8080/actuator/health || exit 1\n\n# Entry point\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n\n# Build command: docker build -t myapp:latest .\n# Run command: docker run -p 8080:8080 myapp:latest\n*/\n\n/*\n// 2. Docker Compose Example\nversion: '3.8'\nservices:\n  app:\n    build: .\n    ports:\n      - \"8080:8080\"\n    environment:\n      - SPRING_PROFILES_ACTIVE=docker\n      - DB_HOST=postgres\n    depends_on:\n      - postgres\n      - redis\n    networks:\n      - backend\n  \n  postgres:\n    image: postgres:13\n    environment:\n      - POSTGRES_DB=mydb\n      - POSTGRES_USER=user\n      - POSTGRES_PASSWORD=password\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    networks:\n      - backend\n  \n  redis:\n    image: redis:6-alpine\n    command: redis-server --appendonly yes\n    volumes:\n      - redis_data:/data\n    networks:\n      - backend\n  \n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf\n    depends_on:\n      - app\n    networks:\n      - backend\n\nnetworks:\n  backend:\n    driver: bridge\n\nvolumes:\n  postgres_data:\n  redis_data:\n*/\n\n/*\n// 3. Kubernetes Deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myapp-deployment\n  labels:\n    app: myapp\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: myapp\n  template:\n    metadata:\n      labels:\n        app: myapp\n    spec:\n      containers:\n      - name: myapp\n        image: myapp:1.0.0\n        ports:\n        - containerPort: 8080\n        env:\n        - name: SPRING_PROFILES_ACTIVE\n          value: \"production\"\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"100m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /actuator/health/liveness\n            port: 8080\n          initialDelaySeconds: 60\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /actuator/health/readiness\n            port: 8080\n          initialDelaySeconds: 30\n          periodSeconds: 5\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: myapp-service\nspec:\n  selector:\n    app: myapp\n  ports:\n  - port: 80\n    targetPort: 8080\n  type: LoadBalancer\n*/\n\n/*\n// 4. Jenkins Pipeline (Jenkinsfile)\npipeline {\n    agent any\n    \n    environment {\n        APP_NAME = 'myapp'\n        DOCKER_REGISTRY = 'myregistry.com'\n        KUBE_CONFIG = credentials('kubeconfig')\n    }\n    \n    stages {\n        stage('Checkout') {\n            steps {\n                git branch: 'main', \n                    url: 'https://github.com/myorg/myapp.git'\n            }\n        }\n        \n        stage('Build') {\n            steps {\n                sh 'mvn clean compile'\n            }\n        }\n        \n        stage('Test') {\n            steps {\n                sh 'mvn test'\n            }\n            post {\n                always {\n                    junit 'target/surefire-reports/*.xml'\n                }\n            }\n        }\n        \n        stage('Package') {\n            steps {\n                sh 'mvn package -DskipTests'\n            }\n        }\n        \n        stage('Docker Build') {\n            steps {\n                script {\n                    docker.build(\"${APP_NAME}:${BUILD_NUMBER}\")\n                }\n            }\n        }\n        \n        stage('Docker Push') {\n            steps {\n                script {\n                    docker.withRegistry(\"https://${DOCKER_REGISTRY}\", 'docker-credentials') {\n                        docker.image(\"${APP_NAME}:${BUILD_NUMBER}\").push()\n                        docker.image(\"${APP_NAME}:${BUILD_NUMBER}\").push('latest')\n                    }\n                }\n            }\n        }\n        \n        stage('Deploy to Kubernetes') {\n            steps {\n                withKubeConfig([credentialsId: 'kubeconfig']) {\n                    sh '''\n                        kubectl set image deployment/myapp-deployment \\\n                            myapp=${DOCKER_REGISTRY}/${APP_NAME}:${BUILD_NUMBER}\n                        kubectl rollout status deployment/myapp-deployment\n                    '''\n                }\n            }\n        }\n    }\n    \n    post {\n        success {\n            echo 'Pipeline succeeded!'\n        }\n        failure {\n            echo 'Pipeline failed!'\n            mail to: 'team@example.com',\n                subject: \"Pipeline Failed: ${currentBuild.fullDisplayName}\",\n                body: \"Check ${env.BUILD_URL}\"\n        }\n    }\n}\n*/\n\n/*\n// 5. Git Workflow Example\n# Feature branch workflow\n\n# Create new feature branch\ngit checkout -b feature/new-authentication\n\n# Make changes and commit\ngit add .\ngit commit -m \"Add OAuth2 authentication\"\n\n# Push to remote\ngit push origin feature/new-authentication\n\n# Create Pull Request on GitHub/GitLab\n# After review and approval:\n\ngit checkout main\ngit pull origin main\ngit merge --no-ff feature/new-authentication\ngit push origin main\n\ngit branch -d feature/new-authentication\n*/\n\n/*\n// 6. Helm Chart (Kubernetes package manager)\n# Chart.yaml\napiVersion: v2\nname: myapp\nversion: 1.0.0\n\ntemplates/deployment.yaml\n{{- include \"common.deployment\" . }}\n\nvalues.yaml\nreplicaCount: 3\n\nimage:\n  repository: myregistry.com/myapp\n  tag: latest\n  pullPolicy: Always\n\nservice:\n  type: ClusterIP\n  port: 8080\n\nresources:\n  requests:\n    memory: 256Mi\n    cpu: 100m\n  limits:\n    memory: 512Mi\n    cpu: 500m\n\n# Install: helm install myapp ./myapp\n# Upgrade: helm upgrade myapp ./myapp\n*/\n\npublic class DevOpsConcepts {\n    public static void main(String[] args) {\n        System.out.println(\"=== DEVOPS PRACTICES ===\");\n        \n        System.out.println(\"\\n1. CI/CD Pipeline Stages:\");\n        System.out.println(\"   • Source - Code repository (Git)\");\n        System.out.println(\"   • Build - Compile, package\");\n        System.out.println(\"   • Test - Unit, integration tests\");\n        System.out.println(\"   • Deploy - Staging, production\");\n        System.out.println(\"   • Monitor - Logs, metrics\");\n        \n        System.out.println(\"\\n2. Containerization:\");\n        System.out.println(\"   • Docker - Container runtime\");\n        System.out.println(\"   • Container registries - Docker Hub, ECR, GCR\");\n        System.out.println(\"   • Best practices\");\n        System.out.println(\"     - Use minimal base images\");\n        System.out.println(\"     - Create non-root users\");\n        System.out.println(\"     - Implement health checks\");\n        System.out.println(\"     - Use .dockerignore\");\n        \n        System.out.println(\"\\n3. Container Orchestration (Kubernetes):\");\n        System.out.println(\"   • Pods - Smallest deployable units\");\n        System.out.println(\"   • Deployments - Manage pod replicas\");\n        System.out.println(\"   • Services - Network abstraction\");\n        System.out.println(\"   • ConfigMaps & Secrets - Configuration\");\n        System.out.println(\"   • Ingress - External access\");\n        System.out.println(\"   • Horizontal Pod Autoscaler - Auto-scaling\");\n        \n        System.out.println(\"\\n4. Infrastructure as Code (IaC):\");\n        System.out.println(\"   • Terraform - Cloud infrastructure\");\n        System.out.println(\"   • CloudFormation - AWS specific\");\n        System.out.println(\"   • Ansible - Configuration management\");\n        System.out.println(\"   • Helm - Kubernetes packages\");\n        \n        System.out.println(\"\\n5. CI/CD Tools:\");\n        System.out.println(\"   • Jenkins - Extensible automation server\");\n        System.out.println(\"   • GitLab CI - Integrated with GitLab\");\n        System.out.println(\"   • GitHub Actions - GitHub integrated\");\n        System.out.println(\"   • CircleCI - Cloud-based\");\n        System.out.println(\"   • Azure DevOps - Microsoft ecosystem\");\n        \n        System.out.println(\"\\n6. Monitoring & Observability:\");\n        System.out.println(\"   • Metrics - Prometheus\");\n        System.out.println(\"   • Logging - ELK Stack (Elasticsearch, Logstash, Kibana)\");\n        System.out.println(\"   • Tracing - Jaeger, Zipkin\");\n        System.out.println(\"   • Alerting - Alertmanager, PagerDuty\");\n        \n        System.out.println(\"\\n7. Cloud Platforms:\");\n        System.out.println(\"   • AWS - EC2, S3, RDS, EKS\");\n        System.out.println(\"   • Azure - VMs, Blob Storage, AKS\");\n        System.out.println(\"   • Google Cloud - Compute Engine, GKE\");\n        System.out.println(\"   • Serverless - AWS Lambda, Azure Functions\");\n        \n        System.out.println(\"\\nBest Practices:\");\n        System.out.println(\"1. Implement Infrastructure as Code\");\n        System.out.println(\"2. Use containerization for consistency\");\n        System.out.println(\"3. Implement comprehensive CI/CD pipelines\");\n        System.out.println(\"4. Use feature branches and pull requests\");\n        System.out.println(\"5. Monitor applications and infrastructure\");\n        System.out.println(\"6. Implement auto-scaling\");\n        System.out.println(\"7. Use blue-green or canary deployments\");\n        System.out.println(\"8. Implement disaster recovery plans\");\n        System.out.println(\"9. Secure your pipeline (secrets management)\");\n        System.out.println(\"10. Document everything\");\n    }\n}",
            "components": [
              {
                "name": "Dockerfile",
                "english": "Script to build Docker container images",
                "hinglish": "Docker container images build karne ka script",
                "importance": "High",
                "tip": "Use multi-stage builds to reduce image size",
                "role": "Define container environment and application",
                "pros": "Reproducible, portable, consistent environments",
                "cons": "Learning curve, security considerations",
                "example": "FROM openjdk:11, COPY, RUN, CMD instructions",
                "use_case": "All containerized applications"
              }
            ],
            "comparison_table": {
              "headers": ["Tool", "Primary Use", "Pros", "Cons"],
              "rows": [
                ["Docker", "Containerization", "Portable, lightweight", "Security concerns"],
                ["Kubernetes", "Orchestration", "Scalable, self-healing", "Complex"],
                ["Jenkins", "CI/CD", "Extensible, mature", "Maintenance overhead"],
                ["GitLab CI", "CI/CD", "Integrated, easy setup", "Vendor lock-in"],
                ["Terraform", "Infrastructure as Code", "Multi-cloud, declarative", "State management"],
                ["Ansible", "Configuration", "Agentless, simple", "Performance at scale"]
              ]
            },
            "decision_table": {
              "headers": ["Requirement", "DevOps Solution"],
              "rows": [
                ["Container packaging", "Docker"],
                ["Container orchestration", "Kubernetes"],
                ["CI/CD pipeline", "Jenkins/GitLab CI"],
                ["Infrastructure provisioning", "Terraform"],
                ["Configuration management", "Ansible"],
                ["Monitoring", "Prometheus + Grafana"],
                ["Logging", "ELK Stack"]
              ]
            },
            "best_practices": [
              {
                "practice": "Multi-stage Docker builds use karein",
                "reason": "Smaller final image size, better security",
                "hinglish": "Dockerfile mein multi-stage builds use karo"
              }
            ]
          }
        },
        {
          "id": 8,
          "title": "Cloud Platforms aur Monitoring",
          "english": "Cloud deployment and application monitoring",
          "hinglish": "Cloud deployment aur application monitoring",
          "examples": [
            "// AWS SDK example\nAmazonS3 s3Client = AmazonS3ClientBuilder.standard()\n    .withRegion(Regions.US_EAST_1)\n    .build();\ns3Client.putObject(\"my-bucket\", \"key\", new File(\"file.txt\"));",
            "// Logging with SLF4J\nimport org.slf4j.*;\nprivate static final Logger logger = LoggerFactory.getLogger(MyClass.class);\nlogger.info(\"User {} logged in\", username);",
            "// Micrometer metrics\nMeterRegistry registry = new SimpleMeterRegistry();\nCounter counter = Counter.builder(\"api.calls\")\n    .description(\"API calls count\")\n    .register(registry);\ncounter.increment();"
          ],
          "practice": [
            {
              "question": "AWS ke main services konse hain?",
              "answer": "EC2 (compute), S3 (storage), RDS (database), Lambda (serverless), EKS (Kubernetes)"
            },
            {
              "question": "Log4j2 aur SLF4J mein kya sambandh hai?",
              "answer": "SLF4J logging facade hai, Log4j2 actual implementation hai"
            },
            {
              "question": "ELK Stack kya hota hai?",
              "answer": "Elasticsearch (search), Logstash (processing), Kibana (visualization)"
            },
            {
              "question": "Micrometer kya hota hai?",
              "answer": "Metrics facade for Java applications, Prometheus, CloudWatch compatible"
            }
          ],
          "detailed_explanation": {
            "example_code": "import org.slf4j.*;\nimport org.apache.logging.log4j.*;\nimport io.micrometer.core.instrument.*;\nimport software.amazon.awssdk.services.s3.*;\nimport software.amazon.awssdk.services.s3.model.*;\nimport java.util.concurrent.TimeUnit;\n\n// 1. Logging with SLF4J and Log4j2\nclass LoggingExample {\n    // SLF4J Logger (interface)\n    private static final org.slf4j.Logger slf4jLogger = \n        org.slf4j.LoggerFactory.getLogger(LoggingExample.class);\n    \n    // Log4j2 Logger (implementation)\n    private static final org.apache.logging.log4j.Logger log4jLogger = \n        org.apache.logging.log4j.LogManager.getLogger(LoggingExample.class);\n    \n    public void performOperation() {\n        String userId = \"123\";\n        String action = \"login\";\n        \n        // Different log levels\n        slf4jLogger.trace(\"Trace level - detailed debugging\");\n        slf4jLogger.debug(\"Debug level - debugging information\");\n        slf4jLogger.info(\"User {} performed {} action\", userId, action); // Parameterized logging\n        slf4jLogger.warn(\"Warning - something unusual\");\n        slf4jLogger.error(\"Error occurred\", new RuntimeException(\"Something went wrong\"));\n        \n        // MDC (Mapped Diagnostic Context) for tracing\n        org.slf4j.MDC.put(\"userId\", userId);\n        org.slf4j.MDC.put(\"requestId\", \"req-123\");\n        \n        slf4jLogger.info(\"Operation with context\");\n        \n        org.slf4j.MDC.clear();\n    }\n}\n\n// 2. Metrics with Micrometer\nclass MetricsExample {\n    private final MeterRegistry meterRegistry;\n    private final Counter apiCallsCounter;\n    private final Timer apiResponseTimer;\n    private final DistributionSummary payloadSizeSummary;\n    \n    public MetricsExample(MeterRegistry meterRegistry) {\n        this.meterRegistry = meterRegistry;\n        \n        // Counter - monotonically increasing\n        this.apiCallsCounter = Counter.builder(\"api.calls.total\")\n            .description(\"Total number of API calls\")\n            .tag(\"service\", \"user-service\")\n            .register(meterRegistry);\n        \n        // Timer - measures duration\n        this.apiResponseTimer = Timer.builder(\"api.response.time\")\n            .description(\"API response time\")\n            .publishPercentiles(0.5, 0.95, 0.99) // 50th, 95th, 99th percentiles\n            .register(meterRegistry);\n        \n        // Distribution summary - measures distribution\n        this.payloadSizeSummary = DistributionSummary.builder(\"api.payload.size\")\n            .description(\"API payload size in bytes\")\n            .baseUnit(\"bytes\")\n            .register(meterRegistry);\n        \n        // Gauge - current value\n        meterRegistry.gaugeCollectionSize(\"queue.size\", Collections.emptyList(), new ArrayList<>());\n    }\n    \n    public void handleApiRequest() {\n        apiCallsCounter.increment();\n        \n        long startTime = System.nanoTime();\n        try {\n            // Simulate API processing\n            Thread.sleep(100);\n            \n            // Record payload size\n            payloadSizeSummary.record(2048); // 2KB payload\n            \n        } catch(InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            long duration = System.nanoTime() - startTime;\n            apiResponseTimer.record(duration, TimeUnit.NANOSECONDS);\n        }\n    }\n}\n\n// 3. AWS SDK Examples\nclass AWSExamples {\n    \n    public void s3Operations() {\n        // Create S3 client\n        S3Client s3Client = S3Client.builder()\n            .region(software.amazon.awssdk.regions.Region.US_EAST_1)\n            .build();\n        \n        try {\n            // List buckets\n            ListBucketsResponse listResponse = s3Client.listBuckets();\n            listResponse.buckets().forEach(bucket -> \n                System.out.println(\"Bucket: \" + bucket.name()));\n            \n            // Upload file\n            PutObjectRequest putRequest = PutObjectRequest.builder()\n                .bucket(\"my-bucket\")\n                .key(\"data/file.txt\")\n                .build();\n            \n            s3Client.putObject(putRequest, \n                software.amazon.awssdk.core.sync.RequestBody.fromFile(\n                    new java.io.File(\"file.txt\")));\n            \n            // Download file\n            GetObjectRequest getRequest = GetObjectRequest.builder()\n                .bucket(\"my-bucket\")\n                .key(\"data/file.txt\")\n                .build();\n            \n            s3Client.getObject(getRequest, \n                software.amazon.awssdk.core.sync.ResponseTransformer.toFile(\n                    new java.io.File(\"downloaded.txt\")));\n                    \n        } finally {\n            s3Client.close();\n        }\n    }\n    \n    public void ec2Operations() {\n        /*\n        Ec2Client ec2Client = Ec2Client.builder()\n            .region(Region.US_EAST_1)\n            .build();\n        \n        // Describe instances\n        DescribeInstancesRequest request = DescribeInstancesRequest.builder().build();\n        DescribeInstancesResponse response = ec2Client.describeInstances(request);\n        \n        // Launch instance\n        RunInstancesRequest runRequest = RunInstancesRequest.builder()\n            .imageId(\"ami-12345678\")\n            .instanceType(InstanceType.T2_MICRO)\n            .maxCount(1)\n            .minCount(1)\n            .build();\n        \n        RunInstancesResponse runResponse = ec2Client.runInstances(runRequest);\n        */\n    }\n}\n\n// 4. Azure SDK Example\nclass AzureExamples {\n    /*\n    // Azure Storage Blob\n    BlobServiceClient blobServiceClient = new BlobServiceClientBuilder()\n        .connectionString(\"DefaultEndpointsProtocol=https;AccountName=...\")\n        .buildClient();\n    \n    // Azure Cosmos DB\n    CosmosClient client = new CosmosClientBuilder()\n        .endpoint(\"https://your-account.documents.azure.com:443/\")\n        .key(\"your-key\")\n        .buildClient();\n    */\n}\n\n// 5. ELK Stack Configuration\nclass ELKConfiguration {\n    /*\n    // log4j2.xml configuration for ELK\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Configuration>\n        <Appenders>\n            <Console name=\"Console\" target=\"SYSTEM_OUT\">\n                <PatternLayout pattern=\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\n            </Console>\n            \n            <Socket name=\"Logstash\" host=\"localhost\" port=\"5000\">\n                <JsonLayout compact=\"true\" eventEol=\"true\">\n                    <KeyValuePair key=\"app\" value=\"myapp\"/>\n                    <KeyValuePair key=\"environment\" value=\"${sys:ENVIRONMENT}\"/>\n                </JsonLayout>\n            </Socket>\n            \n            <RollingFile name=\"File\" fileName=\"logs/app.log\"\n                         filePattern=\"logs/app-%d{yyyy-MM-dd}-%i.log\">\n                <PatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\n                <Policies>\n                    <TimeBasedTriggeringPolicy/>\n                    <SizeBasedTriggeringPolicy size=\"10 MB\"/>\n                </Policies>\n                <DefaultRolloverStrategy max=\"10\"/>\n            </RollingFile>\n        </Appenders>\n        \n        <Loggers>\n            <Root level=\"info\">\n                <AppenderRef ref=\"Console\"/>\n                <AppenderRef ref=\"Logstash\"/>\n                <AppenderRef ref=\"File\"/>\n            </Root>\n        </Loggers>\n    </Configuration>\n    */\n}\n\n// 6. Health Checks\nclass HealthCheckExample {\n    /*\n    // Spring Boot Actuator health checks\n    @Component\n    public class CustomHealthIndicator implements HealthIndicator {\n        \n        @Override\n        public Health health() {\n            boolean databaseUp = checkDatabase();\n            boolean externalServiceUp = checkExternalService();\n            \n            if(databaseUp && externalServiceUp) {\n                return Health.up()\n                    .withDetail(\"database\", \"connected\")\n                    .withDetail(\"external-service\", \"available\")\n                    .build();\n            } else {\n                return Health.down()\n                    .withDetail(\"database\", databaseUp ? \"connected\" : \"disconnected\")\n                    .withDetail(\"external-service\", externalServiceUp ? \"available\" : \"unavailable\")\n                    .build();\n            }\n        }\n        \n        private boolean checkDatabase() {\n            // Check database connection\n            return true;\n        }\n        \n        private boolean checkExternalService() {\n            // Check external service\n            return true;\n        }\n    }\n    */\n}\n\npublic class CloudMonitoringConcepts {\n    public static void main(String[] args) {\n        System.out.println(\"=== CLOUD PLATFORMS & MONITORING ===\");\n        \n        System.out.println(\"\\n1. AWS Core Services:\");\n        System.out.println(\"   • Compute: EC2, Lambda, ECS, EKS\");\n        System.out.println(\"   • Storage: S3, EBS, EFS\");\n        System.out.println(\"   • Database: RDS, DynamoDB, ElastiCache\");\n        System.out.println(\"   • Networking: VPC, Route 53, CloudFront\");\n        System.out.println(\"   • Management: CloudWatch, CloudFormation, IAM\");\n        \n        System.out.println(\"\\n2. Azure Core Services:\");\n        System.out.println(\"   • Compute: Virtual Machines, App Service, AKS\");\n        System.out.println(\"   • Storage: Blob Storage, Files, Disk Storage\");\n        System.out.println(\"   • Database: Cosmos DB, SQL Database\");\n        System.out.println(\"   • AI/ML: Cognitive Services, Machine Learning\");\n        \n        System.out.println(\"\\n3. Google Cloud Core Services:\");\n        System.out.println(\"   • Compute: Compute Engine, App Engine, GKE\");\n        System.out.println(\"   • Storage: Cloud Storage, Persistent Disk\");\n        System.out.println(\"   • Database: Cloud SQL, Firestore, Bigtable\");\n        System.out.println(\"   • Big Data: BigQuery, Dataflow\");\n        \n        System.out.println(\"\\n4. Logging Framework Hierarchy:\");\n        System.out.println(\"   Application → SLF4J (Facade) → Logback/Log4j2 (Implementation)\");\n        System.out.println(\"   Benefits: Decoupling, easy switching, consistent API\");\n        \n        System.out.println(\"\\n5. Log Levels:\");\n        System.out.println(\"   • TRACE - Most detailed\");\n        System.out.println(\"   • DEBUG - Debugging information\");\n        System.out.println(\"   • INFO - Normal operation\");\n        System.out.println(\"   • WARN - Warning\");\n        System.out.println(\"   • ERROR - Error\");\n        System.out.println(\"   • FATAL - Application crash\");\n        \n        System.out.println(\"\\n6. Metrics Types (Micrometer):\");\n        System.out.println(\"   • Counter - Monotonically increasing\");\n        System.out.println(\"   • Gauge - Current value\");\n        System.out.println(\"   • Timer - Duration measurements\");\n        System.out.println(\"   • DistributionSummary - Value distributions\");\n        System.out.println(\"   • LongTaskTimer - Long running tasks\");\n        \n        System.out.println(\"\\n7. ELK Stack Components:\");\n        System.out.println(\"   • Elasticsearch - Search and analytics engine\");\n        System.out.println(\"   • Logstash - Data processing pipeline\");\n        System.out.println(\"   • Kibana - Visualization and dashboards\");\n        System.out.println(\"   • Filebeat - Lightweight log shipper\");\n        \n        System.out.println(\"\\n8. APM (Application Performance Monitoring):\");\n        System.out.println(\"   • New Relic - Full-stack observability\");\n        System.out.println(\"   • Datadog - Infrastructure monitoring\");\n        System.out.println(\"   • AppDynamics - Business performance\");\n        System.out.println(\"   • Dynatrace - AI-powered monitoring\");\n        \n        System.out.println(\"\\nBest Practices:\");\n        System.out.println(\"1. Use structured logging (JSON)\");\n        System.out.println(\"2. Implement distributed tracing\");\n        System.out.println(\"3. Set up alerts for critical metrics\");\n        System.out.println(\"4. Use cloud-native monitoring solutions\");\n        System.out.println(\"5. Implement health checks and readiness probes\");\n        System.out.println(\"6. Use infrastructure as code for cloud resources\");\n        System.out.println(\"7. Implement cost monitoring and optimization\");\n        System.out.println(\"8. Use multiple availability zones for high availability\");\n        System.out.println(\"9. Implement backup and disaster recovery\");\n        System.out.println(\"10. Monitor security compliance\");\n    }\n}",
            "components": [
              {
                "name": "SLF4J",
                "english": "Simple Logging Facade for Java - logging abstraction",
                "hinglish": "Simple Logging Facade for Java - logging abstraction",
                "importance": "High",
                "tip": "Use SLF4J as facade, Logback or Log4j2 as implementation",
                "role": "Provide consistent logging API",
                "pros": "Decoupling, easy to switch implementations",
                "cons": "Additional dependency",
                "example": "private static final Logger logger = LoggerFactory.getLogger(MyClass.class);",
                "use_case": "All Java applications requiring logging"
              }
            ],
            "comparison_table": {
              "headers": ["Monitoring Aspect", "Tools", "Purpose"],
              "rows": [
                ["Logging", "Log4j2, Logback, ELK", "Troubleshooting, audit trails"],
                ["Metrics", "Micrometer, Prometheus", "Performance monitoring, alerts"],
                ["Tracing", "Jaeger, Zipkin", "Distributed transaction tracking"],
                ["APM", "New Relic, AppDynamics", "Application performance insights"],
                ["Infrastructure", "CloudWatch, Datadog", "Resource monitoring"],
                ["Synthetic", "Selenium, Pingdom", "External monitoring"]
              ]
            },
            "decision_table": {
              "headers": ["Monitoring Need", "Solution"],
              "rows": [
                ["Application logs", "ELK Stack or cloud logging"],
                ["Performance metrics", "Prometheus + Grafana"],
                ["Distributed tracing", "Jaeger or Zipkin"],
                ["Business metrics", "Custom metrics with Micrometer"],
                ["User experience", "Real User Monitoring (RUM)"],
                ["Cost monitoring", "Cloud cost management tools"]
              ]
            },
            "best_practices": [
              {
                "practice": "Structured logging (JSON format) implement karein",
                "reason": "Log analysis aur processing easy hota hai",
                "hinglish": "Logging ke liye structured format (JSON) use karo"
              }
            ]
          }
        }
      ]
    }
  ]
}