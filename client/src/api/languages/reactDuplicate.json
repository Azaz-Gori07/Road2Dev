{
    "technology": "React",
    "slug": "react",
    "description": "React is a JavaScript library for building user interfaces, particularly for single-page applications.",
    "levels": [
        {
            "level": "beginner",
            "order": 1,
            "topics": [
                {
                    "id": 1,
                    "title": "JSX Syntax and Basics",
                    "english": "JSX is a syntax extension that allows HTML-like code in JavaScript.",
                    "hinglish": "JSX ek syntax hai jo JavaScript mein HTML jaisa code likhne deta hai.",
                    "examples": [
                        "const element = <h1>Hello, world!</h1>;",
                        "const name = 'John';\nconst element = <h1>Hello, {name}</h1>;"
                    ],
                    "practice": [
                        {
                            "question": "What is JSX?",
                            "answer": "Syntax extension for writing HTML in JavaScript"
                        },
                        {
                            "question": "How to embed JavaScript in JSX?",
                            "answer": "Using curly braces {}"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// JSX with expressions\nconst user = { firstName: 'John', lastName: 'Doe' };\nconst element = (\n  <div>\n    <h1>Hello, {user.firstName} {user.lastName}</h1>\n    <p>{new Date().toLocaleTimeString()}</p>\n    <button disabled={isLoading}>\n      {isLoading ? 'Loading...' : 'Submit'}\n    </button>\n  </div>\n);",
                        "components": [
                            {
                                "name": "HTML-like Syntax",
                                "english": "Write HTML tags directly in JavaScript",
                                "hinglish": "JavaScript mein directly HTML tags likho",
                                "importance": "Familiar syntax for developers",
                                "tip": "Always return single root element"
                            },
                            {
                                "name": "JavaScript Expressions",
                                "english": "Embed JavaScript inside {}",
                                "hinglish": "{} ke andar JavaScript embed karo",
                                "importance": "Dynamic content rendering",
                                "tip": "Any valid JavaScript expression works"
                            },
                            {
                                "name": "JSX Attributes",
                                "english": "Use camelCase for attributes",
                                "hinglish": "Attributes ke liye camelCase use karo",
                                "importance": "Consistency with JavaScript",
                                "tip": "class becomes className, for becomes htmlFor"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Feature",
                                "HTML",
                                "JSX"
                            ],
                            "rows": [
                                [
                                    "Attribute Names",
                                    "class, for",
                                    "className, htmlFor"
                                ],
                                [
                                    "Inline Styles",
                                    "style=\"color: red\"",
                                    "style={{color: 'red'}}"
                                ],
                                [
                                    "Self-closing Tags",
                                    "<br>",
                                    "<br />"
                                ],
                                [
                                    "JavaScript",
                                    "Not possible",
                                    "{expression}"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Always wrap multiple elements",
                                "reason": "JSX must have single parent element",
                                "hinglish": "JSX ko single parent element chahiye"
                            },
                            {
                                "practice": "Use parentheses for multi-line JSX",
                                "reason": "Avoids automatic semicolon insertion issues",
                                "hinglish": "Automatic semicolon issues se bachao"
                            },
                            {
                                "practice": "Keep JSX readable",
                                "reason": "Better maintenance and debugging",
                                "hinglish": "Readable code maintenance mein easy hai"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Forgetting to close tags",
                                "solution": "Always use self-closing syntax for empty tags",
                                "hinglish": "Empty tags ke liye self-closing syntax use karo"
                            },
                            {
                                "mistake": "Using class instead of className",
                                "solution": "Remember JSX uses className attribute",
                                "hinglish": "JSX mein className attribute use hota hai"
                            }
                        ]
                    }
                },
                {
                    "id": 2,
                    "title": "Functional Components and Props",
                    "english": "Functional components are JavaScript functions that return React elements.",
                    "hinglish": "Functional components JavaScript functions hain jo React elements return karte hain.",
                    "examples": [
                        "function Greeting(props) {\n  return <h1>Hello, {props.name}</h1>;\n}",
                        "const Greeting = (props) => <h1>Hello, {props.name}</h1>;"
                    ],
                    "practice": [
                        {
                            "question": "How do you pass data to components?",
                            "answer": "Using props (properties)"
                        },
                        {
                            "question": "Can props be modified inside component?",
                            "answer": "No, props are read-only"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// Functional Component with props\nfunction UserProfile(props) {\n  return (\n    <div className=\"user-profile\">\n      <img src={props.avatarUrl} alt={props.name} />\n      <h2>{props.name}</h2>\n      <p>Age: {props.age}</p>\n      <p>Email: {props.email}</p>\n      {props.isAdmin && <span className=\"admin-badge\">Admin</span>}\n    </div>\n  );\n}\n\n// Using the component\n<UserProfile \n  name=\"John Doe\"\n  age={28}\n  email=\"john@example.com\"\n  avatarUrl=\"/avatar.jpg\"\n  isAdmin={true}\n/>",
                        "components": [
                            {
                                "name": "Component Function",
                                "english": "Function that returns JSX",
                                "hinglish": "Function jo JSX return kare",
                                "importance": "Basic building block of React",
                                "tip": "Always start component names with capital letter"
                            },
                            {
                                "name": "Props Object",
                                "english": "Read-only data passed to component",
                                "hinglish": "Component mein pass ki gayi read-only data",
                                "importance": "Parent-child communication",
                                "tip": "Destructure props for cleaner code"
                            },
                            {
                                "name": "Props Validation",
                                "english": "Type checking for props",
                                "hinglish": "Props ke liye type checking",
                                "importance": "Better debugging and maintenance",
                                "tip": "Use PropTypes or TypeScript"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Aspect",
                                "Functional Component",
                                "Class Component"
                            ],
                            "rows": [
                                [
                                    "Syntax",
                                    "Function or arrow function",
                                    "ES6 class"
                                ],
                                [
                                    "State",
                                    "useState hook",
                                    "this.state"
                                ],
                                [
                                    "Lifecycle",
                                    "useEffect hook",
                                    "componentDidMount etc."
                                ],
                                [
                                    "Performance",
                                    "Slightly better",
                                    "Slightly heavier"
                                ],
                                [
                                    "this keyword",
                                    "Not needed",
                                    "Required"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Destructure props",
                                "reason": "Cleaner code and clear dependencies",
                                "hinglish": "Clean code aur clear dependencies ke liye"
                            },
                            {
                                "practice": "Use default props",
                                "reason": "Handle missing props gracefully",
                                "hinglish": "Missing props ko gracefully handle karo"
                            },
                            {
                                "practice": "Keep components small",
                                "reason": "Better reusability and testing",
                                "hinglish": "Better reusability aur testing ke liye"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Mutating props directly",
                                "solution": "Props are read-only, use state for changes",
                                "hinglish": "Props read-only hain, changes ke liye state use karo"
                            },
                            {
                                "mistake": "Too many props",
                                "solution": "Combine related props into objects",
                                "hinglish": "Related props ko objects mein combine karo"
                            }
                        ]
                    }
                },
                {
                    "id": 3,
                    "title": "State with useState Hook",
                    "english": "useState hook allows functional components to have state.",
                    "hinglish": "useState hook functional components ko state rakne ki capability deta hai.",
                    "examples": [
                        "const [count, setCount] = useState(0);",
                        "const [user, setUser] = useState({ name: '', age: 0 });"
                    ],
                    "practice": [
                        {
                            "question": "Which hook is used for state in functional components?",
                            "answer": "useState"
                        },
                        {
                            "question": "How to update state based on previous state?",
                            "answer": "Pass function to setter: setCount(prev => prev + 1)"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "function Counter() {\n  const [count, setCount] = useState(0);\n  const [user, setUser] = useState({\n    name: 'John',\n    age: 25,\n    preferences: { theme: 'dark', language: 'en' }\n  });\n\n  const increment = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  const updateName = (newName) => {\n    setUser(prevUser => ({\n      ...prevUser,\n      name: newName\n    }));\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n      \n      <p>User: {user.name}, Age: {user.age}</p>\n      <button onClick={() => updateName('Jane')}>\n        Change Name\n      </button>\n    </div>\n  );\n}",
                        "components": [
                            {
                                "name": "useState Hook",
                                "english": "Function that returns state variable and setter",
                                "hinglish": "Function jo state variable aur setter return kare",
                                "importance": "Adds state to functional components",
                                "tip": "Always use at top level of component"
                            },
                            {
                                "name": "State Variable",
                                "english": "Current state value",
                                "hinglish": "Current state ki value",
                                "importance": "Holds component's dynamic data",
                                "tip": "Can be any type: string, number, object, array"
                            },
                            {
                                "name": "Setter Function",
                                "english": "Function to update state",
                                "hinglish": "State update karne wala function",
                                "importance": "Triggers re-render with new state",
                                "tip": "Use functional updates for previous state"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Update Type",
                                "Direct Update",
                                "Functional Update"
                            ],
                            "rows": [
                                [
                                    "Syntax",
                                    "setCount(5)",
                                    "setCount(prev => prev + 1)"
                                ],
                                [
                                    "Use Case",
                                    "Independent updates",
                                    "Based on previous state"
                                ],
                                [
                                    "Multiple Calls",
                                    "May overwrite",
                                    "Queues properly"
                                ],
                                [
                                    "Async Behavior",
                                    "Problematic",
                                    "Correct handling"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Use multiple useState calls",
                                "reason": "Separate concerns, easier to manage",
                                "hinglish": "Concerns alag karo, manage karna easy ho"
                            },
                            {
                                "practice": "Use functional updates",
                                "reason": "Avoid stale state in async operations",
                                "hinglish": "Async operations mein stale state se bachao"
                            },
                            {
                                "practice": "Initialize with function for expensive computation",
                                "reason": "Performance optimization",
                                "hinglish": "Expensive computation ke liye performance optimize karo"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Mutating state directly",
                                "solution": "Always use setter function",
                                "hinglish": "Setter function hi use karo state change ke liye"
                            },
                            {
                                "mistake": "Forgetting to spread objects/arrays",
                                "solution": "Always create new references",
                                "hinglish": "Objects/arrays update karne par new reference banayo"
                            }
                        ]
                    }
                },
                {
                    "id": 4,
                    "title": "Event Handling in React",
                    "english": "React events are named using camelCase and use JSX syntax.",
                    "hinglish": "React events camelCase mein hote hain aur JSX syntax use karte hain.",
                    "examples": [
                        "<button onClick={handleClick}>Click me</button>",
                        "<input onChange={handleChange} value={value} />"
                    ],
                    "practice": [
                        {
                            "question": "How do you handle events in React?",
                            "answer": "Using camelCase event handlers like onClick, onChange"
                        },
                        {
                            "question": "How to pass parameters to event handler?",
                            "answer": "Use arrow function: onClick={() => handleClick(id)}"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "function EventExamples() {\n  const [text, setText] = useState('');\n  const [count, setCount] = useState(0);\n  \n  // Simple click handler\n  const handleClick = (event) => {\n    console.log('Button clicked', event);\n    setCount(prev => prev + 1);\n  };\n  \n  // Input change handler\n  const handleChange = (event) => {\n    setText(event.target.value);\n  };\n  \n  // Form submit handler\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    console.log('Form submitted:', text);\n  };\n  \n  // With parameters\n  const handleItemClick = (itemId, event) => {\n    console.log('Item clicked:', itemId, event);\n  };\n  \n  return (\n    <div>\n      <button onClick={handleClick}>\n        Clicked {count} times\n      </button>\n      \n      <form onSubmit={handleSubmit}>\n        <input \n          type=\"text\" \n          value={text} \n          onChange={handleChange} \n          placeholder=\"Type something...\"\n        />\n        <button type=\"submit\">Submit</button>\n      </form>\n      \n      <div>\n        {[1, 2, 3].map(item => (\n          <button \n            key={item}\n            onClick={(e) => handleItemClick(item, e)}\n          >\n            Item {item}\n          </button>\n        ))}\n      </div>\n    </div>\n  );\n}",
                        "components": [
                            {
                                "name": "Synthetic Events",
                                "english": "React's cross-browser event system",
                                "hinglish": "React ka cross-browser event system",
                                "importance": "Consistent behavior across browsers",
                                "tip": "Events are pooled for performance"
                            },
                            {
                                "name": "Event Handler Functions",
                                "english": "Functions that handle events",
                                "hinglish": "Events handle karne wale functions",
                                "importance": "Define component behavior",
                                "tip": "Name handlers with 'handle' prefix"
                            },
                            {
                                "name": "Event Object",
                                "english": "Contains event information",
                                "hinglish": "Event ki information rakhta hai",
                                "importance": "Access event details like target, type",
                                "tip": "Use event.preventDefault() for forms"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Event Type",
                                "HTML",
                                "React"
                            ],
                            "rows": [
                                [
                                    "Click",
                                    "onclick",
                                    "onClick"
                                ],
                                [
                                    "Change",
                                    "onchange",
                                    "onChange"
                                ],
                                [
                                    "Submit",
                                    "onsubmit",
                                    "onSubmit"
                                ],
                                [
                                    "Mouse Over",
                                    "onmouseover",
                                    "onMouseOver"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Use arrow functions or bind in constructor",
                                "reason": "Maintains correct 'this' context",
                                "hinglish": "Correct 'this' context maintain rahega"
                            },
                            {
                                "practice": "Prevent default behavior when needed",
                                "reason": "Control form submission and link navigation",
                                "hinglish": "Form submission aur link navigation control karo"
                            },
                            {
                                "practice": "Use event delegation for multiple elements",
                                "reason": "Better performance with many event handlers",
                                "hinglish": "Multiple event handlers ke saath better performance"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Calling function instead of passing reference",
                                "solution": "Pass function reference: onClick={handleClick}",
                                "hinglish": "Function reference pass karo, call mat karo"
                            },
                            {
                                "mistake": "Forgetting to prevent default form submission",
                                "solution": "Always call event.preventDefault() in form handlers",
                                "hinglish": "Form handlers mein hamesha event.preventDefault() call karo"
                            }
                        ]
                    }
                },
                {
                    "id": 5,
                    "title": "Conditional Rendering",
                    "english": "Conditional rendering displays different components based on conditions.",
                    "hinglish": "Conditional rendering conditions ke basis par different components show karta hai.",
                    "examples": [
                        "{isLoggedIn ? <UserDashboard /> : <Login />}",
                        "{isLoading && <Spinner />}"
                    ],
                    "practice": [
                        {
                            "question": "What are common ways for conditional rendering?",
                            "answer": "Ternary operators, && operator, if statements"
                        },
                        {
                            "question": "When to use && operator?",
                            "answer": "When you want to render something or nothing"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "function UserInterface() {\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  const [userRole, setUserRole] = useState('user');\n  const [items, setItems] = useState([]);\n  const [isLoading, setIsLoading] = useState(true);\n  \n  // Ternary operator\n  const authComponent = isLoggedIn ? (\n    <Dashboard />\n  ) : (\n    <Login onLogin={() => setIsLoggedIn(true)} />\n  );\n  \n  // && operator (short circuit)\n  const adminPanel = userRole === 'admin' && (\n    <AdminControls />\n  );\n  \n  // Early return\n  if (isLoading) {\n    return <LoadingSpinner />;\n  }\n  \n  // Inline if-else\n  const welcomeMessage = () => {\n    if (isLoggedIn) {\n      return <h1>Welcome back!</h1>;\n    } else {\n      return <h1>Please sign in</h1>;\n    }\n  };\n  \n  // Conditional rendering in JSX\n  return (\n    <div>\n      {welcomeMessage()}\n      \n      {/* Simple condition */}\n      {isLoggedIn && <UserProfile />}\n      \n      {/* Multiple conditions */}\n      {userRole === 'admin' ? (\n        <AdminDashboard />\n      ) : userRole === 'moderator' ? (\n        <ModeratorDashboard />\n      ) : (\n        <UserDashboard />\n      )}\n      \n      {/* Render list or empty state */}\n      {items.length > 0 ? (\n        <ItemList items={items} />\n      ) : (\n        <EmptyState message=\"No items found\" />\n      )}\n      \n      {/* Conditional attribute */}\n      <button \n        disabled={!isLoggedIn}\n        className={isLoggedIn ? 'active' : 'inactive'}\n      >\n        Submit\n      </button>\n    </div>\n  );\n}",
                        "components": [
                            {
                                "name": "Ternary Operator (? :)",
                                "english": "Condition ? trueCase : falseCase",
                                "hinglish": "Condition ? trueCase : falseCase",
                                "importance": "Inline if-else in JSX",
                                "tip": "Keep simple, extract complex logic"
                            },
                            {
                                "name": "Logical && Operator",
                                "english": "Condition && Component",
                                "hinglish": "Condition && Component",
                                "importance": "Render or render nothing",
                                "tip": "Works because false && anything is false"
                            },
                            {
                                "name": "If Statements",
                                "english": "Traditional if/else",
                                "hinglish": "Traditional if/else",
                                "importance": "Complex conditional logic",
                                "tip": "Use outside JSX or in functions"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Method",
                                "Use Case",
                                "Example"
                            ],
                            "rows": [
                                [
                                    "Ternary",
                                    "Either/or rendering",
                                    "{cond ? <A /> : <B />}"
                                ],
                                [
                                    "&& Operator",
                                    "Render or nothing",
                                    "{cond && <A />}"
                                ],
                                [
                                    "If Statement",
                                    "Complex logic",
                                    "if(cond) return <A />"
                                ],
                                [
                                    "Switch",
                                    "Multiple conditions",
                                    "switch(role) { case: ... }"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Extract complex conditions",
                                "reason": "Improves readability and testing",
                                "hinglish": "Readability aur testing improve karta hai"
                            },
                            {
                                "practice": "Avoid nested ternaries",
                                "reason": "Hard to read and maintain",
                                "hinglish": "Padhna aur maintain karna mushkil hota hai"
                            },
                            {
                                "practice": "Use early returns",
                                "reason": "Cleaner code structure",
                                "hinglish": "Clean code structure ke liye"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Using numbers with && operator",
                                "solution": "Convert to boolean explicitly",
                                "hinglish": "&& operator ke saath numbers use mat karo"
                            },
                            {
                                "mistake": "Forgetting null/undefined checks",
                                "solution": "Use optional chaining or default values",
                                "hinglish": "Optional chaining ya default values use karo"
                            }
                        ]
                    }
                },
                {
                    "id": 6,
                    "title": "Lists and Keys",
                    "english": "Render lists of data using map() and assign unique keys for performance.",
                    "hinglish": "map() function se data ki lists render karo aur performance ke liye unique keys assign karo.",
                    "examples": [
                        "{items.map(item => <li key={item.id}>{item.name}</li>)}",
                        "{users.map(user => <UserCard key={user.id} user={user} />)}"
                    ],
                    "practice": [
                        {
                            "question": "Why are keys important in lists?",
                            "answer": "Keys help React identify which items have changed"
                        },
                        {
                            "question": "What makes a good key?",
                            "answer": "Unique and stable identifier like ID from data"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "function TodoList() {\n  const [todos, setTodos] = useState([\n    { id: 1, text: 'Learn React', completed: true },\n    { id: 2, text: 'Build project', completed: false },\n    { id: 3, text: 'Deploy app', completed: false }\n  ]);\n  \n  const [users, setUsers] = useState([\n    { id: 'u1', name: 'John', age: 25 },\n    { id: 'u2', name: 'Jane', age: 30 },\n    { id: 'u3', name: 'Bob', age: 35 }\n  ]);\n  \n  // Simple list rendering\n  const todoItems = todos.map(todo => (\n    <li key={todo.id}>\n      <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n        {todo.text}\n      </span>\n    </li>\n  ));\n  \n  // List with component\n  const userList = users.map(user => (\n    <UserCard \n      key={user.id}\n      user={user}\n      onDelete={() => deleteUser(user.id)}\n    />\n  ));\n  \n  // Inline rendering\n  return (\n    <div>\n      <h2>Todos</h2>\n      <ul>\n        {todos.map(todo => (\n          <TodoItem \n            key={todo.id}\n            todo={todo}\n            onToggle={() => toggleTodo(todo.id)}\n          />\n        ))}\n      </ul>\n      \n      <h2>Users</h2>\n      <div className=\"user-grid\">\n        {users.map((user, index) => (\n          // Avoid index as key when data changes\n          <div key={user.id} className=\"user-card\">\n            <h3>{user.name}</h3>\n            <p>Age: {user.age}</p>\n          </div>\n        ))}\n      </div>\n      \n      {/* List with filter */}\n      <h2>Active Todos</h2>\n      <ul>\n        {todos\n          .filter(todo => !todo.completed)\n          .map(todo => (\n            <li key={todo.id}>{todo.text}</li>\n          ))}\n      </ul>\n    </div>\n  );\n}",
                        "components": [
                            {
                                "name": "Array.map() Method",
                                "english": "Transform array items to React elements",
                                "hinglish": "Array items ko React elements mein transform karo",
                                "importance": "Render dynamic lists from data",
                                "tip": "Always return JSX from map callback"
                            },
                            {
                                "name": "Key Prop",
                                "english": "Unique identifier for each list item",
                                "hinglish": "Har list item ka unique identifier",
                                "importance": "Performance optimization and correct updates",
                                "tip": "Use IDs from data, not array indices"
                            },
                            {
                                "name": "Fragment for Adjacent Elements",
                                "english": "Group multiple elements without wrapper",
                                "hinglish": "Wrapper ke bina multiple elements group karo",
                                "importance": "Clean DOM structure",
                                "tip": "Use <>...</> or <Fragment>...</Fragment>"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Key Type",
                                "When to Use",
                                "Example"
                            ],
                            "rows": [
                                [
                                    "ID from data",
                                    "Always preferred",
                                    "key={item.id}"
                                ],
                                [
                                    "Unique string",
                                    "When no ID exists",
                                    "key={`user-${name}`}"
                                ],
                                [
                                    "Index",
                                    "Static lists only",
                                    "key={index}"
                                ],
                                [
                                    "Generated ID",
                                    "Client-side only",
                                    "key={nanoid()}"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Extract list items to components",
                                "reason": "Better organization and performance",
                                "hinglish": "Better organization aur performance ke liye"
                            },
                            {
                                "practice": "Avoid index as key for dynamic lists",
                                "reason": "Can cause bugs with reordering",
                                "hinglish": "Dynamic lists mein index key se bugs ho sakte hain"
                            },
                            {
                                "practice": "Use stable keys",
                                "reason": "Prevent unnecessary re-renders",
                                "hinglish": "Unnecessary re-renders se bachao"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Missing key prop",
                                "solution": "Always add unique key to list items",
                                "hinglish": "List items mein hamesha unique key add karo"
                            },
                            {
                                "mistake": "Using non-unique keys",
                                "solution": "Ensure keys are unique across siblings",
                                "hinglish": "Keys siblings ke beech unique honi chahiye"
                            }
                        ]
                    }
                },
                {
                    "id": 7,
                    "title": "Forms and Controlled Components",
                    "english": "Controlled components have form data controlled by React state.",
                    "hinglish": "Controlled components mein form data React state se control hota hai.",
                    "examples": [
                        "<input value={name} onChange={e => setName(e.target.value)} />",
                        "<select value={country} onChange={e => setCountry(e.target.value)}>"
                    ],
                    "practice": [
                        {
                            "question": "What is a controlled component?",
                            "answer": "Form element whose value is controlled by React state"
                        },
                        {
                            "question": "How to handle form submission?",
                            "answer": "Use onSubmit handler and prevent default behavior"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "function RegistrationForm() {\n  const [formData, setFormData] = useState({\n    username: '',\n    email: '',\n    password: '',\n    gender: '',\n    acceptTerms: false,\n    country: 'IN',\n    bio: ''\n  });\n  \n  const [errors, setErrors] = useState({});\n  \n  // Generic change handler\n  const handleChange = (e) => {\n    const { name, value, type, checked } = e.target;\n    setFormData(prev => ({\n      ...prev,\n      [name]: type === 'checkbox' ? checked : value\n    }));\n    \n    // Clear error when user types\n    if (errors[name]) {\n      setErrors(prev => ({ ...prev, [name]: '' }));\n    }\n  };\n  \n  // Submit handler\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    \n    // Validation\n    const newErrors = {};\n    if (!formData.username) newErrors.username = 'Username required';\n    if (!formData.email.includes('@')) newErrors.email = 'Invalid email';\n    if (formData.password.length < 6) newErrors.password = 'Password too short';\n    if (!formData.acceptTerms) newErrors.acceptTerms = 'Must accept terms';\n    \n    if (Object.keys(newErrors).length > 0) {\n      setErrors(newErrors);\n      return;\n    }\n    \n    // Submit logic\n    console.log('Form submitted:', formData);\n    alert('Registration successful!');\n  };\n  \n  return (\n    <form onSubmit={handleSubmit} className=\"registration-form\">\n      <div>\n        <label>Username:</label>\n        <input\n          type=\"text\"\n          name=\"username\"\n          value={formData.username}\n          onChange={handleChange}\n          placeholder=\"Enter username\"\n        />\n        {errors.username && <span className=\"error\">{errors.username}</span>}\n      </div>\n      \n      <div>\n        <label>Email:</label>\n        <input\n          type=\"email\"\n          name=\"email\"\n          value={formData.email}\n          onChange={handleChange}\n        />\n        {errors.email && <span className=\"error\">{errors.email}</span>}\n      </div>\n      \n      <div>\n        <label>Password:</label>\n        <input\n          type=\"password\"\n          name=\"password\"\n          value={formData.password}\n          onChange={handleChange}\n        />\n        {errors.password && <span className=\"error\">{errors.password}</span>}\n      </div>\n      \n      <div>\n        <label>Gender:</label>\n        <div>\n          <label>\n            <input\n              type=\"radio\"\n              name=\"gender\"\n              value=\"male\"\n              checked={formData.gender === 'male'}\n              onChange={handleChange}\n            />\n            Male\n          </label>\n          <label>\n            <input\n              type=\"radio\"\n              name=\"gender\"\n              value=\"female\"\n              checked={formData.gender === 'female'}\n              onChange={handleChange}\n            />\n            Female\n          </label>\n        </div>\n      </div>\n      \n      <div>\n        <label>Country:</label>\n        <select\n          name=\"country\"\n          value={formData.country}\n          onChange={handleChange}\n        >\n          <option value=\"IN\">India</option>\n          <option value=\"US\">USA</option>\n          <option value=\"UK\">UK</option>\n        </select>\n      </div>\n      \n      <div>\n        <label>Bio:</label>\n        <textarea\n          name=\"bio\"\n          value={formData.bio}\n          onChange={handleChange}\n          rows=\"4\"\n        />\n      </div>\n      \n      <div>\n        <label>\n          <input\n            type=\"checkbox\"\n            name=\"acceptTerms\"\n            checked={formData.acceptTerms}\n            onChange={handleChange}\n          />\n          I accept the terms and conditions\n        </label>\n        {errors.acceptTerms && <span className=\"error\">{errors.acceptTerms}</span>}\n      </div>\n      \n      <button type=\"submit\" disabled={!formData.acceptTerms}>\n        Register\n      </button>\n    </form>\n  );\n}",
                        "components": [
                            {
                                "name": "Controlled Input",
                                "english": "Input value bound to React state",
                                "hinglish": "Input value React state se bound hai",
                                "importance": "Single source of truth",
                                "tip": "Always use value + onChange together"
                            },
                            {
                                "name": "Form Validation",
                                "english": "Check user input before submission",
                                "hinglish": "Submission se pehle user input check karo",
                                "importance": "Data quality and user experience",
                                "tip": "Validate on change and submit"
                            },
                            {
                                "name": "Form Submission",
                                "english": "Handle form submission with validation",
                                "hinglish": "Validation ke saath form submission handle karo",
                                "importance": "Process user data",
                                "tip": "Always prevent default behavior"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Input Type",
                                "Value Prop",
                                "Change Handler"
                            ],
                            "rows": [
                                [
                                    "Text Input",
                                    "value",
                                    "onChange"
                                ],
                                [
                                    "Textarea",
                                    "value",
                                    "onChange"
                                ],
                                [
                                    "Select",
                                    "value",
                                    "onChange"
                                ],
                                [
                                    "Checkbox",
                                    "checked",
                                    "onChange"
                                ],
                                [
                                    "Radio",
                                    "checked",
                                    "onChange"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Use single state object for forms",
                                "reason": "Easier management and submission",
                                "hinglish": "Forms manage karna easy ho jata hai"
                            },
                            {
                                "practice": "Implement real-time validation",
                                "reason": "Better user feedback",
                                "hinglish": "User ko better feedback milta hai"
                            },
                            {
                                "practice": "Disable submit button when invalid",
                                "reason": "Prevent invalid submissions",
                                "hinglish": "Invalid submissions se bachao"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Forgetting preventDefault()",
                                "solution": "Always call e.preventDefault() in form submit",
                                "hinglish": "Form submit mein hamesha e.preventDefault() call karo"
                            },
                            {
                                "mistake": "Using null or undefined as value",
                                "solution": "Always use empty string as default",
                                "hinglish": "Default value ke liye empty string use karo"
                            }
                        ]
                    }
                },
                {
                    "id": 8,
                    "title": "Basic Form Validation",
                    "english": "Validate form inputs before submission to ensure data quality.",
                    "hinglish": "Form inputs ko submission se pehle validate karo taaki data quality maintain rahe.",
                    "examples": [
                        "if (!email.includes('@')) setError('Invalid email');",
                        "const isValid = password.length >= 6 && /[A-Z]/.test(password);"
                    ],
                    "practice": [
                        {
                            "question": "When should you validate forms?",
                            "answer": "On submit and ideally on each change (real-time)"
                        },
                        {
                            "question": "What's the difference between client and server validation?",
                            "answer": "Client: UX enhancement; Server: Security and data integrity"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "function ValidatedForm() {\n  const [formData, setFormData] = useState({\n    email: '',\n    password: '',\n    confirmPassword: '',\n    age: '',\n    website: ''\n  });\n  \n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n  \n  // Validation rules\n  const validateField = (name, value) => {\n    switch (name) {\n      case 'email':\n        if (!value) return 'Email is required';\n        if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value)) \n          return 'Invalid email format';\n        return '';\n        \n      case 'password':\n        if (!value) return 'Password is required';\n        if (value.length < 6) return 'Must be at least 6 characters';\n        if (!/[A-Z]/.test(value)) return 'Must contain uppercase letter';\n        if (!/[0-9]/.test(value)) return 'Must contain number';\n        return '';\n        \n      case 'confirmPassword':\n        if (value !== formData.password) return 'Passwords do not match';\n        return '';\n        \n      case 'age':\n        if (!value) return 'Age is required';\n        const ageNum = parseInt(value);\n        if (isNaN(ageNum)) return 'Must be a number';\n        if (ageNum < 18) return 'Must be 18 or older';\n        if (ageNum > 120) return 'Enter valid age';\n        return '';\n        \n      case 'website':\n        if (value && !/^https?:\\/\\//.test(value)) \n          return 'Must start with http:// or https://';\n        return '';\n        \n      default:\n        return '';\n    }\n  };\n  \n  // Handle input change with validation\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setFormData(prev => ({ ...prev, [name]: value }));\n    \n    // Validate if field was touched\n    if (touched[name]) {\n      const error = validateField(name, value);\n      setErrors(prev => ({ ...prev, [name]: error }));\n    }\n  };\n  \n  // Mark field as touched\n  const handleBlur = (e) => {\n    const { name } = e.target;\n    setTouched(prev => ({ ...prev, [name]: true }));\n    \n    // Validate on blur\n    const error = validateField(name, formData[name]);\n    setErrors(prev => ({ ...prev, [name]: error }));\n  };\n  \n  // Validate entire form\n  const validateForm = () => {\n    const newErrors = {};\n    const newTouched = {};\n    let isValid = true;\n    \n    Object.keys(formData).forEach(key => {\n      newTouched[key] = true;\n      const error = validateField(key, formData[key]);\n      newErrors[key] = error;\n      if (error) isValid = false;\n    });\n    \n    setTouched(newTouched);\n    setErrors(newErrors);\n    return isValid;\n  };\n  \n  // Submit handler\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    \n    if (!validateForm()) {\n      alert('Please fix errors before submitting');\n      return;\n    }\n    \n    console.log('Form is valid:', formData);\n    alert('Form submitted successfully!');\n  };\n  \n  // Check if form is valid\n  const isFormValid = () => {\n    return Object.values(errors).every(error => !error) &&\n           Object.values(formData).every(value => value.trim() !== '');\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>Email:</label>\n        <input\n          type=\"email\"\n          name=\"email\"\n          value={formData.email}\n          onChange={handleChange}\n          onBlur={handleBlur}\n          className={errors.email && touched.email ? 'error' : ''}\n        />\n        {errors.email && touched.email && (\n          <span className=\"error-message\">{errors.email}</span>\n        )}\n      </div>\n      \n      <div>\n        <label>Password:</label>\n        <input\n          type=\"password\"\n          name=\"password\"\n          value={formData.password}\n          onChange={handleChange}\n          onBlur={handleBlur}\n          className={errors.password && touched.password ? 'error' : ''}\n        />\n        {errors.password && touched.password && (\n          <span className=\"error-message\">{errors.password}</span>\n        )}\n      </div>\n      \n      <div>\n        <label>Confirm Password:</label>\n        <input\n          type=\"password\"\n          name=\"confirmPassword\"\n          value={formData.confirmPassword}\n          onChange={handleChange}\n          onBlur={handleBlur}\n          className={errors.confirmPassword && touched.confirmPassword ? 'error' : ''}\n        />\n        {errors.confirmPassword && touched.confirmPassword && (\n          <span className=\"error-message\">{errors.confirmPassword}</span>\n        )}\n      </div>\n      \n      <div>\n        <label>Age:</label>\n        <input\n          type=\"number\"\n          name=\"age\"\n          value={formData.age}\n          onChange={handleChange}\n          onBlur={handleBlur}\n          className={errors.age && touched.age ? 'error' : ''}\n        />\n        {errors.age && touched.age && (\n          <span className=\"error-message\">{errors.age}</span>\n        )}\n      </div>\n      \n      <div>\n        <label>Website (optional):</label>\n        <input\n          type=\"text\"\n          name=\"website\"\n          value={formData.website}\n          onChange={handleChange}\n          onBlur={handleBlur}\n          placeholder=\"https://example.com\"\n          className={errors.website && touched.website ? 'error' : ''}\n        />\n        {errors.website && touched.website && (\n          <span className=\"error-message\">{errors.website}</span>\n        )}\n      </div>\n      \n      <button \n        type=\"submit\" \n        disabled={!isFormValid()}\n        className={!isFormValid() ? 'disabled' : ''}\n      >\n        Submit\n      </button>\n      \n      {/* Validation summary */}\n      {Object.keys(errors).some(key => errors[key] && touched[key]) && (\n        <div className=\"validation-summary\">\n          <h4>Please fix the following errors:</h4>\n          <ul>\n            {Object.entries(errors)\n              .filter(([key, error]) => error && touched[key])\n              .map(([key, error]) => (\n                <li key={key}>{error}</li>\n              ))}\n          </ul>\n        </div>\n      )}\n    </form>\n  );\n}",
                        "components": [
                            {
                                "name": "Real-time Validation",
                                "english": "Validate as user types",
                                "hinglish": "User ke type karte hi validate karo",
                                "importance": "Immediate feedback, better UX",
                                "tip": "Use onChange for real-time validation"
                            },
                            {
                                "name": "On-blur Validation",
                                "english": "Validate when user leaves field",
                                "hinglish": "User field chodte hi validate karo",
                                "importance": "Prevents distracting validation",
                                "tip": "Use onBlur for this"
                            },
                            {
                                "name": "Form-level Validation",
                                "english": "Validate all fields on submit",
                                "hinglish": "Submit par saare fields validate karo",
                                "importance": "Final check before submission",
                                "tip": "Combine with field-level validation"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Validation Type",
                                "When",
                                "Implementation"
                            ],
                            "rows": [
                                [
                                    "Real-time",
                                    "On change",
                                    "onChange + validation"
                                ],
                                [
                                    "On-blur",
                                    "Field exit",
                                    "onBlur + validation"
                                ],
                                [
                                    "On-submit",
                                    "Form submit",
                                    "handleSubmit + validation"
                                ],
                                [
                                    "Server-side",
                                    "After submit",
                                    "API response handling"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Show errors near the field",
                                "reason": "Clear association between error and input",
                                "hinglish": "Error aur input ke beech clear association"
                            },
                            {
                                "practice": "Don't validate empty fields immediately",
                                "reason": "Better user experience",
                                "hinglish": "Better user experience ke liye"
                            },
                            {
                                "practice": "Use both client and server validation",
                                "reason": "Security and user experience",
                                "hinglish": "Security aur user experience dono ke liye"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Too aggressive validation",
                                "solution": "Wait for user to finish typing",
                                "hinglish": "User ke type khatam hone ka wait karo"
                            },
                            {
                                "mistake": "Not clearing errors on correction",
                                "solution": "Clear errors when user starts typing again",
                                "hinglish": "User dubara type kare to errors clear karo"
                            }
                        ]
                    }
                },
                {
                    "id": 9,
                    "title": "Styling in React: CSS Modules and CSS-in-JS",
                    "english": "Different approaches to style React components including CSS Modules and CSS-in-JS libraries.",
                    "hinglish": "React components ko style karne ke different approaches - CSS Modules aur CSS-in-JS libraries.",
                    "examples": [
                        "import styles from './Button.module.css';",
                        "const StyledButton = styled.button`\n  background: blue;\n  color: white;\n`;"
                    ],
                    "practice": [
                        {
                            "question": "What are CSS Modules?",
                            "answer": "Locally scoped CSS files imported as objects"
                        },
                        {
                            "question": "What is CSS-in-JS?",
                            "answer": "Writing CSS directly in JavaScript files"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// CSS Modules Example - Button.module.css\n/* .button {\n  padding: 12px 24px;\n  border: none;\n  border-radius: 4px;\n  font-size: 16px;\n  cursor: pointer;\n  transition: background-color 0.3s;\n}\n\n.primary {\n  background-color: #007bff;\n  color: white;\n}\n\n.primary:hover {\n  background-color: #0056b3;\n}\n\n.secondary {\n  background-color: #6c757d;\n  color: white;\n}\n\n.large {\n  padding: 16px 32px;\n  font-size: 18px;\n}\n\n.disabled {\n  opacity: 0.6;\n  cursor: not-allowed;\n} */\n\n// CSS Modules Component\nimport styles from './Button.module.css';\n\nfunction Button({ variant = 'primary', size, disabled, children, onClick }) {\n  const buttonClasses = [\n    styles.button,\n    styles[variant],\n    size && styles[size],\n    disabled && styles.disabled\n  ].filter(Boolean).join(' ');\n\n  return (\n    <button \n      className={buttonClasses}\n      disabled={disabled}\n      onClick={onClick}\n    >\n      {children}\n    </button>\n  );\n}\n\n// CSS-in-JS Example with styled-components\nimport styled from 'styled-components';\n\nconst StyledContainer = styled.div`\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 20px;\n  background-color: ${props => props.theme.background};\n  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n  \n  @media (max-width: 768px) {\n    padding: 10px;\n  }\n`;\n\nconst Card = styled.div`\n  background: white;\n  border-radius: 8px;\n  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n  padding: 20px;\n  margin-bottom: 20px;\n  transition: transform 0.2s;\n  \n  &:hover {\n    transform: translateY(-2px);\n  }\n  \n  ${props => props.highlighted && `\n    border-left: 4px solid #007bff;\n  `}\n`;\n\nconst DynamicButton = styled.button`\n  background-color: ${props => props.primary ? '#007bff' : '#6c757d'};\n  color: white;\n  padding: ${props => props.large ? '16px 32px' : '12px 24px'};\n  border: none;\n  border-radius: 4px;\n  font-size: ${props => props.large ? '18px' : '16px'};\n  cursor: pointer;\n  transition: all 0.3s;\n  \n  &:hover {\n    background-color: ${props => props.primary ? '#0056b3' : '#545b62'};\n  }\n  \n  &:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n  }\n`;\n\n// Usage\nfunction App() {\n  return (\n    <StyledContainer>\n      <Card>\n        <h2>CSS Modules Example</h2>\n        <Button variant=\"primary\" size=\"large\">\n          Primary Button\n        </Button>\n        <Button variant=\"secondary\" disabled>\n          Disabled Button\n        </Button>\n      </Card>\n      \n      <Card highlighted>\n        <h2>CSS-in-JS Example</h2>\n        <DynamicButton primary large>\n          Primary Large Button\n        </DynamicButton>\n        <DynamicButton>\n          Secondary Button\n        </DynamicButton>\n      </Card>\n    </StyledContainer>\n  );\n}\n\n// Inline Styles Example\nfunction InlineStyleComponent() {\n  const containerStyle = {\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center',\n    minHeight: '100vh',\n    backgroundColor: '#f5f5f5',\n    padding: '20px'\n  };\n\n  const dynamicStyle = (isActive) => ({\n    padding: '10px 20px',\n    margin: '10px',\n    backgroundColor: isActive ? '#007bff' : '#e0e0e0',\n    color: isActive ? 'white' : '#333',\n    border: 'none',\n    borderRadius: '4px',\n    cursor: 'pointer',\n    transition: 'background-color 0.3s'\n  });\n\n  const [active, setActive] = useState(false);\n\n  return (\n    <div style={containerStyle}>\n      <button \n        style={dynamicStyle(active)}\n        onClick={() => setActive(!active)}\n      >\n        {active ? 'Active' : 'Inactive'}\n      </button>\n    </div>\n  );\n}",
                        "components": [
                            {
                                "name": "CSS Modules",
                                "english": "Locally scoped CSS files",
                                "hinglish": "Locally scoped CSS files",
                                "importance": "Avoids CSS conflicts",
                                "tip": "Automatically generates unique class names"
                            },
                            {
                                "name": "CSS-in-JS",
                                "english": "CSS written in JavaScript",
                                "hinglish": "JavaScript mein likha hua CSS",
                                "importance": "Dynamic styles and theming",
                                "tip": "Use styled-components or Emotion"
                            },
                            {
                                "name": "Inline Styles",
                                "english": "Style objects in JavaScript",
                                "hinglish": "JavaScript mein style objects",
                                "importance": "Dynamic styling without CSS",
                                "tip": "Good for highly dynamic styles"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Method",
                                "Pros",
                                "Cons"
                            ],
                            "rows": [
                                [
                                    "CSS Modules",
                                    "Scoped styles, familiar CSS",
                                    "No dynamic styling"
                                ],
                                [
                                    "CSS-in-JS",
                                    "Dynamic styles, theming",
                                    "Bundle size, learning curve"
                                ],
                                [
                                    "Inline Styles",
                                    "Fully dynamic, simple",
                                    "No pseudo-classes, media queries"
                                ],
                                [
                                    "Regular CSS",
                                    "Simple, powerful",
                                    "Global scope, conflicts"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Choose based on project needs",
                                "reason": "Different approaches suit different projects",
                                "hinglish": "Different projects ke liye different approaches"
                            },
                            {
                                "practice": "Use CSS Modules for component libraries",
                                "reason": "Predictable, scoped styles",
                                "hinglish": "Predictable, scoped styles ke liye"
                            },
                            {
                                "practice": "Use CSS-in-JS for theming",
                                "reason": "Excellent for dynamic themes",
                                "hinglish": "Dynamic themes ke liye best hai"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Overusing inline styles",
                                "solution": "Use for truly dynamic styles only",
                                "hinglish": "Sirf truly dynamic styles ke liye use karo"
                            },
                            {
                                "mistake": "Mixing multiple approaches",
                                "solution": "Stick to one approach per project",
                                "hinglish": "Ek project mein ek hi approach use karo"
                            }
                        ]
                    }
                },
                {
                    "id": 10,
                    "title": "React Router Basics",
                    "english": "React Router enables navigation and routing in React applications.",
                    "hinglish": "React Router React applications mein navigation aur routing enable karta hai.",
                    "examples": [
                        "<Route path=\"/about\" element={<About />} />",
                        "<Link to=\"/home\">Home</Link>"
                    ],
                    "practice": [
                        {
                            "question": "What is React Router used for?",
                            "answer": "Client-side routing in React applications"
                        },
                        {
                            "question": "Difference between Link and anchor tag?",
                            "answer": "Link prevents page reload, anchor tag reloads page"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "import { BrowserRouter, Routes, Route, Link, NavLink, useParams, useNavigate } from 'react-router-dom';\n\n// Main App component with routing\nfunction App() {\n  return (\n    <BrowserRouter>\n      <div className=\"app\">\n        <Navigation />\n        \n        <main>\n          <Routes>\n            <Route path=\"/\" element={<Home />} />\n            <Route path=\"/about\" element={<About />} />\n            <Route path=\"/users\" element={<Users />} />\n            <Route path=\"/users/:userId\" element={<UserDetail />} />\n            <Route path=\"/products\" element={<Products />}>\n              <Route path=\":productId\" element={<ProductDetail />} />\n              <Route path=\"category/:categoryId\" element={<ProductCategory />} />\n            </Route>\n            <Route path=\"/contact\" element={<Contact />} />\n            <Route path=\"*\" element={<NotFound />} />\n          </Routes>\n        </main>\n        \n        <Footer />\n      </div>\n    </BrowserRouter>\n  );\n}\n\n// Navigation component\nfunction Navigation() {\n  return (\n    <nav className=\"navigation\">\n      <ul>\n        <li>\n          <Link to=\"/\">Home</Link>\n        </li>\n        <li>\n          <NavLink \n            to=\"/about\"\n            className={({ isActive }) => isActive ? 'active-link' : ''}\n          >\n            About\n          </NavLink>\n        </li>\n        <li>\n          <NavLink to=\"/users\">Users</NavLink>\n        </li>\n        <li>\n          <NavLink to=\"/products\">Products</NavLink>\n        </li>\n        <li>\n          <NavLink to=\"/contact\">Contact</NavLink>\n        </li>\n      </ul>\n    </nav>\n  );\n}\n\n// Home component\nfunction Home() {\n  return (\n    <div className=\"home\">\n      <h1>Welcome to our App</h1>\n      <p>This is the home page.</p>\n      <Link to=\"/products\">View Products</Link>\n    </div>\n  );\n}\n\n// Users component\nfunction Users() {\n  const users = [\n    { id: 1, name: 'John Doe', email: 'john@example.com' },\n    { id: 2, name: 'Jane Smith', email: 'jane@example.com' },\n    { id: 3, name: 'Bob Johnson', email: 'bob@example.com' }\n  ];\n\n  return (\n    <div className=\"users\">\n      <h1>Users List</h1>\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>\n            <Link to={`/users/${user.id}`}>\n              {user.name}\n            </Link>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// User Detail component with parameters\nfunction UserDetail() {\n  const { userId } = useParams();\n  const navigate = useNavigate();\n  \n  // Mock user data\n  const users = {\n    1: { name: 'John Doe', email: 'john@example.com', age: 28 },\n    2: { name: 'Jane Smith', email: 'jane@example.com', age: 32 },\n    3: { name: 'Bob Johnson', email: 'bob@example.com', age: 45 }\n  };\n  \n  const user = users[userId];\n  \n  if (!user) {\n    return (\n      <div>\n        <h2>User not found</h2>\n        <button onClick={() => navigate('/users')}>Back to Users</button>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"user-detail\">\n      <button onClick={() => navigate(-1)}>Go Back</button>\n      <h2>User Details</h2>\n      <p><strong>ID:</strong> {userId}</p>\n      <p><strong>Name:</strong> {user.name}</p>\n      <p><strong>Email:</strong> {user.email}</p>\n      <p><strong>Age:</strong> {user.age}</p>\n      \n      <div>\n        <button onClick={() => navigate(`/users/${parseInt(userId) + 1}`)}>\n          Next User\n        </button>\n        <button onClick={() => navigate('/users')}>\n          Back to List\n        </button>\n      </div>\n    </div>\n  );\n}\n\n// Products component with nested routes\nfunction Products() {\n  return (\n    <div className=\"products\">\n      <h1>Products</h1>\n      <nav>\n        <Link to=\"1\">Product 1</Link>\n        <Link to=\"2\">Product 2</Link>\n        <Link to=\"category/electronics\">Electronics</Link>\n        <Link to=\"category/clothing\">Clothing</Link>\n      </nav>\n      \n      {/* This is where nested routes will render */}\n      <Routes>\n        <Route path=\":productId\" element={<ProductDetail />} />\n        <Route path=\"category/:categoryId\" element={<ProductCategory />} />\n      </Routes>\n    </div>\n  );\n}\n\n// Product Detail component\nfunction ProductDetail() {\n  const { productId } = useParams();\n  \n  return (\n    <div className=\"product-detail\">\n      <h2>Product {productId}</h2>\n      <p>Details for product {productId}</p>\n    </div>\n  );\n}\n\n// Product Category component\nfunction ProductCategory() {\n  const { categoryId } = useParams();\n  \n  return (\n    <div className=\"product-category\">\n      <h2>{categoryId.charAt(0).toUpperCase() + categoryId.slice(1)}</h2>\n      <p>Products in {categoryId} category</p>\n    </div>\n  );\n}\n\n// Contact component\nfunction Contact() {\n  const navigate = useNavigate();\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    // Form submission logic\n    alert('Message sent!');\n    navigate('/'); // Redirect to home after submission\n  };\n  \n  return (\n    <div className=\"contact\">\n      <h1>Contact Us</h1>\n      <form onSubmit={handleSubmit}>\n        <input type=\"text\" placeholder=\"Your Name\" required />\n        <input type=\"email\" placeholder=\"Your Email\" required />\n        <textarea placeholder=\"Your Message\" rows=\"4\" required></textarea>\n        <button type=\"submit\">Send Message</button>\n      </form>\n    </div>\n  );\n}\n\n// 404 Not Found component\nfunction NotFound() {\n  return (\n    <div className=\"not-found\">\n      <h1>404 - Page Not Found</h1>\n      <p>The page you're looking for doesn't exist.</p>\n      <Link to=\"/\">Go to Home</Link>\n    </div>\n  );\n}\n\n// Footer component\nfunction Footer() {\n  return (\n    <footer className=\"footer\">\n      <p>&copy; 2024 My App. All rights reserved.</p>\n      <Link to=\"/privacy\">Privacy Policy</Link>\n    </footer>\n  );\n}",
                        "components": [
                            {
                                "name": "BrowserRouter",
                                "english": "Wrapper component for routing",
                                "hinglish": "Routing ke liye wrapper component",
                                "importance": "Enables client-side routing",
                                "tip": "Wrap your entire app with this"
                            },
                            {
                                "name": "Routes and Route",
                                "english": "Define application routes",
                                "hinglish": "Application routes define karo",
                                "importance": "Maps URLs to components",
                                "tip": "Route elements define what component to render"
                            },
                            {
                                "name": "Link and NavLink",
                                "english": "Navigation links without page reload",
                                "hinglish": "Page reload ke bina navigation links",
                                "importance": "Smooth client-side navigation",
                                "tip": "NavLink adds active class automatically"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Component",
                                "Purpose",
                                "When to Use"
                            ],
                            "rows": [
                                [
                                    "Link",
                                    "Basic navigation",
                                    "Simple links between pages"
                                ],
                                [
                                    "NavLink",
                                    "Navigation with active state",
                                    "Navigation menus"
                                ],
                                [
                                    "Navigate",
                                    "Programmatic redirect",
                                    "After login/logout"
                                ],
                                [
                                    "useNavigate",
                                    "Navigation in code",
                                    "Form submission, buttons"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Use nested routes for related pages",
                                "reason": "Better organization and shared layout",
                                "hinglish": "Better organization aur shared layout ke liye"
                            },
                            {
                                "practice": "Add a catch-all 404 route",
                                "reason": "Better UX for invalid URLs",
                                "hinglish": "Invalid URLs ke liye better UX"
                            },
                            {
                                "practice": "Use NavLink for navigation menus",
                                "reason": "Automatic active state styling",
                                "hinglish": "Automatic active state styling ke liye"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Forgetting BrowserRouter wrapper",
                                "solution": "Wrap entire app with BrowserRouter",
                                "hinglish": "Pure app ko BrowserRouter se wrap karo"
                            },
                            {
                                "mistake": "Using anchor tags instead of Link",
                                "solution": "Always use Link for internal navigation",
                                "hinglish": "Internal navigation ke liye hamesha Link use karo"
                            }
                        ]
                    }
                }
            ]
        },
        {
            "level": "intermediate",
            "order": 2,
            "topics": [
                {
                    "id": 11,
                    "title": "useEffect Hook for Side Effects",
                    "english": "useEffect hook handles side effects in functional components like data fetching, subscriptions, or DOM manipulation.",
                    "hinglish": "useEffect hook functional components mein side effects handle karta hai jaise data fetching, subscriptions, ya DOM manipulation.",
                    "examples": [
                        "useEffect(() => {\n  document.title = `You clicked ${count} times`;\n}, [count]);",
                        "useEffect(() => {\n  const subscription = API.subscribe();\n  return () => subscription.unsubscribe();\n}, []);"
                    ],
                    "practice": [
                        {
                            "question": "What is the purpose of useEffect?",
                            "answer": "To perform side effects in functional components"
                        },
                        {
                            "question": "When does useEffect run?",
                            "answer": "After render, and re-runs when dependencies change"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "function UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  // Effect for fetching user data\n  useEffect(() => {\n    let isMounted = true;\n    \n    const fetchUser = async () => {\n      if (!userId) return;\n      \n      setLoading(true);\n      setError(null);\n      \n      try {\n        const response = await fetch(`/api/users/${userId}`);\n        const data = await response.json();\n        \n        if (isMounted) {\n          setUser(data);\n        }\n      } catch (err) {\n        if (isMounted) {\n          setError(err.message);\n        }\n      } finally {\n        if (isMounted) {\n          setLoading(false);\n        }\n      }\n    };\n    \n    fetchUser();\n    \n    // Cleanup function\n    return () => {\n      isMounted = false;\n      console.log('Cleanup for user:', userId);\n    };\n  }, [userId]); // Re-run when userId changes\n  \n  // Effect for document title\n  useEffect(() => {\n    if (user) {\n      document.title = `Profile: ${user.name}`;\n    } else {\n      document.title = 'User Profile';\n    }\n    \n    // Cleanup for title\n    return () => {\n      document.title = 'React App';\n    };\n  }, [user]);\n  \n  // Effect for event listeners\n  useEffect(() => {\n    const handleResize = () => {\n      console.log('Window resized:', window.innerWidth);\n    };\n    \n    window.addEventListener('resize', handleResize);\n    \n    // Cleanup event listener\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []); // Empty array means run once on mount\n  \n  // Effect for localStorage\n  useEffect(() => {\n    const savedTheme = localStorage.getItem('theme');\n    if (savedTheme) {\n      document.body.classList.add(savedTheme);\n    }\n  }, []);\n  \n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n  if (!user) return <div>No user selected</div>;\n  \n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>Email: {user.email}</p>\n      <p>Role: {user.role}</p>\n    </div>\n  );\n}",
                        "components": [
                            {
                                "name": "Effect Function",
                                "english": "Function containing side effect logic",
                                "hinglish": "Side effect logic wala function",
                                "importance": "Where you write side effect code",
                                "tip": "Can be async for data fetching"
                            },
                            {
                                "name": "Dependency Array",
                                "english": "Array of values that trigger effect re-run",
                                "hinglish": "Values ka array jo effect ko dubara run karaye",
                                "importance": "Controls when effect executes",
                                "tip": "Empty array [] means run only once"
                            },
                            {
                                "name": "Cleanup Function",
                                "english": "Function that cleans up side effects",
                                "hinglish": "Side effects clean karne wala function",
                                "importance": "Prevents memory leaks",
                                "tip": "Return cleanup function from effect"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Dependency Array",
                                "Behavior",
                                "Use Case"
                            ],
                            "rows": [
                                [
                                    "[]",
                                    "Run once on mount",
                                    "Event listeners, initial fetch"
                                ],
                                [
                                    "[state]",
                                    "Run when state changes",
                                    "Document title, analytics"
                                ],
                                [
                                    "[prop, state]",
                                    "Run when dependencies change",
                                    "Data fetching"
                                ],
                                [
                                    "No array",
                                    "Run after every render",
                                    "Rare, usually avoid"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Use multiple useEffect hooks",
                                "reason": "Separate concerns, easier to understand",
                                "hinglish": "Concerns alag karo, samajhna easy ho"
                            },
                            {
                                "practice": "Always cleanup subscriptions",
                                "reason": "Prevent memory leaks",
                                "hinglish": "Memory leaks se bachao"
                            },
                            {
                                "practice": "Use dependency array correctly",
                                "reason": "Avoid infinite loops and bugs",
                                "hinglish": "Infinite loops aur bugs se bachao"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Missing dependencies",
                                "solution": "Include all values used inside effect",
                                "hinglish": "Effect ke andar use kiye gaye saare values include karo"
                            },
                            {
                                "mistake": "Forgetting cleanup",
                                "solution": "Always return cleanup for subscriptions",
                                "hinglish": "Subscriptions ke liye hamesha cleanup return karo"
                            }
                        ]
                    }
                },
                {
                    "id": 12,
                    "title": "useRef Hook for DOM Access and Mutable Values",
                    "english": "useRef returns a mutable ref object that persists across renders, useful for accessing DOM elements or storing mutable values.",
                    "hinglish": "useRef ek mutable ref object return karta hai jo renders ke beech persist rehta hai, DOM elements access karne ya mutable values store karne ke liye useful hai.",
                    "examples": [
                        "const inputRef = useRef(null);\n<input ref={inputRef} />",
                        "const intervalRef = useRef();\nintervalRef.current = setInterval(...);"
                    ],
                    "practice": [
                        {
                            "question": "What are two main uses of useRef?",
                            "answer": "1. Accessing DOM elements 2. Storing mutable values that don't trigger re-renders"
                        },
                        {
                            "question": "Does changing ref.current cause re-render?",
                            "answer": "No, ref changes don't trigger component re-render"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "function RefExamples() {\n  // 1. DOM Element Reference\n  const inputRef = useRef(null);\n  const buttonRef = useRef(null);\n  const containerRef = useRef(null);\n  \n  // 2. Mutable Value Storage (doesn't cause re-render)\n  const renderCount = useRef(0);\n  const prevValueRef = useRef('');\n  const intervalRef = useRef(null);\n  \n  const [value, setValue] = useState('');\n  const [timer, setTimer] = useState(0);\n  \n  // Focus input on mount\n  useEffect(() => {\n    inputRef.current?.focus();\n    \n    // Track render count\n    renderCount.current += 1;\n    console.log(`Rendered ${renderCount.current} times`);\n  });\n  \n  // Track previous value\n  useEffect(() => {\n    prevValueRef.current = value;\n  }, [value]);\n  \n  // Handle input change\n  const handleChange = (e) => {\n    setValue(e.target.value);\n  };\n  \n  // Focus input function\n  const focusInput = () => {\n    inputRef.current?.focus();\n    inputRef.current?.select();\n  };\n  \n  // Get input dimensions\n  const logInputDimensions = () => {\n    if (inputRef.current) {\n      const { width, height } = inputRef.current.getBoundingClientRect();\n      console.log(`Input dimensions: ${width}x${height}`);\n    }\n  };\n  \n  // Timer functions\n  const startTimer = () => {\n    if (intervalRef.current) return;\n    \n    intervalRef.current = setInterval(() => {\n      setTimer(prev => prev + 1);\n    }, 1000);\n  };\n  \n  const stopTimer = () => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n  };\n  \n  // Scroll to bottom\n  const scrollToBottom = () => {\n    if (containerRef.current) {\n      containerRef.current.scrollTop = containerRef.current.scrollHeight;\n    }\n  };\n  \n  // Measure render performance\n  const expensiveCalculationRef = useRef(null);\n  \n  const performExpensiveCalc = () => {\n    if (!expensiveCalculationRef.current) {\n      console.time('expensive');\n      let result = 0;\n      for (let i = 0; i < 1000000000; i++) {\n        result += i;\n      }\n      expensiveCalculationRef.current = result;\n      console.timeEnd('expensive');\n    }\n    return expensiveCalculationRef.current;\n  };\n  \n  return (\n    <div ref={containerRef} style={{ height: '200px', overflow: 'auto' }}>\n      <h1>useRef Examples</h1>\n      \n      {/* DOM Access Example */}\n      <div>\n        <input\n          ref={inputRef}\n          type=\"text\"\n          value={value}\n          onChange={handleChange}\n          placeholder=\"Type something...\"\n        />\n        <button ref={buttonRef} onClick={focusInput}>\n          Focus Input\n        </button>\n        <button onClick={logInputDimensions}>\n          Log Dimensions\n        </button>\n      </div>\n      \n      {/* Previous Value Tracking */}\n      <div>\n        <p>Current Value: {value}</p>\n        <p>Previous Value: {prevValueRef.current}</p>\n        <p>Render Count: {renderCount.current}</p>\n      </div>\n      \n      {/* Timer Example */}\n      <div>\n        <h2>Timer: {timer}s</h2>\n        <button onClick={startTimer}>Start Timer</button>\n        <button onClick={stopTimer}>Stop Timer</button>\n      </div>\n      \n      {/* Scroll Example */}\n      <div>\n        <button onClick={scrollToBottom}>Scroll to Bottom</button>\n        <p>Some content to scroll...</p>\n        <div style={{ height: '500px', background: 'linear-gradient(#eee, #fff)' }}>\n          Scrollable content area\n        </div>\n      </div>\n      \n      {/* Expensive Calculation */}\n      <div>\n        <button onClick={performExpensiveCalc}>\n          Perform Expensive Calculation\n        </button>\n      </div>\n      \n      {/* Video/Audio Control Example */}\n      <VideoPlayerWithRef />\n    </div>\n  );\n}\n\n// Video player using ref\nfunction VideoPlayerWithRef() {\n  const videoRef = useRef(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  \n  const togglePlay = () => {\n    if (videoRef.current) {\n      if (isPlaying) {\n        videoRef.current.pause();\n      } else {\n        videoRef.current.play();\n      }\n      setIsPlaying(!isPlaying);\n    }\n  };\n  \n  const setVolume = (level) => {\n    if (videoRef.current) {\n      videoRef.current.volume = level;\n    }\n  };\n  \n  const jumpToTime = (seconds) => {\n    if (videoRef.current) {\n      videoRef.current.currentTime = seconds;\n    }\n  };\n  \n  return (\n    <div>\n      <h3>Video Player</h3>\n      <video\n        ref={videoRef}\n        width=\"400\"\n        src=\"https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"\n        onPlay={() => setIsPlaying(true)}\n        onPause={() => setIsPlaying(false)}\n      />\n      <div>\n        <button onClick={togglePlay}>\n          {isPlaying ? 'Pause' : 'Play'}\n        </button>\n        <button onClick={() => setVolume(0.5)}>Volume 50%</button>\n        <button onClick={() => setVolume(1)}>Volume 100%</button>\n        <button onClick={() => jumpToTime(30)}>Jump to 30s</button>\n        <button onClick={() => jumpToTime(60)}>Jump to 1m</button>\n      </div>\n    </div>\n  );\n}",
                        "components": [
                            {
                                "name": "DOM Element Ref",
                                "english": "Reference to DOM elements",
                                "hinglish": "DOM elements ka reference",
                                "importance": "Access DOM properties and methods",
                                "tip": "Initialize with null, assign via ref prop"
                            },
                            {
                                "name": "Mutable Value Storage",
                                "english": "Store values that persist across renders",
                                "hinglish": "Renders ke beech persist rehne wali values store karo",
                                "importance": "Values that shouldn't trigger re-renders",
                                "tip": "Use for timers, previous values, calculations"
                            },
                            {
                                "name": "Imperative Handle",
                                "english": "Expose component methods to parent",
                                "hinglish": "Component methods parent ko expose karo",
                                "importance": "Imperative DOM operations",
                                "tip": "Combine with forwardRef and useImperativeHandle"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Feature",
                                "useRef",
                                "useState"
                            ],
                            "rows": [
                                [
                                    "Re-render on change",
                                    "No",
                                    "Yes"
                                ],
                                [
                                    "Persists across renders",
                                    "Yes",
                                    "Yes"
                                ],
                                [
                                    "Access DOM elements",
                                    "Yes",
                                    "No"
                                ],
                                [
                                    "Mutable values",
                                    "Yes (current property)",
                                    "No (immutable)"
                                ],
                                [
                                    "Initialization",
                                    "useRef(initialValue)",
                                    "useState(initialValue)"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Use ref for DOM access only when needed",
                                "reason": "React prefers declarative approach",
                                "hinglish": "React declarative approach prefer karta hai"
                            },
                            {
                                "practice": "Check ref.current before using",
                                "reason": "Ref might be null during initial render",
                                "hinglish": "Initial render mein ref null ho sakta hai"
                            },
                            {
                                "practice": "Use ref for values that don't affect rendering",
                                "reason": "Better performance",
                                "hinglish": "Better performance ke liye"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Using ref for state that should trigger re-render",
                                "solution": "Use useState instead for rendering data",
                                "hinglish": "Rendering data ke liye useState use karo"
                            },
                            {
                                "mistake": "Not cleaning up ref-based subscriptions",
                                "solution": "Clear intervals/timeouts in cleanup",
                                "hinglish": "Cleanup mein intervals/timeouts clear karo"
                            }
                        ]
                    }
                },
                {
                    "id": 13,
                    "title": "useContext Hook for Global State",
                    "english": "useContext hook allows components to consume values from React Context without prop drilling.",
                    "hinglish": "useContext hook components ko React Context se values consume karne deta hai bina prop drilling ke.",
                    "examples": [
                        "const theme = useContext(ThemeContext);",
                        "const { user, login } = useContext(AuthContext);"
                    ],
                    "practice": [
                        {
                            "question": "What problem does useContext solve?",
                            "answer": "Prop drilling - passing props through multiple levels"
                        },
                        {
                            "question": "How do you create a Context?",
                            "answer": "Using React.createContext()"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// 1. Create Contexts\nimport React, { createContext, useState, useContext } from 'react';\n\n// Theme Context\nexport const ThemeContext = createContext({\n  theme: 'light',\n  toggleTheme: () => {},\n});\n\n// User Context\nexport const UserContext = createContext({\n  user: null,\n  login: () => {},\n  logout: () => {},\n});\n\n// Settings Context\nexport const SettingsContext = createContext({\n  language: 'en',\n  notifications: true,\n  updateSettings: () => {},\n});\n\n// 2. Context Providers\nfunction AppProviders({ children }) {\n  // Theme state\n  const [theme, setTheme] = useState('light');\n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n  \n  // User state\n  const [user, setUser] = useState(null);\n  const login = (userData) => {\n    setUser(userData);\n    localStorage.setItem('user', JSON.stringify(userData));\n  };\n  const logout = () => {\n    setUser(null);\n    localStorage.removeItem('user');\n  };\n  \n  // Settings state\n  const [settings, setSettings] = useState({\n    language: 'en',\n    notifications: true,\n    theme: 'auto',\n  });\n  const updateSettings = (newSettings) => {\n    setSettings(prev => ({ ...prev, ...newSettings }));\n  };\n  \n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      <UserContext.Provider value={{ user, login, logout }}>\n        <SettingsContext.Provider value={{ settings, updateSettings }}>\n          {children}\n        </SettingsContext.Provider>\n      </UserContext.Provider>\n    </ThemeContext.Provider>\n  );\n}\n\n// 3. Custom Hooks for easier consumption\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  return context;\n}\n\nfunction useUser() {\n  const context = useContext(UserContext);\n  if (!context) {\n    throw new Error('useUser must be used within UserProvider');\n  }\n  return context;\n}\n\nfunction useSettings() {\n  const context = useContext(SettingsContext);\n  if (!context) {\n    throw new Error('useSettings must be used within SettingsProvider');\n  }\n  return context;\n}\n\n// 4. Components using Context\nfunction ThemeToggle() {\n  const { theme, toggleTheme } = useTheme();\n  \n  return (\n    <button \n      onClick={toggleTheme}\n      style={{\n        backgroundColor: theme === 'dark' ? '#333' : '#fff',\n        color: theme === 'dark' ? '#fff' : '#333',\n        padding: '10px 20px',\n        border: '1px solid #ccc',\n        cursor: 'pointer',\n      }}\n    >\n      Switch to {theme === 'dark' ? 'Light' : 'Dark'} Mode\n    </button>\n  );\n}\n\nfunction UserProfile() {\n  const { user, logout } = useUser();\n  const { settings } = useSettings();\n  \n  if (!user) {\n    return <div>Please log in</div>;\n  }\n  \n  return (\n    <div className=\"user-profile\">\n      <h2>Welcome, {user.name}!</h2>\n      <p>Email: {user.email}</p>\n      <p>Language: {settings.language}</p>\n      <button onClick={logout}>Logout</button>\n    </div>\n  );\n}\n\nfunction LoginForm() {\n  const { login } = useUser();\n  const [credentials, setCredentials] = useState({ email: '', password: '' });\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    // Mock login\n    login({\n      id: 1,\n      name: 'John Doe',\n      email: credentials.email,\n      role: 'user',\n    });\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"email\"\n        placeholder=\"Email\"\n        value={credentials.email}\n        onChange={(e) => setCredentials(prev => ({ ...prev, email: e.target.value }))}\n      />\n      <input\n        type=\"password\"\n        placeholder=\"Password\"\n        value={credentials.password}\n        onChange={(e) => setCredentials(prev => ({ ...prev, password: e.target.value }))}\n      />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}\n\nfunction SettingsPanel() {\n  const { settings, updateSettings } = useSettings();\n  const { theme } = useTheme();\n  \n  const handleLanguageChange = (language) => {\n    updateSettings({ language });\n  };\n  \n  const toggleNotifications = () => {\n    updateSettings({ notifications: !settings.notifications });\n  };\n  \n  return (\n    <div className=\"settings-panel\">\n      <h3>Settings</h3>\n      <div>\n        <label>Language:</label>\n        <select \n          value={settings.language}\n          onChange={(e) => handleLanguageChange(e.target.value)}\n        >\n          <option value=\"en\">English</option>\n          <option value=\"hi\">Hindi</option>\n          <option value=\"es\">Spanish</option>\n        </select>\n      </div>\n      \n      <div>\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={settings.notifications}\n            onChange={toggleNotifications}\n          />\n          Enable Notifications\n        </label>\n      </div>\n      \n      <div>\n        <p>Current Theme: {theme}</p>\n      </div>\n    </div>\n  );\n}\n\n// 5. Main App Component\nfunction App() {\n  return (\n    <AppProviders>\n      <div className=\"app\">\n        <header>\n          <h1>Context API Example</h1>\n          <ThemeToggle />\n        </header>\n        \n        <main>\n          <section>\n            <h2>User Section</h2>\n            <UserProfile />\n            <LoginForm />\n          </section>\n          \n          <section>\n            <h2>Settings</h2>\n            <SettingsPanel />\n          </section>\n          \n          <section>\n            <h2>Deeply Nested Component</h2>\n            <Level1 />\n          </section>\n        </main>\n      </div>\n    </AppProviders>\n  );\n}\n\n// 6. Example of avoiding prop drilling\nfunction Level1() {\n  return (\n    <div>\n      <p>Level 1</p>\n      <Level2 />\n    </div>\n  );\n}\n\nfunction Level2() {\n  return (\n    <div>\n      <p>Level 2</p>\n      <Level3 />\n    </div>\n  );\n}\n\nfunction Level3() {\n  // Direct access without passing props through Level1 and Level2\n  const { user } = useUser();\n  const { theme } = useTheme();\n  \n  return (\n    <div style={{\n      padding: '20px',\n      backgroundColor: theme === 'dark' ? '#222' : '#f0f0f0',\n      color: theme === 'dark' ? '#fff' : '#000',\n    }}>\n      <p>Level 3 - Deeply nested!</p>\n      <p>User from context: {user ? user.name : 'Not logged in'}</p>\n      <p>Theme from context: {theme}</p>\n    </div>\n  );\n}\n\n// 7. Performance Optimization with Context\nconst ExpensiveComponent = React.memo(function ExpensiveComponent() {\n  const { settings } = useSettings();\n  \n  console.log('ExpensiveComponent rendered');\n  \n  // Heavy computation\n  const heavyComputation = () => {\n    let sum = 0;\n    for (let i = 0; i < 1000000; i++) {\n      sum += i;\n    }\n    return sum;\n  };\n  \n  return (\n    <div>\n      <p>Language: {settings.language}</p>\n      <p>Computed: {heavyComputation()}</p>\n    </div>\n  );\n});",
                        "components": [
                            {
                                "name": "createContext",
                                "english": "Creates a Context object",
                                "hinglish": "Context object create karta hai",
                                "importance": "Foundation for Context API",
                                "tip": "Provide default values for better TypeScript support"
                            },
                            {
                                "name": "Context.Provider",
                                "english": "Provides context values to children",
                                "hinglish": "Context values children ko provide karta hai",
                                "importance": "Makes context available to subtree",
                                "tip": "Wrap your app or relevant parts with Provider"
                            },
                            {
                                "name": "useContext Hook",
                                "english": "Consumes values from Context",
                                "hinglish": "Context se values consume karta hai",
                                "importance": "Access context values in components",
                                "tip": "Create custom hooks for better abstraction"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Solution",
                                "When to Use",
                                "Pros",
                                "Cons"
                            ],
                            "rows": [
                                [
                                    "Context API",
                                    "Theme, auth, global settings",
                                    "Built-in, simple",
                                    "Performance concerns"
                                ],
                                [
                                    "Prop Drilling",
                                    "2-3 levels deep",
                                    "Explicit, simple",
                                    "Gets messy quickly"
                                ],
                                [
                                    "Component Composition",
                                    "Reusable layouts",
                                    "Flexible, explicit",
                                    "Can be verbose"
                                ],
                                [
                                    "State Management Lib",
                                    "Complex global state",
                                    "Performance, tools",
                                    "Learning curve"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Split contexts by domain",
                                "reason": "Better performance and organization",
                                "hinglish": "Better performance aur organization ke liye"
                            },
                            {
                                "practice": "Create custom context hooks",
                                "reason": "Better error handling and abstraction",
                                "hinglish": "Better error handling aur abstraction ke liye"
                            },
                            {
                                "practice": "Memoize context values",
                                "reason": "Prevent unnecessary re-renders",
                                "hinglish": "Unnecessary re-renders se bachao"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Putting everything in one context",
                                "solution": "Split into multiple smaller contexts",
                                "hinglish": "Multiple smaller contexts mein split karo"
                            },
                            {
                                "mistake": "Forgetting Provider wrapper",
                                "solution": "Ensure component is inside Provider",
                                "hinglish": "Component Provider ke andar hai iska dhyan rakh"
                            }
                        ]
                    }
                },
                {
                    "id": 14,
                    "title": "Higher-Order Components (HOCs)",
                    "english": "HOCs are functions that take a component and return a new enhanced component with additional props or functionality.",
                    "hinglish": "HOCs wo functions hain jo ek component lete hain aur ek naya enhanced component return karte hain jisme additional props ya functionality hoti hai.",
                    "examples": [
                        "const EnhancedComponent = withAuth(UserComponent);",
                        "const WithLoading = (Component) => (props) => {\n  if (props.loading) return <Spinner />;\n  return <Component {...props} />;\n};"
                    ],
                    "practice": [
                        {
                            "question": "What is a Higher-Order Component?",
                            "answer": "A function that takes a component and returns a new enhanced component"
                        },
                        {
                            "question": "When should you use HOCs?",
                            "answer": "For cross-cutting concerns like authentication, logging, or data fetching"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// 1. Basic HOC Structure\nfunction withExtraProp(WrappedComponent) {\n  // Return a new component\n  return function EnhancedComponent(props) {\n    // Add extra props\n    const extraProps = {\n      extraData: 'This comes from HOC',\n      timestamp: new Date().toISOString(),\n    };\n    \n    // Render wrapped component with enhanced props\n    return <WrappedComponent {...props} {...extraProps} />;\n  };\n}\n\n// 2. Authentication HOC\nfunction withAuth(WrappedComponent) {\n  return function AuthenticatedComponent(props) {\n    const [isAuthenticated, setIsAuthenticated] = useState(false);\n    const [user, setUser] = useState(null);\n    const [loading, setLoading] = useState(true);\n    \n    useEffect(() => {\n      // Check authentication\n      const token = localStorage.getItem('token');\n      if (token) {\n        // Verify token (mock)\n        setUser({ id: 1, name: 'John Doe', role: 'admin' });\n        setIsAuthenticated(true);\n      }\n      setLoading(false);\n    }, []);\n    \n    const login = (credentials) => {\n      // Mock login\n      localStorage.setItem('token', 'fake-token');\n      setUser({ id: 1, name: 'John Doe', role: 'admin' });\n      setIsAuthenticated(true);\n    };\n    \n    const logout = () => {\n      localStorage.removeItem('token');\n      setUser(null);\n      setIsAuthenticated(false);\n    };\n    \n    if (loading) {\n      return <div>Loading authentication...</div>;\n    }\n    \n    if (!isAuthenticated) {\n      return (\n        <div>\n          <h3>Please login to continue</h3>\n          <button onClick={() => login({})}>Mock Login</button>\n        </div>\n      );\n    }\n    \n    // Pass auth props to wrapped component\n    return (\n      <WrappedComponent\n        {...props}\n        user={user}\n        isAuthenticated={isAuthenticated}\n        login={login}\n        logout={logout}\n      />\n    );\n  };\n}\n\n// 3. Loading HOC\nfunction withLoading(WrappedComponent) {\n  return function LoadingComponent({ loading, ...props }) {\n    if (loading) {\n      return (\n        <div className=\"loading-container\">\n          <div className=\"spinner\"></div>\n          <p>Loading data...</p>\n        </div>\n      );\n    }\n    \n    return <WrappedComponent {...props} />;\n  };\n}\n\n// 4. Error Boundary HOC\nfunction withErrorBoundary(WrappedComponent, errorComponent) {\n  return class ErrorBoundaryHOC extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = { hasError: false, error: null };\n    }\n    \n    static getDerivedStateFromError(error) {\n      return { hasError: true, error };\n    }\n    \n    componentDidCatch(error, errorInfo) {\n      console.error('Error caught by HOC:', error, errorInfo);\n      // Log to error reporting service\n    }\n    \n    render() {\n      if (this.state.hasError) {\n        return errorComponent ? errorComponent(this.state.error) : (\n          <div className=\"error-boundary\">\n            <h3>Something went wrong</h3>\n            <p>{this.state.error?.message}</p>\n            <button onClick={() => this.setState({ hasError: false })}>\n              Try Again\n            </button>\n          </div>\n        );\n      }\n      \n      return <WrappedComponent {...this.props} />;\n    }\n  };\n}\n\n// 5. Logging HOC\nfunction withLogger(WrappedComponent, componentName) {\n  return class LoggingComponent extends React.Component {\n    componentDidMount() {\n      console.log(`Component ${componentName || WrappedComponent.name} mounted`);\n    }\n    \n    componentDidUpdate(prevProps) {\n      console.log(`Component ${componentName || WrappedComponent.name} updated`, {\n        prevProps,\n        nextProps: this.props\n      });\n    }\n    \n    componentWillUnmount() {\n      console.log(`Component ${componentName || WrappedComponent.name} unmounted`);\n    }\n    \n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  };\n}\n\n// 6. Data Fetching HOC\nfunction withDataFetching(WrappedComponent, fetchFunction, dataKey = 'data') {\n  return function DataFetchingComponent(props) {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n    \n    useEffect(() => {\n      const fetchData = async () => {\n        try {\n          setLoading(true);\n          const result = await fetchFunction(props);\n          setData(result);\n        } catch (err) {\n          setError(err.message);\n        } finally {\n          setLoading(false);\n        }\n      };\n      \n      fetchData();\n    }, [props]);\n    \n    // Create props to pass\n    const dataProps = {\n      [dataKey]: data,\n      loading,\n      error,\n      refetch: () => {\n        setLoading(true);\n        fetchFunction(props).then(setData).catch(setError).finally(() => setLoading(false));\n      }\n    };\n    \n    return <WrappedComponent {...props} {...dataProps} />;\n  };\n}\n\n// 7. Styling HOC\nfunction withStyles(WrappedComponent, styles) {\n  return function StyledComponent(props) {\n    return (\n      <div style={styles.container}>\n        <WrappedComponent {...props} />\n      </div>\n    );\n  };\n}\n\n// 8. Composing Multiple HOCs\nconst composeHOCs = (...hocs) => (Component) => {\n  return hocs.reduceRight((acc, hoc) => hoc(acc), Component);\n};\n\n// Example usage\nfunction UserProfile({ user, extraData, loading }) {\n  if (loading) {\n    return <div>Loading user profile...</div>;\n  }\n  \n  return (\n    <div className=\"user-profile\">\n      <h2>{user.name}</h2>\n      <p>Email: {user.email}</p>\n      <p>Role: {user.role}</p>\n      <p>Extra: {extraData}</p>\n    </div>\n  );\n}\n\n// Apply multiple HOCs\nconst EnhancedUserProfile = composeHOCs(\n  withAuth,\n  withLoading,\n  withLogger,\n  withExtraProp\n)(UserProfile);\n\n// Data fetching example\nconst fetchUserData = async ({ userId }) => {\n  const response = await fetch(`/api/users/${userId}`);\n  return response.json();\n};\n\nconst UserProfileWithData = withDataFetching(\n  UserProfile,\n  fetchUserData,\n  'userData'\n);\n\n// Main App\nfunction App() {\n  return (\n    <div className=\"app\">\n      <h1>Higher-Order Components Examples</h1>\n      \n      <section>\n        <h2>Authentication HOC</h2>\n        <EnhancedUserProfile loading={false} />\n      </section>\n      \n      <section>\n        <h2>Error Boundary Example</h2>\n        {withErrorBoundary(\n          () => {\n            throw new Error('Test error!');\n          },\n          (error) => (\n            <div>\n              <p>Custom error: {error.message}</p>\n            </div>\n          )\n        )(null)}\n      </section>\n      \n      <section>\n        <h2>Styled Component</h2>\n        {withStyles(\n          () => <div>Content inside styled container</div>,\n          {\n            container: {\n              padding: '20px',\n              border: '2px solid blue',\n              borderRadius: '8px',\n              backgroundColor: '#f0f0f0'\n            }\n          }\n        )(null)}\n      </section>\n    </div>\n  );\n}",
                        "components": [
                            {
                                "name": "HOC Function",
                                "english": "Function that takes component, returns enhanced component",
                                "hinglish": "Function jo component leta hai, enhanced component return karta hai",
                                "importance": "Core HOC pattern",
                                "tip": "Always return a new component, don't modify original"
                            },
                            {
                                "name": "Props Manipulation",
                                "english": "Add, remove, or modify props",
                                "hinglish": "Props add, remove ya modify karo",
                                "importance": "Enhance component functionality",
                                "tip": "Use spread operator to pass props through"
                            },
                            {
                                "name": "Composition",
                                "english": "Combine multiple HOCs",
                                "hinglish": "Multiple HOCs combine karo",
                                "importance": "Build complex enhancements",
                                "tip": "Use compose utility for readability"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Pattern",
                                "Use Case",
                                "Pros",
                                "Cons"
                            ],
                            "rows": [
                                [
                                    "HOCs",
                                    "Cross-cutting concerns",
                                    "Reusable, separation",
                                    "Wrapper hell, prop collisions"
                                ],
                                [
                                    "Render Props",
                                    "Dynamic composition",
                                    "Flexible, explicit",
                                    "Nested callbacks"
                                ],
                                [
                                    "Custom Hooks",
                                    "Stateful logic",
                                    "Composable, clean",
                                    "No UI enhancement"
                                ],
                                [
                                    "Compound Components",
                                    "Component families",
                                    "Flexible API",
                                    "Complex implementation"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Pass unrelated props through",
                                "reason": "Don't block props meant for wrapped component",
                                "hinglish": "Wrapped component ke liye meant props ko block mat karo"
                            },
                            {
                                "practice": "Use displayName for debugging",
                                "reason": "Easy to identify in React DevTools",
                                "hinglish": "React DevTools mein identify karna easy ho"
                            },
                            {
                                "practice": "Keep HOCs simple and focused",
                                "reason": "Easier to test and compose",
                                "hinglish": "Test aur compose karna easy ho"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Modifying original component",
                                "solution": "Always return new component",
                                "hinglish": "Hamesha naya component return karo"
                            },
                            {
                                "mistake": "Prop name collisions",
                                "solution": "Use unique prop names or namespace",
                                "hinglish": "Unique prop names ya namespace use karo"
                            }
                        ]
                    }
                },
                {
                    "id": 15,
                    "title": "Render Props Pattern",
                    "english": "Render props is a pattern where a component's children is a function that returns React elements, enabling dynamic composition.",
                    "hinglish": "Render props ek pattern hai jisme component ke children ek function hote hain jo React elements return karte hain, dynamic composition enable karta hai.",
                    "examples": [
                        "<Mouse render={(x, y) => (\n  <p>Mouse position: {x}, {y}</p>\n)} />",
                        "<DataProvider>\n  {data => <div>{data}</div>}\n</DataProvider>"
                    ],
                    "practice": [
                        {
                            "question": "What is render props pattern?",
                            "answer": "A component that takes a function as a prop (often called render) and calls it with data"
                        },
                        {
                            "question": "What are alternatives to render prop?",
                            "answer": "1. children as function 2. Component injection"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// 1. Basic Render Prop Component\nfunction MouseTracker({ render }) {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  \n  const handleMouseMove = (event) => {\n    setPosition({\n      x: event.clientX,\n      y: event.clientY\n    });\n  };\n  \n  return (\n    <div style={{ height: '100vh' }} onMouseMove={handleMouseMove}>\n      {/* Call render prop with position */}\n      {render(position)}\n    </div>\n  );\n}\n\n// 2. Children as Function Pattern\nfunction MouseTracker2({ children }) {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  \n  const handleMouseMove = (event) => {\n    setPosition({\n      x: event.clientX,\n      y: event.clientY\n    });\n  };\n  \n  return (\n    <div style={{ height: '100vh' }} onMouseMove={handleMouseMove}>\n      {/* Call children function with position */}\n      {children(position)}\n    </div>\n  );\n}\n\n// 3. Data Provider Component\nfunction DataFetcher({ url, render }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        const response = await fetch(url);\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    fetchData();\n  }, [url]);\n  \n  return render({ data, loading, error });\n}\n\n// 4. Toggle Component\nfunction Toggle({ children }) {\n  const [on, setOn] = useState(false);\n  \n  const toggle = () => setOn(!on);\n  const setOnState = (value) => setOn(value);\n  \n  return children({ on, toggle, setOn: setOnState });\n}\n\n// 5. Form State Manager\nfunction FormManager({ initialValues, children }) {\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n  \n  const handleChange = (name, value) => {\n    setValues(prev => ({ ...prev, [name]: value }));\n    \n    // Clear error when user types\n    if (errors[name]) {\n      setErrors(prev => ({ ...prev, [name]: '' }));\n    }\n  };\n  \n  const handleBlur = (name) => {\n    setTouched(prev => ({ ...prev, [name]: true }));\n  };\n  \n  const validate = () => {\n    const newErrors = {};\n    // Simple validation\n    Object.keys(values).forEach(key => {\n      if (!values[key]) {\n        newErrors[key] = `${key} is required`;\n      }\n    });\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n  \n  const reset = () => {\n    setValues(initialValues);\n    setErrors({});\n    setTouched({});\n  };\n  \n  return children({\n    values,\n    errors,\n    touched,\n    handleChange,\n    handleBlur,\n    validate,\n    reset,\n    isValid: Object.keys(errors).length === 0\n  });\n}\n\n// 6. Theme Provider with Render Prop\nfunction ThemeProvider({ theme: initialTheme, children }) {\n  const [theme, setTheme] = useState(initialTheme);\n  \n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n  \n  const themeStyles = {\n    light: {\n      backgroundColor: '#ffffff',\n      color: '#000000',\n      buttonColor: '#007bff'\n    },\n    dark: {\n      backgroundColor: '#1a1a1a',\n      color: '#ffffff',\n      buttonColor: '#6c757d'\n    }\n  };\n  \n  return children({\n    theme,\n    toggleTheme,\n    styles: themeStyles[theme]\n  });\n}\n\n// 7. Window Size Tracker\nfunction WindowSize({ children }) {\n  const [size, setSize] = useState({\n    width: window.innerWidth,\n    height: window.innerHeight\n  });\n  \n  useEffect(() => {\n    const handleResize = () => {\n      setSize({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    };\n    \n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n  \n  return children(size);\n}\n\n// 8. Authentication Render Prop\nfunction AuthProvider({ children }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    // Check existing auth\n    const token = localStorage.getItem('token');\n    if (token) {\n      setUser({ id: 1, name: 'John Doe' });\n    }\n    setLoading(false);\n  }, []);\n  \n  const login = (credentials) => {\n    // Mock login\n    localStorage.setItem('token', 'fake-token');\n    setUser({ id: 1, name: 'John Doe' });\n  };\n  \n  const logout = () => {\n    localStorage.removeItem('token');\n    setUser(null);\n  };\n  \n  return children({ user, loading, login, logout });\n}\n\n// Usage Examples\nfunction App() {\n  return (\n    <div className=\"app\">\n      <h1>Render Props Pattern Examples</h1>\n      \n      {/* Example 1: Mouse Tracker with render prop */}\n      <section>\n        <h2>Mouse Tracker</h2>\n        <MouseTracker\n          render={({ x, y }) => (\n            <div>\n              <p>Mouse position: {x}, {y}</p>\n              <div style={{\n                position: 'absolute',\n                left: x - 10,\n                top: y - 10,\n                width: '20px',\n                height: '20px',\n                backgroundColor: 'red',\n                borderRadius: '50%'\n              }} />\n            </div>\n          )}\n        />\n      </section>\n      \n      {/* Example 2: Mouse Tracker with children as function */}\n      <section>\n        <h2>Mouse Tracker (Children Function)</h2>\n        <MouseTracker2>\n          {({ x, y }) => (\n            <div>\n              <h3>Position: ({x}, {y})</h3>\n              <progress value={x} max={window.innerWidth} />\n            </div>\n          )}\n        </MouseTracker2>\n      </section>\n      \n      {/* Example 3: Data Fetcher */}\n      <section>\n        <h2>Data Fetcher</h2>\n        <DataFetcher\n          url=\"https://api.github.com/users/facebook\"\n          render={({ data, loading, error }) => {\n            if (loading) return <div>Loading...</div>;\n            if (error) return <div>Error: {error}</div>;\n            if (!data) return <div>No data</div>;\n            \n            return (\n              <div>\n                <h3>{data.login}</h3>\n                <img src={data.avatar_url} alt={data.login} width=\"100\" />\n                <p>{data.bio}</p>\n              </div>\n            );\n          }}\n        />\n      </section>\n      \n      {/* Example 4: Toggle Component */}\n      <section>\n        <h2>Toggle Component</h2>\n        <Toggle>\n          {({ on, toggle }) => (\n            <div>\n              <button onClick={toggle}>\n                {on ? 'ON' : 'OFF'}\n              </button>\n              {on && (\n                <div style={{ padding: '20px', backgroundColor: 'green', color: 'white' }}>\n                  Content visible when ON\n                </div>\n              )}\n            </div>\n          )}\n        </Toggle>\n      </section>\n      \n      {/* Example 5: Form Manager */}\n      <section>\n        <h2>Form Manager</h2>\n        <FormManager initialValues={{ name: '', email: '' }}>\n          {({ values, errors, handleChange, validate }) => (\n            <form onSubmit={(e) => {\n              e.preventDefault();\n              if (validate()) {\n                alert('Form submitted: ' + JSON.stringify(values));\n              }\n            }}>\n              <div>\n                <label>Name:</label>\n                <input\n                  value={values.name}\n                  onChange={(e) => handleChange('name', e.target.value)}\n                />\n                {errors.name && <span style={{ color: 'red' }}>{errors.name}</span>}\n              </div>\n              \n              <div>\n                <label>Email:</label>\n                <input\n                  type=\"email\"\n                  value={values.email}\n                  onChange={(e) => handleChange('email', e.target.value)}\n                />\n                {errors.email && <span style={{ color: 'red' }}>{errors.email}</span>}\n              </div>\n              \n              <button type=\"submit\">Submit</button>\n              \n              <pre>{JSON.stringify(values, null, 2)}</pre>\n            </form>\n          )}\n        </FormManager>\n      </section>\n      \n      {/* Example 6: Theme Provider */}\n      <section>\n        <h2>Theme Provider</h2>\n        <ThemeProvider theme=\"light\">\n          {({ theme, toggleTheme, styles }) => (\n            <div style={{\n              padding: '20px',\n              backgroundColor: styles.backgroundColor,\n              color: styles.color\n            }}>\n              <h3>Current Theme: {theme}</h3>\n              <button \n                onClick={toggleTheme}\n                style={{\n                  backgroundColor: styles.buttonColor,\n                  color: 'white',\n                  padding: '10px 20px',\n                  border: 'none',\n                  borderRadius: '4px'\n                }}\n              >\n                Toggle Theme\n              </button>\n              <p>This content adapts to theme</p>\n            </div>\n          )}\n        </ThemeProvider>\n      </section>\n      \n      {/* Example 7: Window Size */}\n      <section>\n        <h2>Window Size Tracker</h2>\n        <WindowSize>\n          {({ width, height }) => (\n            <div>\n              <p>Window Size: {width} x {height}</p>\n              <p>Device: {width < 768 ? 'Mobile' : width < 1024 ? 'Tablet' : 'Desktop'}</p>\n            </div>\n          )}\n        </WindowSize>\n      </section>\n      \n      {/* Example 8: Authentication */}\n      <section>\n        <h2>Authentication</h2>\n        <AuthProvider>\n          {({ user, loading, login, logout }) => {\n            if (loading) return <div>Checking auth...</div>;\n            \n            if (!user) {\n              return (\n                <div>\n                  <p>Please login</p>\n                  <button onClick={() => login({})}>Login</button>\n                </div>\n              );\n            }\n            \n            return (\n              <div>\n                <p>Welcome, {user.name}!</p>\n                <button onClick={logout}>Logout</button>\n              </div>\n            );\n          }}\n        </AuthProvider>\n      </section>\n    </div>\n  );\n}",
                        "components": [
                            {
                                "name": "Render Prop",
                                "english": "Function prop that renders content",
                                "hinglish": "Function prop jo content render karta hai",
                                "importance": "Dynamic composition",
                                "tip": "Usually called 'render' or uses children"
                            },
                            {
                                "name": "Children as Function",
                                "english": "children prop as render function",
                                "hinglish": "children prop render function ki tarah",
                                "importance": "Cleaner JSX syntax",
                                "tip": "More intuitive than render prop"
                            },
                            {
                                "name": "State Exposure",
                                "english": "Expose internal state to render function",
                                "hinglish": "Internal state ko render function ko expose karo",
                                "importance": "Consumer controls rendering",
                                "tip": "Pass state and handlers as function arguments"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Aspect",
                                "Render Props",
                                "HOCs"
                            ],
                            "rows": [
                                [
                                    "Composition",
                                    "Dynamic at render time",
                                    "Static at composition time"
                                ],
                                [
                                    "Explicitness",
                                    "Explicit data flow",
                                    "Implicit prop injection"
                                ],
                                [
                                    "Flexibility",
                                    "High - consumer controls render",
                                    "Medium - HOC controls"
                                ],
                                [
                                    "Nesting",
                                    "Callback hell possible",
                                    "Wrapper hell possible"
                                ],
                                [
                                    "Debugging",
                                    "Easier - see props in render",
                                    "Harder - props are hidden"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Use children as function for cleaner syntax",
                                "reason": "More intuitive and readable",
                                "hinglish": "More intuitive aur readable hai"
                            },
                            {
                                "practice": "Provide sensible defaults",
                                "reason": "Better developer experience",
                                "hinglish": "Better developer experience ke liye"
                            },
                            {
                                "practice": "Memoize render functions",
                                "reason": "Performance optimization",
                                "hinglish": "Performance optimization ke liye"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Creating new functions on every render",
                                "solution": "Use useCallback or move function outside",
                                "hinglish": "useCallback ya function bahar move karo"
                            },
                            {
                                "mistake": "Too much nesting",
                                "solution": "Extract to separate components",
                                "hinglish": "Alag components mein extract karo"
                            }
                        ]
                    }
                },
                {
                    "id": 16,
                    "title": "Next.js Fundamentals: Pages and Routing",
                    "english": "Next.js provides file-based routing where pages are React components in the pages directory.",
                    "hinglish": "Next.js file-based routing provide karta hai jahan pages directory mein pages React components hain.",
                    "examples": [
                        "// pages/about.js\nexport default function About() {\n  return <h1>About Page</h1>;\n}",
                        "// pages/users/[id].js\nexport default function User({ userId }) {\n  return <h1>User: {userId}</h1>;\n}"
                    ],
                    "practice": [
                        {
                            "question": "How does Next.js routing work?",
                            "answer": "File-based routing: files in pages directory become routes"
                        },
                        {
                            "question": "How to create dynamic routes?",
                            "answer": "Use [] brackets in filename: [id].js"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// pages/index.js - Home page\nimport Link from 'next/link';\nimport { useRouter } from 'next/router';\n\nexport default function HomePage() {\n  const router = useRouter();\n  \n  const navigateToAbout = () => {\n    router.push('/about');\n  };\n  \n  return (\n    <div>\n      <h1>Welcome to Next.js!</h1>\n      <p>This is the home page.</p>\n      \n      {/* Navigation Links */}\n      <nav>\n        <ul>\n          <li>\n            <Link href=\"/about\">About</Link>\n          </li>\n          <li>\n            <Link href=\"/products\">Products</Link>\n          </li>\n          <li>\n            <Link href=\"/users\">Users</Link>\n          </li>\n          <li>\n            <Link href=\"/blog/first-post\">First Blog Post</Link>\n          </li>\n          <li>\n            <Link href=\"/dashboard\">Dashboard</Link>\n          </li>\n        </ul>\n      </nav>\n      \n      <button onClick={navigateToAbout}>\n        Go to About Programmatically\n      </button>\n      \n      {/* Prefetching example */}\n      <Link href=\"/contact\" prefetch={false}>\n        Contact (No Prefetch)\n      </Link>\n    </div>\n  );\n}\n\n// pages/about.js - Static page\nexport default function AboutPage() {\n  return (\n    <div>\n      <h1>About Us</h1>\n      <p>Learn more about our company.</p>\n      <Link href=\"/\">Back to Home</Link>\n    </div>\n  );\n}\n\n// pages/products/index.js - Products listing\nexport default function ProductsPage() {\n  const products = [\n    { id: 1, name: 'Product 1', price: 100 },\n    { id: 2, name: 'Product 2', price: 200 },\n    { id: 3, name: 'Product 3', price: 300 },\n  ];\n  \n  return (\n    <div>\n      <h1>Products</h1>\n      <ul>\n        {products.map(product => (\n          <li key={product.id}>\n            <Link href={`/products/${product.id}`}>\n              {product.name} - ${product.price}\n            </Link>\n          </li>\n        ))}\n      </ul>\n      \n      {/* Nested route */}\n      <Link href=\"/products/categories/electronics\">\n        View Electronics Category\n      </Link>\n    </div>\n  );\n}\n\n// pages/products/[id].js - Dynamic product page\nimport { useRouter } from 'next/router';\n\nexport default function ProductDetailPage() {\n  const router = useRouter();\n  const { id } = router.query;\n  \n  // Loading state\n  if (router.isFallback) {\n    return <div>Loading...</div>;\n  }\n  \n  return (\n    <div>\n      <h1>Product Details</h1>\n      <p>Product ID: {id}</p>\n      <p>Product Name: Product {id}</p>\n      <p>Price: ${id * 100}</p>\n      \n      <Link href=\"/products\">Back to Products</Link>\n    </div>\n  );\n}\n\n// Optional catch-all: pages/products/[[...slug]].js\nexport default function ProductCategoryPage() {\n  const router = useRouter();\n  const { slug } = router.query;\n  \n  return (\n    <div>\n      <h1>Product Category</h1>\n      <p>Slug: {slug ? slug.join('/') : 'No category selected'}</p>\n      \n      <ul>\n        <li><Link href=\"/products/categories/electronics\">Electronics</Link></li>\n        <li><Link href=\"/products/categories/electronics/laptops\">Electronics/Laptops</Link></li>\n        <li><Link href=\"/products/categories/clothing/men/shirts\">Clothing/Men/Shirts</Link></li>\n      </ul>\n    </div>\n  );\n}\n\n// pages/users/index.js\nexport default function UsersPage() {\n  const users = [\n    { id: 1, name: 'John Doe', role: 'admin' },\n    { id: 2, name: 'Jane Smith', role: 'user' },\n    { id: 3, name: 'Bob Johnson', role: 'user' },\n  ];\n  \n  return (\n    <div>\n      <h1>Users</h1>\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>\n            <Link href={`/users/${user.id}/profile`}>\n              {user.name}\n            </Link>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// pages/users/[userId]/profile.js - Nested dynamic route\nexport default function UserProfilePage() {\n  const router = useRouter();\n  const { userId } = router.query;\n  \n  return (\n    <div>\n      <h1>User Profile</h1>\n      <p>User ID: {userId}</p>\n      <p>Profile details for user {userId}</p>\n      \n      {/* Nested profile tabs */}\n      <nav>\n        <Link href={`/users/${userId}/profile`}>Overview</Link>\n        <Link href={`/users/${userId}/profile/settings`}>Settings</Link>\n        <Link href={`/users/${userId}/profile/activity`}>Activity</Link>\n      </nav>\n    </div>\n  );\n}\n\n// pages/users/[userId]/profile/[tab].js - Nested dynamic with multiple params\nexport default function UserProfileTabPage() {\n  const router = useRouter();\n  const { userId, tab } = router.query;\n  \n  return (\n    <div>\n      <h1>User {userId} - {tab}</h1>\n      <p>Content for {tab} tab</p>\n    </div>\n  );\n}\n\n// pages/blog/[slug].js - Blog post with getStaticPaths\nexport default function BlogPostPage({ post }) {\n  return (\n    <div>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </div>\n  );\n}\n\n// pages/contact.js - Contact page with form\nexport default function ContactPage() {\n  const [formData, setFormData] = useState({ name: '', email: '', message: '' });\n  const router = useRouter();\n  \n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    \n    // Submit form data\n    const response = await fetch('/api/contact', {\n      method: 'POST',\n      body: JSON.stringify(formData),\n    });\n    \n    if (response.ok) {\n      router.push('/thank-you');\n    }\n  };\n  \n  return (\n    <div>\n      <h1>Contact Us</h1>\n      <form onSubmit={handleSubmit}>\n        <input\n          type=\"text\"\n          placeholder=\"Name\"\n          value={formData.name}\n          onChange={(e) => setFormData({ ...formData, name: e.target.value })}\n        />\n        <input\n          type=\"email\"\n          placeholder=\"Email\"\n          value={formData.email}\n          onChange={(e) => setFormData({ ...formData, email: e.target.value })}\n        />\n        <textarea\n          placeholder=\"Message\"\n          value={formData.message}\n          onChange={(e) => setFormData({ ...formData, message: e.target.value })}\n        />\n        <button type=\"submit\">Send Message</button>\n      </form>\n    </div>\n  );\n}\n\n// pages/dashboard.js - Dashboard with protected route\nexport default function DashboardPage() {\n  const [user, setUser] = useState(null);\n  const router = useRouter();\n  \n  useEffect(() => {\n    // Check authentication\n    const token = localStorage.getItem('token');\n    if (!token) {\n      router.push('/login');\n    } else {\n      setUser({ name: 'John Doe' });\n    }\n  }, [router]);\n  \n  if (!user) {\n    return <div>Loading dashboard...</div>;\n  }\n  \n  return (\n    <div>\n      <h1>Dashboard</h1>\n      <p>Welcome, {user.name}!</p>\n      \n      <div>\n        <Link href=\"/dashboard/settings\">Settings</Link>\n        <Link href=\"/dashboard/analytics\">Analytics</Link>\n        <Link href=\"/dashboard/reports\">Reports</Link>\n      </div>\n    </div>\n  );\n}\n\n// pages/404.js - Custom 404 page\nexport default function Custom404() {\n  return (\n    <div style={{ textAlign: 'center', padding: '50px' }}>\n      <h1>404 - Page Not Found</h1>\n      <p>The page you're looking for doesn't exist.</p>\n      <Link href=\"/\">Return to Home</Link>\n    </div>\n  );\n}\n\n// pages/_app.js - Custom App component\nfunction MyApp({ Component, pageProps }) {\n  return (\n    <div className=\"app-wrapper\">\n      <header>\n        <nav>\n          <Link href=\"/\">Home</Link>\n          <Link href=\"/about\">About</Link>\n          <Link href=\"/products\">Products</Link>\n          <Link href=\"/contact\">Contact</Link>\n        </nav>\n      </header>\n      \n      <main>\n        <Component {...pageProps} />\n      </main>\n      \n      <footer>\n        <p>&copy; 2024 My Next.js App</p>\n      </footer>\n    </div>\n  );\n}\n\nexport default MyApp;\n\n// pages/_document.js - Custom Document component\nimport Document, { Html, Head, Main, NextScript } from 'next/document';\n\nclass MyDocument extends Document {\n  render() {\n    return (\n      <Html lang=\"en\">\n        <Head>\n          <link rel=\"icon\" href=\"/favicon.ico\" />\n          <meta name=\"description\" content=\"My Next.js application\" />\n          <link href=\"https://fonts.googleapis.com/css2?family=Inter&display=swap\" rel=\"stylesheet\" />\n        </Head>\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    );\n  }\n}\n\nexport default MyDocument;",
                        "components": [
                            {
                                "name": "File-based Routing",
                                "english": "Routes based on file structure",
                                "hinglish": "File structure ke basis par routes",
                                "importance": "Zero-config routing",
                                "tip": "pages directory is special in Next.js"
                            },
                            {
                                "name": "Dynamic Routes",
                                "english": "Routes with parameters using []",
                                "hinglish": "[] use karke parameters wale routes",
                                "importance": "Handle dynamic content",
                                "tip": "[id].js creates /:id route"
                            },
                            {
                                "name": "Link Component",
                                "english": "Client-side navigation component",
                                "hinglish": "Client-side navigation component",
                                "importance": "Fast navigation without page reload",
                                "tip": "Always use Link instead of <a> for internal links"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Routing Type",
                                "File Pattern",
                                "Route Example"
                            ],
                            "rows": [
                                [
                                    "Static",
                                    "about.js",
                                    "/about"
                                ],
                                [
                                    "Dynamic",
                                    "[id].js",
                                    "/products/123"
                                ],
                                [
                                    "Nested",
                                    "blog/[slug].js",
                                    "/blog/my-post"
                                ],
                                [
                                    "Catch-all",
                                    "[...slug].js",
                                    "/docs/a/b/c"
                                ],
                                [
                                    "Optional Catch-all",
                                    "[[...slug]].js",
                                    "/shop or /shop/category"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Use Link for internal navigation",
                                "reason": "Client-side navigation, faster",
                                "hinglish": "Client-side navigation, faster hai"
                            },
                            {
                                "practice": "Organize pages logically",
                                "reason": "Maintainable code structure",
                                "hinglish": "Maintainable code structure ke liye"
                            },
                            {
                                "practice": "Use _app.js for global layout",
                                "reason": "Consistent layout across pages",
                                "hinglish": "Saare pages par consistent layout"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Using anchor tags for internal links",
                                "solution": "Always use Next.js Link component",
                                "hinglish": "Internal links ke liye hamesha Next.js Link component use karo"
                            },
                            {
                                "mistake": "Forgetting to handle loading states",
                                "solution": "Check router.isFallback in dynamic routes",
                                "hinglish": "Dynamic routes mein router.isFallback check karo"
                            }
                        ]
                    }
                },
                {
                    "id": 17,
                    "title": "Next.js Data Fetching: SSG, SSR, and ISR",
                    "english": "Next.js provides multiple data fetching strategies: Static Generation (SSG), Server-Side Rendering (SSR), and Incremental Static Regeneration (ISR).",
                    "hinglish": "Next.js multiple data fetching strategies provide karta hai: Static Generation (SSG), Server-Side Rendering (SSR), aur Incremental Static Regeneration (ISR).",
                    "examples": [
                        "// SSG with getStaticProps\nexport async function getStaticProps() {\n  return { props: { data } };\n}",
                        "// SSR with getServerSideProps\nexport async function getServerSideProps(context) {\n  return { props: { data } };\n}"
                    ],
                    "practice": [
                        {
                            "question": "Difference between SSG and SSR?",
                            "answer": "SSG: Build-time generation, SSR: Request-time generation"
                        },
                        {
                            "question": "What is ISR?",
                            "answer": "Incremental Static Regeneration - update static pages after build"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// pages/products/[id].js\nimport { useRouter } from 'next/router';\n\n// 1. Static Generation with getStaticProps and getStaticPaths\nexport async function getStaticPaths() {\n  // Fetch product IDs from API\n  const res = await fetch('https://api.example.com/products');\n  const products = await res.json();\n  \n  // Generate paths for pre-rendering\n  const paths = products.map(product => ({\n    params: { id: product.id.toString() },\n  }));\n  \n  // Only pre-render these paths at build time\n  // Fallback: true -> show loading for other paths\n  // Fallback: blocking -> wait for generation\n  return {\n    paths,\n    fallback: 'blocking', // or true or false\n  };\n}\n\nexport async function getStaticProps({ params }) {\n  // Fetch product data for specific ID\n  const res = await fetch(`https://api.example.com/products/${params.id}`);\n  const product = await res.json();\n  \n  // If product not found, return 404\n  if (!product) {\n    return {\n      notFound: true,\n    };\n  }\n  \n  // Return props to page component\n  return {\n    props: {\n      product,\n    },\n    // Re-generate page every 10 seconds (ISR)\n    revalidate: 10,\n  };\n}\n\nexport default function ProductPage({ product }) {\n  const router = useRouter();\n  \n  // If page is not yet generated, this will be displayed\n  if (router.isFallback) {\n    return <div>Loading...</div>;\n  }\n  \n  return (\n    <div>\n      <h1>{product.name}</h1>\n      <p>{product.description}</p>\n      <p>Price: ${product.price}</p>\n    </div>\n  );\n}\n\n// pages/blog/[slug].js\n// 2. Incremental Static Regeneration (ISR) Example\nexport async function getStaticPaths() {\n  // For large sites, don't pre-render all paths\n  return {\n    paths: [\n      { params: { slug: 'first-post' } },\n      { params: { slug: 'second-post' } },\n    ],\n    fallback: 'blocking',\n  };\n}\n\nexport async function getStaticProps({ params }) {\n  const res = await fetch(`https://api.example.com/posts/${params.slug}`);\n  const post = await res.json();\n  \n  return {\n    props: {\n      post,\n    },\n    // ISR: Revalidate every 60 seconds\n    revalidate: 60,\n    // Cache for 1 hour on CDN\n    headers: {\n      'Cache-Control': 'public, max-age=3600, stale-while-revalidate=86400',\n    },\n  };\n}\n\nexport default function BlogPost({ post }) {\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <div dangerouslySetInnerHTML={{ __html: post.content }} />\n      <p>Published: {new Date(post.publishedAt).toLocaleDateString()}</p>\n    </article>\n  );\n}\n\n// pages/dashboard.js\n// 3. Server-Side Rendering (SSR) Example\nexport async function getServerSideProps(context) {\n  const { req, res, query } = context;\n  \n  // Access cookies, headers, etc.\n  const token = req.cookies.token;\n  \n  if (!token) {\n    // Redirect if not authenticated\n    return {\n      redirect: {\n        destination: '/login',\n        permanent: false,\n      },\n    };\n  }\n  \n  // Fetch user-specific data\n  const userRes = await fetch('https://api.example.com/user', {\n    headers: { Authorization: `Bearer ${token}` },\n  });\n  const userData = await userRes.json();\n  \n  // Fetch dashboard data\n  const dashboardRes = await fetch('https://api.example.com/dashboard', {\n    headers: { Authorization: `Bearer ${token}` },\n  });\n  const dashboardData = await dashboardRes.json();\n  \n  // Set cache headers\n  res.setHeader(\n    'Cache-Control',\n    'public, s-maxage=10, stale-while-revalidate=59'\n  );\n  \n  return {\n    props: {\n      user: userData,\n      dashboard: dashboardData,\n      // Pass query params to page\n      searchQuery: query.q || '',\n    },\n  };\n}\n\nexport default function DashboardPage({ user, dashboard, searchQuery }) {\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      <p>Welcome, {user.name}!</p>\n      \n      <div>\n        <h2>Stats</h2>\n        <p>Total Users: {dashboard.totalUsers}</p>\n        <p>Revenue: ${dashboard.revenue}</p>\n      </div>\n      \n      {searchQuery && (\n        <p>Search results for: {searchQuery}</p>\n      )}\n    </div>\n  );\n}\n\n// pages/index.js\n// 4. Static Generation without external data\nexport default function HomePage() {\n  return (\n    <div>\n      <h1>Welcome to our site!</h1>\n      <p>This page is statically generated at build time.</p>\n    </div>\n  );\n}\n\n// pages/products/index.js\n// 5. Static Generation with revalidation\nexport async function getStaticProps() {\n  const res = await fetch('https://api.example.com/products');\n  const products = await res.json();\n  \n  return {\n    props: {\n      products,\n    },\n    // Revalidate every hour\n    revalidate: 3600,\n  };\n}\n\nexport default function ProductsPage({ products }) {\n  return (\n    <div>\n      <h1>Products</h1>\n      <ul>\n        {products.map(product => (\n          <li key={product.id}>\n            <h3>{product.name}</h3>\n            <p>{product.price}</p>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// pages/api/revalidate.js\n// 6. On-demand Revalidation (Webhook)\nexport default async function handler(req, res) {\n  // Check for secret token\n  if (req.query.secret !== process.env.REVALIDATION_TOKEN) {\n    return res.status(401).json({ message: 'Invalid token' });\n  }\n  \n  try {\n    // Revalidate specific paths\n    await res.revalidate('/products');\n    await res.revalidate(`/products/${req.body.productId}`);\n    \n    return res.json({ revalidated: true });\n  } catch (err) {\n    return res.status(500).send('Error revalidating');\n  }\n}\n\n// pages/analytics.js\n// 7. Client-side Data Fetching (for user-specific data)\nimport { useState, useEffect } from 'react';\n\nexport default function AnalyticsPage() {\n  const [analytics, setAnalytics] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    const fetchAnalytics = async () => {\n      const res = await fetch('/api/analytics');\n      const data = await res.json();\n      setAnalytics(data);\n      setLoading(false);\n    };\n    \n    fetchAnalytics();\n  }, []);\n  \n  if (loading) return <div>Loading analytics...</div>;\n  \n  return (\n    <div>\n      <h1>Analytics</h1>\n      <pre>{JSON.stringify(analytics, null, 2)}</pre>\n    </div>\n  );\n}\n\n// pages/weather/[city].js\n// 8. Hybrid Approach: SSG with client-side updates\nexport async function getStaticProps({ params }) {\n  // Initial static data\n  const initialRes = await fetch(\n    `https://api.weather.com/${params.city}?date=${new Date().toISOString().split('T')[0]}`\n  );\n  const initialData = await initialRes.json();\n  \n  return {\n    props: {\n      city: params.city,\n      initialWeather: initialData,\n      lastUpdated: new Date().toISOString(),\n    },\n    revalidate: 3600, // Update every hour\n  };\n}\n\nexport async function getStaticPaths() {\n  return {\n    paths: [\n      { params: { city: 'new-york' } },\n      { params: { city: 'london' } },\n      { params: { city: 'tokyo' } },\n    ],\n    fallback: true,\n  };\n}\n\nexport default function WeatherPage({ city, initialWeather, lastUpdated }) {\n  const [weather, setWeather] = useState(initialWeather);\n  const [realTimeData, setRealTimeData] = useState(null);\n  const router = useRouter();\n  \n  // Client-side update for real-time data\n  useEffect(() => {\n    const fetchRealTimeWeather = async () => {\n      const res = await fetch(`/api/weather/realtime/${city}`);\n      const data = await res.json();\n      setRealTimeData(data);\n    };\n    \n    fetchRealTimeWeather();\n    \n    // Update every minute\n    const interval = setInterval(fetchRealTimeWeather, 60000);\n    return () => clearInterval(interval);\n  }, [city]);\n  \n  if (router.isFallback) {\n    return <div>Loading weather data...</div>;\n  }\n  \n  return (\n    <div>\n      <h1>Weather in {city}</h1>\n      <p>Last updated: {lastUpdated}</p>\n      \n      <div>\n        <h2>Static Data (Hourly updates)</h2>\n        <p>Temperature: {weather.temperature}C</p>\n        <p>Condition: {weather.condition}</p>\n      </div>\n      \n      {realTimeData && (\n        <div>\n          <h2>Real-time Data</h2>\n          <p>Current Temp: {realTimeData.currentTemp}C</p>\n          <p>Feels Like: {realTimeData.feelsLike}C</p>\n        </div>\n      )}\n    </div>\n  );\n}",
                        "components": [
                            {
                                "name": "getStaticProps (SSG)",
                                "english": "Fetch data at build time",
                                "hinglish": "Build time par data fetch karo",
                                "importance": "Fastest, cached pages",
                                "tip": "Use for content that doesn't change often"
                            },
                            {
                                "name": "getServerSideProps (SSR)",
                                "english": "Fetch data on each request",
                                "hinglish": "Har request par data fetch karo",
                                "importance": "Fresh data, user-specific",
                                "tip": "Use for dashboard, authenticated pages"
                            },
                            {
                                "name": "Incremental Static Regeneration (ISR)",
                                "english": "Update static pages after build",
                                "hinglish": "Build ke baad static pages update karo",
                                "importance": "Best of both worlds",
                                "tip": "Use revalidate prop in getStaticProps"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Method",
                                "When Data Fetched",
                                "Use Case"
                            ],
                            "rows": [
                                [
                                    "Static Generation (SSG)",
                                    "Build time",
                                    "Blog posts, documentation"
                                ],
                                [
                                    "Server-side Rendering (SSR)",
                                    "Request time",
                                    "Dashboard, user data"
                                ],
                                [
                                    "Client-side Fetching",
                                    "Browser runtime",
                                    "User interactions, real-time"
                                ],
                                [
                                    "Incremental Static Regeneration",
                                    "Build + revalidation",
                                    "E-commerce, news"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Use SSG whenever possible",
                                "reason": "Best performance, CDN cacheable",
                                "hinglish": "Best performance, CDN cacheable"
                            },
                            {
                                "practice": "Use ISR for dynamic content",
                                "reason": "Fresh content with performance",
                                "hinglish": "Fresh content with performance"
                            },
                            {
                                "practice": "Use SSR for authenticated pages",
                                "reason": "Secure, user-specific data",
                                "hinglish": "Secure, user-specific data"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Using SSR when SSG would work",
                                "solution": "Analyze data freshness requirements",
                                "hinglish": "Data freshness requirements analyze karo"
                            },
                            {
                                "mistake": "Not handling fallback states",
                                "solution": "Always handle router.isFallback",
                                "hinglish": "Hamesha router.isFallback handle karo"
                            }
                        ]
                    }
                },
                {
                    "id": 18,
                    "title": "Next.js API Routes",
                    "english": "API Routes allow creating API endpoints within Next.js applications, serving as backend for your frontend.",
                    "hinglish": "API Routes Next.js applications ke andar API endpoints create karne dete hain, aapke frontend ke liye backend ki tarah kaam karte hain.",
                    "examples": [
                        "// pages/api/hello.js\nexport default function handler(req, res) {\n  res.status(200).json({ name: 'John Doe' });\n}",
                        "// pages/api/users/[id].js\nexport default function handler(req, res) {\n  const { id } = req.query;\n  res.json({ userId: id });\n}"
                    ],
                    "practice": [
                        {
                            "question": "Where are API Routes located in Next.js?",
                            "answer": "In the pages/api directory"
                        },
                        {
                            "question": "Can API Routes be dynamic?",
                            "answer": "Yes, using file naming like [id].js"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// pages/api/users/index.js - GET all users, POST new user\nexport default async function handler(req, res) {\n  const { method } = req;\n  \n  switch (method) {\n    case 'GET':\n      return handleGet(req, res);\n    case 'POST':\n      return handlePost(req, res);\n    default:\n      res.setHeader('Allow', ['GET', 'POST']);\n      return res.status(405).end(`Method ${method} Not Allowed`);\n  }\n}\n\nasync function handleGet(req, res) {\n  try {\n    // Connect to database\n    const db = await connectToDatabase();\n    const users = await db.collection('users').find({}).toArray();\n    \n    res.status(200).json(users);\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to fetch users' });\n  }\n}\n\nasync function handlePost(req, res) {\n  try {\n    const { name, email } = req.body;\n    \n    // Validation\n    if (!name || !email) {\n      return res.status(400).json({ error: 'Name and email required' });\n    }\n    \n    // Connect to database\n    const db = await connectToDatabase();\n    const result = await db.collection('users').insertOne({\n      name,\n      email,\n      createdAt: new Date(),\n    });\n    \n    res.status(201).json({\n      id: result.insertedId,\n      name,\n      email,\n    });\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to create user' });\n  }\n}\n\n// pages/api/users/[id].js - GET, PUT, DELETE single user\nexport default async function handler(req, res) {\n  const { id } = req.query;\n  \n  switch (req.method) {\n    case 'GET':\n      return getUser(req, res, id);\n    case 'PUT':\n      return updateUser(req, res, id);\n    case 'DELETE':\n      return deleteUser(req, res, id);\n    default:\n      res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);\n      return res.status(405).end(`Method ${req.method} Not Allowed`);\n  }\n}\n\nasync function getUser(req, res, id) {\n  try {\n    const db = await connectToDatabase();\n    const user = await db.collection('users').findOne({ _id: new ObjectId(id) });\n    \n    if (!user) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    \n    res.status(200).json(user);\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to fetch user' });\n  }\n}\n\nasync function updateUser(req, res, id) {\n  try {\n    const { name, email } = req.body;\n    \n    const db = await connectToDatabase();\n    const result = await db.collection('users').updateOne(\n      { _id: new ObjectId(id) },\n      { $set: { name, email, updatedAt: new Date() } }\n    );\n    \n    if (result.matchedCount === 0) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    \n    res.status(200).json({ message: 'User updated successfully' });\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to update user' });\n  }\n}\n\nasync function deleteUser(req, res, id) {\n  try {\n    const db = await connectToDatabase();\n    const result = await db.collection('users').deleteOne({ _id: new ObjectId(id) });\n    \n    if (result.deletedCount === 0) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    \n    res.status(200).json({ message: 'User deleted successfully' });\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to delete user' });\n  }\n}\n\n// pages/api/auth/[...nextauth].js - NextAuth.js configuration\nimport NextAuth from 'next-auth';\nimport Providers from 'next-auth/providers';\n\nexport default NextAuth({\n  providers: [\n    Providers.GitHub({\n      clientId: process.env.GITHUB_ID,\n      clientSecret: process.env.GITHUB_SECRET,\n    }),\n    Providers.Google({\n      clientId: process.env.GOOGLE_CLIENT_ID,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n    }),\n  ],\n  database: process.env.DATABASE_URL,\n  callbacks: {\n    async session(session, token) {\n      session.user.id = token.id;\n      return session;\n    },\n    async jwt(token, user) {\n      if (user) {\n        token.id = user.id;\n      }\n      return token;\n    },\n  },\n});\n\n// pages/api/contact.js - Contact form handler\nexport default async function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n  \n  const { name, email, message } = req.body;\n  \n  // Server-side validation\n  if (!name || !email || !message) {\n    return res.status(400).json({ error: 'All fields are required' });\n  }\n  \n  if (!isValidEmail(email)) {\n    return res.status(400).json({ error: 'Invalid email address' });\n  }\n  \n  try {\n    // Save to database\n    const db = await connectToDatabase();\n    await db.collection('contacts').insertOne({\n      name,\n      email,\n      message,\n      createdAt: new Date(),\n      ip: req.headers['x-forwarded-for'] || req.connection.remoteAddress,\n    });\n    \n    // Send email notification\n    await sendEmail({\n      to: process.env.ADMIN_EMAIL,\n      subject: 'New Contact Form Submission',\n      text: `Name: ${name}\\nEmail: ${email}\\nMessage: ${message}`,\n    });\n    \n    // Send confirmation email to user\n    await sendEmail({\n      to: email,\n      subject: 'Thanks for contacting us',\n      text: 'We have received your message and will get back to you soon.',\n    });\n    \n    res.status(200).json({ success: true, message: 'Message sent successfully' });\n  } catch (error) {\n    console.error('Contact form error:', error);\n    res.status(500).json({ error: 'Failed to process contact form' });\n  }\n}\n\n// pages/api/upload.js - File upload handler\nimport multer from 'multer';\nimport path from 'path';\n\nconst upload = multer({\n  storage: multer.diskStorage({\n    destination: './public/uploads',\n    filename: (req, file, cb) => {\n      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);\n      cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));\n    },\n  }),\n  fileFilter: (req, file, cb) => {\n    const allowedTypes = /jpeg|jpg|png|gif/;\n    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());\n    const mimetype = allowedTypes.test(file.mimetype);\n    \n    if (extname && mimetype) {\n      return cb(null, true);\n    }\n    cb(new Error('Only image files are allowed'));\n  },\n  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB\n});\n\nexport default async function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n  \n  // Use multer middleware\n  upload.single('image')(req, res, async (err) => {\n    if (err) {\n      return res.status(400).json({ error: err.message });\n    }\n    \n    if (!req.file) {\n      return res.status(400).json({ error: 'No file uploaded' });\n    }\n    \n    try {\n      // Process the uploaded file\n      const fileUrl = `/uploads/${req.file.filename}`;\n      \n      // Save to database\n      const db = await connectToDatabase();\n      await db.collection('uploads').insertOne({\n        filename: req.file.filename,\n        originalName: req.file.originalname,\n        path: fileUrl,\n        size: req.file.size,\n        mimetype: req.file.mimetype,\n        uploadedAt: new Date(),\n      });\n      \n      res.status(200).json({\n        success: true,\n        url: fileUrl,\n        filename: req.file.filename,\n      });\n    } catch (error) {\n      res.status(500).json({ error: 'Failed to process upload' });\n    }\n  });\n}\n\n// Configure for Next.js API routes\n// Disable body parsing for file uploads\nexport const config = {\n  api: {\n    bodyParser: false,\n  },\n};\n\n// pages/api/weather/[city].js - External API proxy\nexport default async function handler(req, res) {\n  const { city } = req.query;\n  \n  if (!city) {\n    return res.status(400).json({ error: 'City parameter is required' });\n  }\n  \n  try {\n    // Fetch from external weather API\n    const apiKey = process.env.WEATHER_API_KEY;\n    const response = await fetch(\n      `https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${apiKey}&units=metric`\n    );\n    \n    if (!response.ok) {\n      throw new Error('Weather API request failed');\n    }\n    \n    const data = await response.json();\n    \n    // Transform data\n    const weatherData = {\n      city: data.name,\n      country: data.sys.country,\n      temperature: data.main.temp,\n      feelsLike: data.main.feels_like,\n      humidity: data.main.humidity,\n      condition: data.weather[0].description,\n      icon: data.weather[0].icon,\n      windSpeed: data.wind.speed,\n    };\n    \n    // Cache response\n    res.setHeader('Cache-Control', 'public, max-age=300'); // 5 minutes\n    \n    res.status(200).json(weatherData);\n  } catch (error) {\n    console.error('Weather API error:', error);\n    res.status(500).json({ error: 'Failed to fetch weather data' });\n  }\n}\n\n// pages/api/middleware/rate-limit.js - Rate limiting middleware\nexport default function rateLimit(handler) {\n  const requests = new Map();\n  \n  return async function (req, res) {\n    const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;\n    const now = Date.now();\n    const windowMs = 15 * 60 * 1000; // 15 minutes\n    const maxRequests = 100; // Max requests per window\n    \n    // Get request history for this IP\n    const requestHistory = requests.get(ip) || [];\n    \n    // Remove old requests\n    const recentRequests = requestHistory.filter(time => now - time < windowMs);\n    \n    // Check if limit exceeded\n    if (recentRequests.length >= maxRequests) {\n      return res.status(429).json({\n        error: 'Too many requests, please try again later',\n        retryAfter: Math.ceil((recentRequests[0] + windowMs - now) / 1000),\n      });\n    }\n    \n    // Add current request\n    recentRequests.push(now);\n    requests.set(ip, recentRequests);\n    \n    // Set rate limit headers\n    res.setHeader('X-RateLimit-Limit', maxRequests);\n    res.setHeader('X-RateLimit-Remaining', maxRequests - recentRequests.length);\n    res.setHeader('X-RateLimit-Reset', Math.ceil((now + windowMs) / 1000));\n    \n    // Call handler\n    return handler(req, res);\n  };\n}\n\n// pages/api/protected/secret.js - Protected API route\nimport { getSession } from 'next-auth/client';\n\nexport default async function handler(req, res) {\n  // Check authentication\n  const session = await getSession({ req });\n  \n  if (!session) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  // Check user role\n  if (session.user.role !== 'admin') {\n    return res.status(403).json({ error: 'Forbidden' });\n  }\n  \n  // Handle request\n  switch (req.method) {\n    case 'GET':\n      return res.status(200).json({\n        secret: 'This is admin-only data',\n        user: session.user,\n      });\n    default:\n      res.setHeader('Allow', ['GET']);\n      return res.status(405).end(`Method ${req.method} Not Allowed`);\n  }\n}\n\n// Helper function to connect to database\nasync function connectToDatabase() {\n  // Implementation depends on your database\n  // Example for MongoDB:\n  const { MongoClient } = require('mongodb');\n  const client = await MongoClient.connect(process.env.MONGODB_URI);\n  return client.db();\n}\n\n// Helper function to validate email\nfunction isValidEmail(email) {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n\n// Helper function to send email\nasync function sendEmail({ to, subject, text }) {\n  // Implementation depends on your email service\n  // Example using nodemailer or SendGrid\n  console.log(`Email sent to ${to}: ${subject}`);\n}",
                        "components": [
                            {
                                "name": "API Route Handler",
                                "english": "Function that handles API requests",
                                "hinglish": "Function jo API requests handle karta hai",
                                "importance": "Backend logic in same project",
                                "tip": "Default export function with req and res parameters"
                            },
                            {
                                "name": "Request Methods",
                                "english": "Handle different HTTP methods",
                                "hinglish": "Different HTTP methods handle karo",
                                "importance": "RESTful API design",
                                "tip": "Use switch statement on req.method"
                            },
                            {
                                "name": "Dynamic API Routes",
                                "english": "API routes with parameters",
                                "hinglish": "Parameters wale API routes",
                                "importance": "Handle dynamic API endpoints",
                                "tip": "Use [param].js file naming"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Route Type",
                                "File Pattern",
                                "Example Endpoint"
                            ],
                            "rows": [
                                [
                                    "Basic",
                                    "api/users.js",
                                    "/api/users"
                                ],
                                [
                                    "Dynamic",
                                    "api/users/[id].js",
                                    "/api/users/123"
                                ],
                                [
                                    "Catch-all",
                                    "api/[...slug].js",
                                    "/api/a/b/c"
                                ],
                                [
                                    "Optional",
                                    "api/[[...slug]].js",
                                    "/api or /api/docs"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Validate input on server",
                                "reason": "Security and data integrity",
                                "hinglish": "Security aur data integrity ke liye"
                            },
                            {
                                "practice": "Handle errors gracefully",
                                "reason": "Better API consumer experience",
                                "hinglish": "Better API consumer experience ke liye"
                            },
                            {
                                "practice": "Use proper HTTP status codes",
                                "reason": "Standard API conventions",
                                "hinglish": "Standard API conventions ke liye"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Exposing sensitive data",
                                "solution": "Validate authentication and authorization",
                                "hinglish": "Authentication aur authorization validate karo"
                            },
                            {
                                "mistake": "No rate limiting",
                                "solution": "Implement rate limiting for public APIs",
                                "hinglish": "Public APIs ke liye rate limiting implement karo"
                            }
                        ]
                    }
                }
            ]
        },
        {
            "level": "advanced",
            "order": 3,
            "topics": [
                {
                    "id": 19,
                    "title": "React Suspense for Code Splitting and Data Fetching",
                    "english": "Suspense lets components wait for something before rendering, enabling code splitting and declarative data fetching.",
                    "hinglish": "Suspense components ko render hone se pehle kisi cheez ka wait karne deta hai, code splitting aur declarative data fetching enable karta hai.",
                    "examples": [
                        "const OtherComponent = React.lazy(() => import('./OtherComponent'));\n<Suspense fallback={<Spinner />}>\n  <OtherComponent />\n</Suspense>",
                        "const resource = fetchProfileData();\n<Suspense fallback={<h1>Loading profile...</h1>}>\n  <ProfileDetails resource={resource} />\n</Suspense>"
                    ],
                    "practice": [
                        {
                            "question": "What is Suspense used for?",
                            "answer": "1. Code splitting 2. Data fetching 3. Waiting for resources"
                        },
                        {
                            "question": "How does Suspense help with code splitting?",
                            "answer": "With React.lazy() to load components only when needed"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// 1. Code Splitting with React.lazy and Suspense\nimport React, { Suspense, useState } from 'react';\n\n// Lazy load components\nconst Dashboard = React.lazy(() => import('./Dashboard'));\nconst Analytics = React.lazy(() => import('./Analytics'));\nconst Reports = React.lazy(() => import('./Reports'));\nconst Settings = React.lazy(() => import('./Settings'));\n\n// Named imports with lazy\nconst UserProfile = React.lazy(() => \n  import('./UserProfile').then(module => ({ default: module.UserProfile }))\n);\n\n// Component with preloading\nconst PreloadableComponent = React.lazy(() => \n  import('./HeavyComponent').then(module => {\n    // Preload related modules\n    import('./RelatedModule1');\n    import('./RelatedModule2');\n    return { default: module.default };\n  })\n);\n\nfunction App() {\n  const [currentTab, setCurrentTab] = useState('dashboard');\n  \n  const renderTab = () => {\n    switch (currentTab) {\n      case 'dashboard':\n        return <Dashboard />;\n      case 'analytics':\n        return <Analytics />;\n      case 'reports':\n        return <Reports />;\n      case 'settings':\n        return <Settings />;\n      case 'profile':\n        return <UserProfile userId=\"123\" />;\n      default:\n        return <Dashboard />;\n    }\n  };\n  \n  return (\n    <div className=\"app\">\n      <nav>\n        <button onClick={() => setCurrentTab('dashboard')}>Dashboard</button>\n        <button onClick={() => setCurrentTab('analytics')}>Analytics</button>\n        <button onClick={() => setCurrentTab('reports')}>Reports</button>\n        <button onClick={() => setCurrentTab('settings')}>Settings</button>\n        <button onClick={() => setCurrentTab('profile')}>Profile</button>\n      </nav>\n      \n      <main>\n        <Suspense fallback={\n          <div className=\"loading-overlay\">\n            <div className=\"spinner\"></div>\n            <p>Loading component...</p>\n          </div>\n        }>\n          {renderTab()}\n          \n          {/* Nested Suspense boundaries */}\n          <Suspense fallback={<div>Loading sidebar...</div>}>\n            <Sidebar />\n          </Suspense>\n        </Suspense>\n      </main>\n      \n      {/* Multiple Suspense boundaries */}\n      <footer>\n        <Suspense fallback={<div>Loading footer...</div>}>\n          <Footer />\n        </Suspense>\n      </footer>\n    </div>\n  );\n}\n\n// 2. Data Fetching with Suspense (Experimental)\n// Create a cache for fetched data\nconst cache = new Map();\n\nfunction fetchData(key) {\n  if (!cache.has(key)) {\n    cache.set(key, getData(key));\n  }\n  return cache.get(key);\n}\n\nasync function getData(key) {\n  // Simulate API call\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  \n  switch (key) {\n    case 'user':\n      return { name: 'John Doe', email: 'john@example.com', role: 'admin' };\n    case 'posts':\n      return [\n        { id: 1, title: 'Post 1', content: 'Content 1' },\n        { id: 2, title: 'Post 2', content: 'Content 2' },\n      ];\n    case 'stats':\n      return { visitors: 1000, revenue: 50000 };\n    default:\n      throw new Error('Invalid key');\n  }\n}\n\n// Suspense-ready component\nfunction UserProfile({ userId }) {\n  const user = fetchData(`user-${userId}`);\n  \n  // This will suspend if data is not ready\n  if (user.status === 'pending') throw user.promise;\n  if (user.status === 'error') throw user.error;\n  \n  return (\n    <div>\n      <h2>{user.value.name}</h2>\n      <p>Email: {user.value.email}</p>\n    </div>\n  );\n}\n\n// Wrapper for Suspense data fetching\nfunction DataFetchingApp() {\n  return (\n    <Suspense fallback={<div>Loading application...</div>}>\n      <div>\n        <h1>User Dashboard</h1>\n        \n        <Suspense fallback={<div>Loading user info...</div>}>\n          <UserProfile userId=\"123\" />\n        </Suspense>\n        \n        <Suspense fallback={<div>Loading posts...</div>}>\n          <UserPosts userId=\"123\" />\n        </Suspense>\n        \n        <Suspense fallback={<div>Loading statistics...</div>}>\n          <UserStats userId=\"123\" />\n        </Suspense>\n      </div>\n    </Suspense>\n  );\n}\n\n// 3. Error Boundaries with Suspense\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n  \n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n  \n  componentDidCatch(error, errorInfo) {\n    console.error('Error caught by boundary:', error, errorInfo);\n    // Log to error reporting service\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return this.props.fallback || (\n        <div className=\"error-boundary\">\n          <h2>Something went wrong</h2>\n          <p>{this.state.error?.message}</p>\n          <button onClick={() => this.setState({ hasError: false })}>\n            Try Again\n          </button>\n        </div>\n      );\n    }\n    \n    return this.props.children;\n  }\n}\n\n// Combined Error Boundary and Suspense\nfunction SafeSuspense({ children, fallback }) {\n  return (\n    <ErrorBoundary fallback={<div>Failed to load component</div>}>\n      <Suspense fallback={fallback}>\n        {children}\n      </Suspense>\n    </ErrorBoundary>\n  );\n}\n\n// 4. Concurrent Mode features with Suspense\nfunction ConcurrentApp() {\n  const [resource, setResource] = useState(null);\n  \n  const handleSearch = (query) => {\n    // Start loading new data\n    setResource(createResource(() => fetchSearchResults(query)));\n  };\n  \n  return (\n    <div>\n      <SearchBar onSearch={handleSearch} />\n      \n      {/* Show stale content while new content loads */}\n      <Suspense fallback={<div>Searching...</div>}>\n        {resource ? (\n          <SearchResults resource={resource} />\n        ) : (\n          <DefaultContent />\n        )}\n      </Suspense>\n    </div>\n  );\n}\n\n// 5. Preloading components\nfunction PreloadableFeature() {\n  const [showFeature, setShowFeature] = useState(false);\n  const [isPreloaded, setIsPreloaded] = useState(false);\n  \n  // Preload component on hover\n  const handleMouseEnter = () => {\n    if (!isPreloaded) {\n      import('./HeavyFeature').then(module => {\n        HeavyFeatureModule = module.default;\n        setIsPreloaded(true);\n      });\n    }\n  };\n  \n  let HeavyFeatureModule = null;\n  \n  return (\n    <div>\n      <button \n        onClick={() => setShowFeature(true)}\n        onMouseEnter={handleMouseEnter}\n      >\n        {showFeature ? 'Hide' : 'Show'} Heavy Feature\n      </button>\n      \n      {showFeature && (\n        <Suspense fallback={<div>Loading feature...</div>}>\n          {isPreloaded ? (\n            <HeavyFeatureModule />\n          ) : (\n            <div>Feature not loaded yet</div>\n          )}\n        </Suspense>\n      )}\n    </div>\n  );\n}\n\n// 6. SuspenseList for coordinating multiple Suspense components\n// Note: SuspenseList is experimental\nfunction SuspenseListExample() {\n  return (\n    <SuspenseList revealOrder=\"forwards\" tail=\"collapsed\">\n      <Suspense fallback={<div>Loading profile...</div>}>\n        <ProfileDetails />\n      </Suspense>\n      \n      <Suspense fallback={<div>Loading posts...</div>}>\n        <ProfileTimeline />\n      </Suspense>\n      \n      <Suspense fallback={<div>Loading followers...</div>}>\n        <ProfileFollowers />\n      </Suspense>\n    </SuspenseList>\n  );\n}\n\n// 7. Resource factory pattern for Suspense data fetching\nfunction createResource(promise) {\n  let status = 'pending';\n  let result;\n  \n  const suspender = promise.then(\n    (data) => {\n      status = 'success';\n      result = data;\n    },\n    (error) => {\n      status = 'error';\n      result = error;\n    }\n  );\n  \n  return {\n    read() {\n      if (status === 'pending') {\n        throw suspender;\n      }\n      if (status === 'error') {\n        throw result;\n      }\n      return result;\n    }\n  };\n}\n\nfunction UserData({ userId }) {\n  const resource = useMemo(() => \n    createResource(fetchUserData(userId)),\n    [userId]\n  );\n  \n  const user = resource.read();\n  \n  return (\n    <div>\n      <h2>{user.name}</h2>\n      {/* Render user data */}\n    </div>\n  );\n}",
                        "components": [
                            {
                                "name": "React.lazy()",
                                "english": "Function for code splitting components",
                                "hinglish": "Code splitting components ke liye function",
                                "importance": "Reduces initial bundle size",
                                "tip": "Only works with default exports by default"
                            },
                            {
                                "name": "Suspense Component",
                                "english": "Wrapper that shows fallback while loading",
                                "hinglish": "Wrapper jo loading ke time fallback show karta hai",
                                "importance": "Better loading states UX",
                                "tip": "Can nest multiple Suspense boundaries"
                            },
                            {
                                "name": "Error Boundaries",
                                "english": "Catch JavaScript errors in child tree",
                                "hinglish": "Child tree mein JavaScript errors catch karta hai",
                                "importance": "Prevents entire app crash",
                                "tip": "Use with Suspense for complete error handling"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Approach",
                                "Bundle Impact",
                                "When to Use"
                            ],
                            "rows": [
                                [
                                    "No Splitting",
                                    "Large initial bundle",
                                    "Small apps, landing pages"
                                ],
                                [
                                    "Route-based",
                                    "Split by routes",
                                    "Multi-page applications"
                                ],
                                [
                                    "Component-based",
                                    "Fine-grained splitting",
                                    "Large apps with heavy components"
                                ],
                                [
                                    "Prefetching",
                                    "Predictive loading",
                                    "User interaction prediction"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Use Suspense with Error Boundaries",
                                "reason": "Handle both loading and error states",
                                "hinglish": "Loading aur error states dono handle karo"
                            },
                            {
                                "practice": "Place Suspense boundaries strategically",
                                "reason": "Balance between granularity and complexity",
                                "hinglish": "Granularity aur complexity ke beech balance rakho"
                            },
                            {
                                "practice": "Preload important components",
                                "reason": "Better perceived performance",
                                "hinglish": "Better perceived performance ke liye"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Suspense without Error Boundary",
                                "solution": "Always wrap Suspense with Error Boundary",
                                "hinglish": "Suspense ko hamesha Error Boundary se wrap karo"
                            },
                            {
                                "mistake": "Too many Suspense boundaries",
                                "solution": "Group related components together",
                                "hinglish": "Related components ko group karo"
                            }
                        ]
                    }
                },
                {
                    "id": 20,
                    "title": "React Server Components (RSC)",
                    "english": "Server Components render on the server, sending minimal JavaScript to client, enabling zero-bundle-size components and direct data access.",
                    "hinglish": "Server Components server par render hote hain, client ko minimal JavaScript bhejte hain, zero-bundle-size components aur direct data access enable karte hain.",
                    "examples": [
                        "// Server Component\nasync function ProductPage({ productId }) {\n  const product = await db.products.find(productId);\n  return <ProductDetails product={product} />;\n}",
                        "// .server.js extension indicates server component"
                    ],
                    "practice": [
                        {
                            "question": "What are Server Components?",
                            "answer": "Components that render exclusively on server, no JavaScript sent to client"
                        },
                        {
                            "question": "Benefits of Server Components?",
                            "answer": "1. Zero bundle size 2. Direct database access 3. Automatic code splitting"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// 1. Basic Server Component (.server.js)\n// app/products/[id]/page.server.js\nimport { db } from '@/lib/database';\nimport ProductDetails from '@/components/ProductDetails';\nimport ProductReviews from '@/components/ProductReviews.client';\nimport AddToCart from '@/components/AddToCart.client';\n\nexport default async function ProductPage({ params }) {\n  // Direct database access - no API needed!\n  const product = await db.products.findUnique({\n    where: { id: params.id },\n    include: { category: true, brand: true }\n  });\n  \n  // Fetch related data\n  const relatedProducts = await db.products.findMany({\n    where: { \n      categoryId: product.categoryId,\n      NOT: { id: product.id }\n    },\n    take: 4\n  });\n  \n  // Server-side only code (never sent to client)\n  const pageViews = await incrementPageView(product.id);\n  \n  if (!product) {\n    return <div>Product not found</div>;\n  }\n  \n  return (\n    <div className=\"product-page\">\n      {/* Server Component */}\n      <ProductDetails product={product} />\n      \n      {/* Client Component for interactivity */}\n      <AddToCart productId={product.id} />\n      \n      {/* Another Server Component */}\n      <ProductSpecifications \n        specs={product.specifications} \n      />\n      \n      {/* Client Component with state */}\n      <ProductReviews productId={product.id} />\n      \n      {/* Server Component with async data */}\n      <RelatedProducts products={relatedProducts} />\n      \n      {/* Static content - no JavaScript */}\n      <footer>\n        <p>Page views: {pageViews}</p>\n        <p>Last updated: {new Date().toLocaleDateString()}</p>\n      </footer>\n    </div>\n  );\n}\n\n// 2. Server Component with Streaming\n// app/dashboard/page.server.js\nexport default async function DashboardPage() {\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      \n      {/* Stream multiple data sources */}\n      <Suspense fallback={<div>Loading stats...</div>}>\n        <DashboardStats />\n      </Suspense>\n      \n      <Suspense fallback={<div>Loading recent activity...</div>}>\n        <RecentActivity />\n      </Suspense>\n      \n      <Suspense fallback={<div>Loading notifications...</div>}>\n        <Notifications />\n      </Suspense>\n    </div>\n  );\n}\n\nasync function DashboardStats() {\n  // Simulate slow API call\n  await new Promise(resolve => setTimeout(resolve, 2000));\n  \n  const stats = await db.$queryRaw`\n    SELECT \n      COUNT(*) as total_users,\n      SUM(revenue) as total_revenue,\n      AVG(order_value) as avg_order\n    FROM analytics\n    WHERE date >= NOW() - INTERVAL '30 days'\n  `;\n  \n  return (\n    <div className=\"stats-grid\">\n      <StatCard title=\"Total Users\" value={stats[0].total_users} />\n      <StatCard title=\"Revenue\" value={`$${stats[0].total_revenue}`} />\n      <StatCard title=\"Avg Order\" value={`$${stats[0].avg_order}`} />\n    </div>\n  );\n}\n\n// 3. Client Component (.client.js)\n// components/AddToCart.client.js\n'use client';\n\nimport { useState } from 'react';\n\nexport default function AddToCart({ productId }) {\n  const [quantity, setQuantity] = useState(1);\n  const [isAdding, setIsAdding] = useState(false);\n  \n  const handleAddToCart = async () => {\n    setIsAdding(true);\n    try {\n      await fetch('/api/cart', {\n        method: 'POST',\n        body: JSON.stringify({ productId, quantity })\n      });\n      alert('Added to cart!');\n    } catch (error) {\n      alert('Failed to add to cart');\n    } finally {\n      setIsAdding(false);\n    }\n  };\n  \n  return (\n    <div className=\"add-to-cart\">\n      <div className=\"quantity-selector\">\n        <button onClick={() => setQuantity(q => Math.max(1, q - 1))}>\n          -\n        </button>\n        <span>{quantity}</span>\n        <button onClick={() => setQuantity(q => q + 1)}>\n          +\n        </button>\n      </div>\n      \n      <button \n        onClick={handleAddToCart}\n        disabled={isAdding}\n        className=\"add-button\"\n      >\n        {isAdding ? 'Adding...' : 'Add to Cart'}\n      </button>\n    </div>\n  );\n}\n\n// 4. Shared Component (works on both server and client)\n// components/ProductDetails.js\nexport default function ProductDetails({ product }) {\n  // This component renders on server, HTML sent to client\n  // No useState, useEffect, or event handlers here\n  \n  return (\n    <div className=\"product-details\">\n      <h1>{product.name}</h1>\n      <p className=\"price\">${product.price}</p>\n      <p className=\"description\">{product.description}</p>\n      \n      {/* Static images - no lazy loading needed */}\n      <div className=\"gallery\">\n        {product.images.map((image, index) => (\n          <img \n            key={index}\n            src={image.url}\n            alt={image.alt || product.name}\n            width=\"300\"\n            height=\"300\"\n          />\n        ))}\n      </div>\n      \n      {/* SEO-friendly content */}\n      <div className=\"seo-content\">\n        <h2>About this product</h2>\n        <div dangerouslySetInnerHTML={{ __html: product.longDescription }} />\n      </div>\n    </div>\n  );\n}\n\n// 5. Server Component with Authentication\n// app/admin/dashboard/page.server.js\nimport { getSession } from '@/lib/auth';\n\nexport default async function AdminDashboard() {\n  // Check auth on server\n  const session = await getSession();\n  \n  if (!session || session.user.role !== 'admin') {\n    return (\n      <div>\n        <h1>Access Denied</h1>\n        <p>You need admin privileges to view this page.</p>\n      </div>\n    );\n  }\n  \n  // Fetch admin-only data\n  const sensitiveData = await db.sensitive.findMany({\n    where: { companyId: session.user.companyId }\n  });\n  \n  return (\n    <div>\n      <h1>Admin Dashboard</h1>\n      <p>Welcome, {session.user.name}</p>\n      \n      {/* Sensitive data stays on server */}\n      <SensitiveDataTable data={sensitiveData} />\n    </div>\n  );\n}\n\n// 6. Server Action (React 19+)\n// app/products/[id]/actions.server.js\n'use server';\n\nimport { revalidatePath } from 'next/cache';\nimport { db } from '@/lib/database';\n\nexport async function updateProductPrice(productId, newPrice) {\n  // Server-side validation\n  if (newPrice <= 0) {\n    throw new Error('Price must be positive');\n  }\n  \n  // Update database\n  await db.products.update({\n    where: { id: productId },\n    data: { price: newPrice }\n  });\n  \n  // Revalidate cache\n  revalidatePath(`/products/${productId}`);\n  revalidatePath('/products');\n  \n  return { success: true };\n}\n\n// 7. Dynamic Metadata in Server Components\n// app/products/[id]/page.server.js\nexport async function generateMetadata({ params }) {\n  const product = await db.products.findUnique({\n    where: { id: params.id },\n    select: { name: true, description: true, images: true }\n  });\n  \n  return {\n    title: product.name,\n    description: product.description,\n    openGraph: {\n      images: product.images.map(img => img.url),\n    },\n  };\n}\n\n// 8. Streaming with Suspense\n// app/blog/[slug]/page.server.js\nexport default async function BlogPost({ params }) {\n  const postPromise = db.posts.findUnique({\n    where: { slug: params.slug }\n  });\n  \n  const commentsPromise = db.comments.findMany({\n    where: { postSlug: params.slug },\n    orderBy: { createdAt: 'desc' }\n  });\n  \n  return (\n    <article>\n      <Suspense fallback={<PostSkeleton />}>\n        <PostContent postPromise={postPromise} />\n      </Suspense>\n      \n      <Suspense fallback={<CommentsSkeleton />}>\n        <PostComments commentsPromise={commentsPromise} />\n      </Suspense>\n    </article>\n  );\n}\n\nasync function PostContent({ postPromise }) {\n  const post = await postPromise;\n  \n  return (\n    <div>\n      <h1>{post.title}</h1>\n      <div dangerouslySetInnerHTML={{ __html: post.content }} />\n    </div>\n  );\n}\n\n// 9. Error Handling in Server Components\n// app/checkout/page.server.js\nexport default async function CheckoutPage() {\n  try {\n    const cart = await getCart();\n    const shippingOptions = await getShippingOptions();\n    \n    if (cart.items.length === 0) {\n      return <EmptyCart />;\n    }\n    \n    return (\n      <div>\n        <CartSummary cart={cart} />\n        <ShippingOptions options={shippingOptions} />\n        <PaymentForm />\n      </div>\n    );\n  } catch (error) {\n    // Handle errors on server\n    console.error('Checkout error:', error);\n    \n    return (\n      <ErrorPage \n        message=\"Failed to load checkout\"\n        retryLink=\"/cart\"\n      />\n    );\n  }\n}\n\n// 10. Performance Comparison\nfunction PerformanceDemo() {\n  return (\n    <div>\n      <h2>Traditional SPA (Client-side)</h2>\n      <ul>\n        <li>Bundle: 150KB JavaScript</li>\n        <li>Time to Interactive: 2.5s</li>\n        <li>SEO: Needs SSR</li>\n      </ul>\n      \n      <h2>Server Components</h2>\n      <ul>\n        <li>Bundle: 10KB JavaScript (just interactivity)</li>\n        <li>Time to Interactive: 0.8s</li>\n        <li>SEO: Perfect out of the box</li>\n        <li>Database: Direct access, no API layer</li>\n      </ul>\n    </div>\n  );\n}\n\n// Helper functions\nasync function incrementPageView(productId) {\n  await db.analytics.upsert({\n    where: { productId },\n    update: { views: { increment: 1 } },\n    create: { productId, views: 1 }\n  });\n  \n  const record = await db.analytics.findUnique({\n    where: { productId }\n  });\n  \n  return record.views;\n}",
                        "components": [
                            {
                                "name": "Server Components",
                                "english": "Render exclusively on server, zero JS bundle",
                                "hinglish": "Server par exclusively render hote hain, zero JS bundle",
                                "importance": "Performance, SEO, direct data access",
                                "tip": "Use for data fetching, static content"
                            },
                            {
                                "name": "Client Components",
                                "english": "Render on client with interactivity",
                                "hinglish": "Client par render hote hain interactivity ke saath",
                                "importance": "Interactive features, state, effects",
                                "tip": "Mark with 'use client' directive"
                            },
                            {
                                "name": "Shared Components",
                                "english": "Render on both server and client",
                                "hinglish": "Server aur client dono par render hote hain",
                                "importance": "Reusable presentational components",
                                "tip": "No hooks or browser APIs"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Component Type",
                                "Renders On",
                                "Can Use"
                            ],
                            "rows": [
                                [
                                    "Server Component",
                                    "Server only",
                                    "Async/await, DB, filesystem"
                                ],
                                [
                                    "Client Component",
                                    "Client only",
                                    "useState, useEffect, browser APIs"
                                ],
                                [
                                    "Shared Component",
                                    "Both",
                                    "Props, basic JSX, no hooks"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Keep Server Components near data source",
                                "reason": "Minimize data fetching layers",
                                "hinglish": "Data fetching layers minimize karo"
                            },
                            {
                                "practice": "Use Client Components only for interactivity",
                                "reason": "Minimize bundle size",
                                "hinglish": "Bundle size minimize karo"
                            },
                            {
                                "practice": "Stream slow data with Suspense",
                                "reason": "Better perceived performance",
                                "hinglish": "Better perceived performance ke liye"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Using hooks in Server Components",
                                "solution": "Move state/effects to Client Components",
                                "hinglish": "State/effects Client Components mein move karo"
                            },
                            {
                                "mistake": "Not marking Client Components",
                                "solution": "Add 'use client' at top of file",
                                "hinglish": "File ke top par 'use client' add karo"
                            }
                        ]
                    }
                },
                {
                    "id": 21,
                    "title": "Custom Hooks for Reusable Logic",
                    "english": "Custom hooks extract component logic into reusable functions, following the same rules as built-in hooks.",
                    "hinglish": "Custom hooks component logic ko reusable functions mein extract karte hain, built-in hooks jaise hi rules follow karte hain.",
                    "examples": [
                        "function useLocalStorage(key, initialValue) {\n  const [value, setValue] = useState(() => {\n    const stored = localStorage.getItem(key);\n    return stored ? JSON.parse(stored) : initialValue;\n  });\n  \n  useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value));\n  }, [key, value]);\n  \n  return [value, setValue];\n}",
                        "const { data, loading, error } = useFetch('/api/data');"
                    ],
                    "practice": [
                        {
                            "question": "What rules must custom hooks follow?",
                            "answer": "1. Name must start with 'use' 2. Only call hooks at top level 3. Only call from React functions"
                        },
                        {
                            "question": "When should you create a custom hook?",
                            "answer": "When you have logic that's used in multiple components"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// 1. Data Fetching Hook\nfunction useFetch(url, options = {}) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    let isMounted = true;\n    \n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch(url, options);\n        \n        if (!response.ok) {\n          throw new Error(`HTTP ${response.status}`);\n        }\n        \n        const result = await response.json();\n        \n        if (isMounted) {\n          setData(result);\n          setError(null);\n        }\n      } catch (err) {\n        if (isMounted) {\n          setError(err.message);\n          setData(null);\n        }\n      } finally {\n        if (isMounted) {\n          setLoading(false);\n        }\n      }\n    };\n    \n    fetchData();\n    \n    return () => {\n      isMounted = false;\n    };\n  }, [url, JSON.stringify(options)]);\n  \n  const refetch = useCallback(() => {\n    // Trigger re-fetch\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch(url, options);\n        const result = await response.json();\n        setData(result);\n        setError(null);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    fetchData();\n  }, [url, options]);\n  \n  return { data, loading, error, refetch };\n}\n\n// 2. Local Storage Hook\nfunction useLocalStorage(key, initialValue) {\n  // Get from localStorage initially\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(error);\n      return initialValue;\n    }\n  });\n  \n  // Update localStorage when value changes\n  const setValue = useCallback((value) => {\n    try {\n      // Allow value to be a function like useState\n      const valueToStore = value instanceof Function \n        ? value(storedValue) \n        : value;\n      \n      setStoredValue(valueToStore);\n      \n      // Save to localStorage\n      if (typeof window !== 'undefined') {\n        window.localStorage.setItem(key, JSON.stringify(valueToStore));\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  }, [key, storedValue]);\n  \n  // Clear value from localStorage\n  const clearValue = useCallback(() => {\n    try {\n      setStoredValue(initialValue);\n      window.localStorage.removeItem(key);\n    } catch (error) {\n      console.error(error);\n    }\n  }, [initialValue, key]);\n  \n  return [storedValue, setValue, clearValue];\n}\n\n// 3. Window Size Hook\nfunction useWindowSize() {\n  const [windowSize, setWindowSize] = useState({\n    width: typeof window !== 'undefined' ? window.innerWidth : 0,\n    height: typeof window !== 'undefined' ? window.innerHeight : 0,\n  });\n  \n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n    \n    const handleResize = () => {\n      setWindowSize({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    };\n    \n    window.addEventListener('resize', handleResize);\n    \n    // Call handler right away to update with initial window size\n    handleResize();\n    \n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n  \n  return windowSize;\n}\n\n// 4. Media Query Hook\nfunction useMediaQuery(query) {\n  const [matches, setMatches] = useState(false);\n  \n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n    \n    const media = window.matchMedia(query);\n    \n    // Update state initially\n    setMatches(media.matches);\n    \n    // Create event listener\n    const listener = (event) => {\n      setMatches(event.matches);\n    };\n    \n    // Add listener\n    media.addEventListener('change', listener);\n    \n    return () => {\n      media.removeEventListener('change', listener);\n    };\n  }, [query]);\n  \n  return matches;\n}\n\n// 5. Previous Value Hook\nfunction usePrevious(value) {\n  const ref = useRef();\n  \n  useEffect(() => {\n    ref.current = value;\n  });\n  \n  return ref.current;\n}\n\n// 6. Debounce Hook\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  \n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    \n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n  \n  return debouncedValue;\n}\n\n// 7. Online Status Hook\nfunction useOnlineStatus() {\n  const [isOnline, setIsOnline] = useState(\n    typeof window !== 'undefined' ? window.navigator.onLine : true\n  );\n  \n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n    \n    const handleOnline = () => setIsOnline(true);\n    const handleOffline = () => setIsOnline(false);\n    \n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n    \n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n  \n  return isOnline;\n}\n\n// 8. Click Outside Hook\nfunction useClickOutside(ref, callback) {\n  useEffect(() => {\n    const handleClickOutside = (event) => {\n      if (ref.current && !ref.current.contains(event.target)) {\n        callback(event);\n      }\n    };\n    \n    document.addEventListener('mousedown', handleClickOutside);\n    \n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, [ref, callback]);\n}\n\n// 9. Form Hook\nfunction useForm(initialValues = {}, validate) {\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  \n  const handleChange = useCallback((name, value) => {\n    setValues(prev => ({ ...prev, [name]: value }));\n    \n    // Clear error when user types\n    if (errors[name]) {\n      setErrors(prev => ({ ...prev, [name]: '' }));\n    }\n  }, [errors]);\n  \n  const handleBlur = useCallback((name) => {\n    setTouched(prev => ({ ...prev, [name]: true }));\n    \n    // Validate on blur if validate function provided\n    if (validate) {\n      const error = validate(name, values[name]);\n      if (error) {\n        setErrors(prev => ({ ...prev, [name]: error }));\n      }\n    }\n  }, [validate, values]);\n  \n  const handleSubmit = useCallback((onSubmit) => async (event) => {\n    event.preventDefault();\n    setIsSubmitting(true);\n    \n    // Validate all fields\n    if (validate) {\n      const newErrors = {};\n      Object.keys(values).forEach(key => {\n        const error = validate(key, values[key]);\n        if (error) newErrors[key] = error;\n      });\n      \n      setErrors(newErrors);\n      setTouched(Object.keys(values).reduce((acc, key) => ({\n        ...acc, [key]: true\n      }), {}));\n      \n      if (Object.keys(newErrors).length > 0) {\n        setIsSubmitting(false);\n        return;\n      }\n    }\n    \n    try {\n      await onSubmit(values);\n    } catch (error) {\n      console.error('Form submission error:', error);\n    } finally {\n      setIsSubmitting(false);\n    }\n  }, [validate, values]);\n  \n  const reset = useCallback(() => {\n    setValues(initialValues);\n    setErrors({});\n    setTouched({});\n    setIsSubmitting(false);\n  }, [initialValues]);\n  \n  return {\n    values,\n    errors,\n    touched,\n    isSubmitting,\n    handleChange,\n    handleBlur,\n    handleSubmit,\n    reset,\n    setValues,\n    isValid: Object.keys(errors).every(key => !errors[key])\n  };\n}\n\n// 10. Authentication Hook\nfunction useAuth() {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    const checkAuth = async () => {\n      try {\n        const token = localStorage.getItem('token');\n        \n        if (!token) {\n          setUser(null);\n          return;\n        }\n        \n        // Verify token\n        const response = await fetch('/api/auth/verify', {\n          headers: { Authorization: `Bearer ${token}` }\n        });\n        \n        if (response.ok) {\n          const userData = await response.json();\n          setUser(userData);\n        } else {\n          localStorage.removeItem('token');\n          setUser(null);\n        }\n      } catch (err) {\n        setError(err.message);\n        setUser(null);\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    checkAuth();\n  }, []);\n  \n  const login = useCallback(async (credentials) => {\n    try {\n      setLoading(true);\n      const response = await fetch('/api/auth/login', {\n        method: 'POST',\n        body: JSON.stringify(credentials)\n      });\n      \n      if (!response.ok) {\n        throw new Error('Login failed');\n      }\n      \n      const { token, user } = await response.json();\n      localStorage.setItem('token', token);\n      setUser(user);\n      setError(null);\n      return user;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n  \n  const logout = useCallback(() => {\n    localStorage.removeItem('token');\n    setUser(null);\n  }, []);\n  \n  return { user, loading, error, login, logout };\n}\n\n// 11. Infinite Scroll Hook\nfunction useInfiniteScroll(fetchMore, hasMore, threshold = 100) {\n  const [isFetching, setIsFetching] = useState(false);\n  \n  useEffect(() => {\n    if (!hasMore || isFetching) return;\n    \n    const handleScroll = () => {\n      const { scrollTop, scrollHeight, clientHeight } = document.documentElement;\n      \n      if (scrollHeight - scrollTop - clientHeight < threshold) {\n        setIsFetching(true);\n        fetchMore().finally(() => setIsFetching(false));\n      }\n    };\n    \n    window.addEventListener('scroll', handleScroll);\n    \n    return () => window.removeEventListener('scroll', handleScroll);\n  }, [hasMore, isFetching, fetchMore, threshold]);\n  \n  return isFetching;\n}\n\n// 12. Keyboard Shortcut Hook\nfunction useKeyPress(targetKey, callback, options = {}) {\n  const { ctrlKey = false, altKey = false, shiftKey = false } = options;\n  \n  useEffect(() => {\n    const handleKeyDown = (event) => {\n      if (\n        event.key === targetKey &&\n        event.ctrlKey === ctrlKey &&\n        event.altKey === altKey &&\n        event.shiftKey === shiftKey\n      ) {\n        event.preventDefault();\n        callback(event);\n      }\n    };\n    \n    window.addEventListener('keydown', handleKeyDown);\n    \n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [targetKey, callback, ctrlKey, altKey, shiftKey]);\n}\n\n// Usage Examples\nfunction App() {\n  // Using custom hooks\n  const { data: posts, loading, error } = useFetch('/api/posts');\n  const [theme, setTheme] = useLocalStorage('theme', 'light');\n  const { width } = useWindowSize();\n  const isMobile = useMediaQuery('(max-width: 768px)');\n  const prevTheme = usePrevious(theme);\n  const isOnline = useOnlineStatus();\n  const { user, login, logout } = useAuth();\n  \n  // Form example\n  const form = useForm({\n    email: '',\n    password: '',\n    remember: false\n  }, (name, value) => {\n    // Validation\n    if (name === 'email' && !value.includes('@')) {\n      return 'Invalid email';\n    }\n    if (name === 'password' && value.length < 6) {\n      return 'Password too short';\n    }\n    return '';\n  });\n  \n  return (\n    <div className={`app ${theme}`}>\n      <header>\n        <button onClick={() => setTheme(t => t === 'light' ? 'dark' : 'light')}>\n          Toggle Theme\n        </button>\n        \n        {!isOnline && (\n          <div className=\"offline-banner\">\n            You're offline. Some features may not work.\n          </div>\n        )}\n        \n        <p>Window width: {width}px</p>\n        <p>Previous theme: {prevTheme}</p>\n      </header>\n      \n      <main>\n        {loading ? (\n          <div>Loading...</div>\n        ) : error ? (\n          <div>Error: {error}</div>\n        ) : (\n          <div>\n            <h1>Posts</h1>\n            {posts.map(post => (\n              <div key={post.id}>{post.title}</div>\n            ))}\n          </div>\n        )}\n        \n        {/* Form using custom hook */}\n        <form onSubmit={form.handleSubmit(async (values) => {\n          console.log('Submitting:', values);\n        })}>\n          <input\n            name=\"email\"\n            value={form.values.email}\n            onChange={(e) => form.handleChange('email', e.target.value)}\n            onBlur={() => form.handleBlur('email')}\n          />\n          {form.errors.email && form.touched.email && (\n            <span>{form.errors.email}</span>\n          )}\n          \n          <input\n            type=\"password\"\n            name=\"password\"\n            value={form.values.password}\n            onChange={(e) => form.handleChange('password', e.target.value)}\n            onBlur={() => form.handleBlur('password')}\n          />\n          \n          <button type=\"submit\" disabled={form.isSubmitting || !form.isValid}>\n            {form.isSubmitting ? 'Submitting...' : 'Submit'}\n          </button>\n        </form>\n        \n        {/* Auth example */}\n        {user ? (\n          <div>\n            <p>Welcome, {user.name}!</p>\n            <button onClick={logout}>Logout</button>\n          </div>\n        ) : (\n          <button onClick={() => login({ email: 'test@example.com', password: 'password' })}>\n            Login\n          </button>\n        )}\n      </main>\n    </div>\n  );\n}",
                        "components": [
                            {
                                "name": "Hook Naming Convention",
                                "english": "Must start with 'use' prefix",
                                "hinglish": "'use' prefix se start hona chahiye",
                                "importance": "React identifies them as hooks",
                                "tip": "Always use 'use' followed by descriptive name"
                            },
                            {
                                "name": "Hook Composition",
                                "english": "Compose multiple hooks together",
                                "hinglish": "Multiple hooks ek saath compose karo",
                                "importance": "Build complex logic from simple hooks",
                                "tip": "Custom hooks can use other custom hooks"
                            },
                            {
                                "name": "Hook Return Value",
                                "english": "Return values for component use",
                                "hinglish": "Component use ke liye values return karo",
                                "importance": "Interface between hook and component",
                                "tip": "Return array or object based on use case"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Hook Type",
                                "Returns",
                                "Example"
                            ],
                            "rows": [
                                [
                                    "State Hook",
                                    "Value + setter",
                                    "useLocalStorage"
                                ],
                                [
                                    "Effect Hook",
                                    "Side effects",
                                    "useWindowSize"
                                ],
                                [
                                    "Utility Hook",
                                    "Computed value",
                                    "useDebounce"
                                ],
                                [
                                    "Complex Hook",
                                    "Multiple values",
                                    "useForm"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Keep hooks focused and single-purpose",
                                "reason": "Better reusability and testing",
                                "hinglish": "Better reusability aur testing ke liye"
                            },
                            {
                                "practice": "Add proper TypeScript types",
                                "reason": "Better developer experience",
                                "hinglish": "Better developer experience ke liye"
                            },
                            {
                                "practice": "Handle edge cases and errors",
                                "reason": "Robust hooks work in all scenarios",
                                "hinglish": "Robust hooks saare scenarios mein kaam kare"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Violating Rules of Hooks",
                                "solution": "Always call hooks at top level",
                                "hinglish": "Hooks hamesha top level par call karo"
                            },
                            {
                                "mistake": "Not handling SSR",
                                "solution": "Check for window/document existence",
                                "hinglish": "Window/document existence check karo"
                            }
                        ]
                    }
                },
                {
                    "id": 22,
                    "title": "Compound Components Pattern",
                    "english": "Compound components are components that work together as a group, sharing implicit state while maintaining separate visual representations.",
                    "hinglish": "Compound components wo components hain jo ek group ki tarah kaam karte hain, implicit state share karte hain lekin alag visual representations maintain karte hain.",
                    "examples": [
                        "<Select>\n  <Select.Option value=\"1\">Option 1</Select.Option>\n  <Select.Option value=\"2\">Option 2</Select.Option>\n</Select>",
                        "<Accordion>\n  <Accordion.Item>\n    <Accordion.Header>Title</Accordion.Header>\n    <Accordion.Content>Content</Accordion.Content>\n  </Accordion.Item>\n</Accordion>"
                    ],
                    "practice": [
                        {
                            "question": "What problem do compound components solve?",
                            "answer": "Flexible API design with implicit state sharing"
                        },
                        {
                            "question": "How do compound components share state?",
                            "answer": "Using React Context or cloneElement"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// 1. Tabs Component\nconst TabsContext = React.createContext({});\n\nfunction Tabs({ children, defaultActiveTab }) {\n  const [activeTab, setActiveTab] = useState(defaultActiveTab);\n  \n  const contextValue = useMemo(() => ({\n    activeTab,\n    setActiveTab\n  }), [activeTab]);\n  \n  return (\n    <TabsContext.Provider value={contextValue}>\n      <div className=\"tabs\">{children}</div>\n    </TabsContext.Provider>\n  );\n}\n\nfunction TabsList({ children }) {\n  return <div className=\"tabs-list\">{children}</div>;\n}\n\nfunction Tab({ id, children, disabled = false }) {\n  const { activeTab, setActiveTab } = useContext(TabsContext);\n  \n  const isActive = activeTab === id;\n  \n  return (\n    <button\n      className={`tab ${isActive ? 'active' : ''} ${disabled ? 'disabled' : ''}`}\n      onClick={() => !disabled && setActiveTab(id)}\n      disabled={disabled}\n      role=\"tab\"\n      aria-selected={isActive}\n    >\n      {children}\n    </button>\n  );\n}\n\nfunction TabPanels({ children }) {\n  return <div className=\"tab-panels\">{children}</div>;\n}\n\nfunction TabPanel({ id, children }) {\n  const { activeTab } = useContext(TabsContext);\n  \n  if (activeTab !== id) return null;\n  \n  return (\n    <div \n      className=\"tab-panel\"\n      role=\"tabpanel\"\n      aria-labelledby={`tab-${id}`}\n    >\n      {children}\n    </div>\n  );\n}\n\n// Attach subcomponents\nTabs.List = TabsList;\nTabs.Tab = Tab;\nTabs.Panels = TabPanels;\nTabs.Panel = TabPanel;\n\n// Usage\nfunction App() {\n  return (\n    <Tabs defaultActiveTab=\"tab1\">\n      <Tabs.List>\n        <Tabs.Tab id=\"tab1\">Tab 1</Tabs.Tab>\n        <Tabs.Tab id=\"tab2\">Tab 2</Tabs.Tab>\n        <Tabs.Tab id=\"tab3\" disabled>Disabled Tab</Tabs.Tab>\n      </Tabs.List>\n      \n      <Tabs.Panels>\n        <Tabs.Panel id=\"tab1\">\n          <h2>Content for Tab 1</h2>\n          <p>This is the first tab content.</p>\n        </Tabs.Panel>\n        \n        <Tabs.Panel id=\"tab2\">\n          <h2>Content for Tab 2</h2>\n          <p>This is the second tab content.</p>\n        </Tabs.Panel>\n        \n        <Tabs.Panel id=\"tab3\">\n          <h2>Content for Tab 3</h2>\n          <p>This tab is disabled.</p>\n        </Tabs.Panel>\n      </Tabs.Panels>\n    </Tabs>\n  );\n}\n\n// 2. Accordion Component\nconst AccordionContext = React.createContext({});\n\nfunction Accordion({ children, multiple = false }) {\n  const [openItems, setOpenItems] = useState([]);\n  \n  const toggleItem = useCallback((itemId) => {\n    setOpenItems(prev => {\n      if (multiple) {\n        return prev.includes(itemId)\n          ? prev.filter(id => id !== itemId)\n          : [...prev, itemId];\n      } else {\n        return prev.includes(itemId) ? [] : [itemId];\n      }\n    });\n  }, [multiple]);\n  \n  const contextValue = useMemo(() => ({\n    openItems,\n    toggleItem\n  }), [openItems, toggleItem]);\n  \n  return (\n    <AccordionContext.Provider value={contextValue}>\n      <div className=\"accordion\">{children}</div>\n    </AccordionContext.Provider>\n  );\n}\n\nfunction AccordionItem({ id, children }) {\n  const { openItems } = useContext(AccordionContext);\n  const isOpen = openItems.includes(id);\n  \n  return (\n    <div className={`accordion-item ${isOpen ? 'open' : ''}`}>\n      {React.Children.map(children, child =>\n        React.cloneElement(child, { itemId: id, isOpen })\n      )}\n    </div>\n  );\n}\n\nfunction AccordionHeader({ children, itemId, isOpen }) {\n  const { toggleItem } = useContext(AccordionContext);\n  \n  return (\n    <button \n      className=\"accordion-header\"\n      onClick={() => toggleItem(itemId)}\n      aria-expanded={isOpen}\n    >\n      {children}\n      <span className=\"accordion-icon\">\n        {isOpen ? '' : ''}\n      </span>\n    </button>\n  );\n}\n\nfunction AccordionContent({ children, isOpen }) {\n  if (!isOpen) return null;\n  \n  return (\n    <div className=\"accordion-content\">\n      {children}\n    </div>\n  );\n}\n\n// Attach subcomponents\nAccordion.Item = AccordionItem;\nAccordion.Header = AccordionHeader;\nAccordion.Content = AccordionContent;\n\n// Usage\nfunction FaqSection() {\n  return (\n    <Accordion>\n      <Accordion.Item id=\"faq1\">\n        <Accordion.Header>\n          What is React?\n        </Accordion.Header>\n        <Accordion.Content>\n          React is a JavaScript library for building user interfaces.\n        </Accordion.Content>\n      </Accordion.Item>\n      \n      <Accordion.Item id=\"faq2\">\n        <Accordion.Header>\n          What are compound components?\n        </Accordion.Header>\n        <Accordion.Content>\n          Compound components are components that work together as a group.\n        </Accordion.Content>\n      </Accordion.Item>\n    </Accordion>\n  );\n}\n\n// 3. Select Component\nconst SelectContext = React.createContext({});\n\nfunction Select({ children, value, onChange, disabled = false }) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [search, setSearch] = useState('');\n  \n  const contextValue = useMemo(() => ({\n    value,\n    onChange,\n    isOpen,\n    setIsOpen,\n    search,\n    setSearch,\n    disabled\n  }), [value, onChange, isOpen, search, disabled]);\n  \n  return (\n    <SelectContext.Provider value={contextValue}>\n      <div className=\"select-wrapper\">{children}</div>\n    </SelectContext.Provider>\n  );\n}\n\nfunction SelectTrigger({ placeholder = 'Select...' }) {\n  const { value, isOpen, setIsOpen, disabled } = useContext(SelectContext);\n  \n  return (\n    <button \n      className=\"select-trigger\"\n      onClick={() => !disabled && setIsOpen(!isOpen)}\n      disabled={disabled}\n    >\n      <span>{value || placeholder}</span>\n      <span className=\"arrow\">{isOpen ? '' : ''}</span>\n    </button>\n  );\n}\n\nfunction SelectValue({ children }) {\n  const { value } = useContext(SelectContext);\n  \n  return (\n    <span className=\"select-value\">\n      {value ? children(value) : 'No value selected'}\n    </span>\n  );\n}\n\nfunction SelectSearch() {\n  const { search, setSearch } = useContext(SelectContext);\n  \n  return (\n    <input\n      type=\"text\"\n      className=\"select-search\"\n      value={search}\n      onChange={(e) => setSearch(e.target.value)}\n      placeholder=\"Search...\"\n    />\n  );\n}\n\nfunction SelectContent({ children }) {\n  const { isOpen } = useContext(SelectContext);\n  \n  if (!isOpen) return null;\n  \n  return (\n    <div className=\"select-content\">\n      {children}\n    </div>\n  );\n}\n\nfunction SelectOption({ value, children }) {\n  const { value: selectedValue, onChange, setIsOpen } = useContext(SelectContext);\n  \n  const isSelected = selectedValue === value;\n  \n  return (\n    <div\n      className={`select-option ${isSelected ? 'selected' : ''}`}\n      onClick={() => {\n        onChange(value);\n        setIsOpen(false);\n      }}\n    >\n      {children}\n      {isSelected && <span className=\"check\"></span>}\n    </div>\n  );\n}\n\n// Attach subcomponents\nSelect.Trigger = SelectTrigger;\nSelect.Value = SelectValue;\nSelect.Search = SelectSearch;\nSelect.Content = SelectContent;\nSelect.Option = SelectOption;\n\n// Usage\nfunction CountrySelect() {\n  const [country, setCountry] = useState('');\n  \n  return (\n    <Select value={country} onChange={setCountry}>\n      <Select.Trigger placeholder=\"Select a country\" />\n      \n      <Select.Content>\n        <Select.Search />\n        \n        <Select.Option value=\"us\">United States</Select.Option>\n        <Select.Option value=\"in\">India</Select.Option>\n        <Select.Option value=\"uk\">United Kingdom</Select.Option>\n        <Select.Option value=\"ca\">Canada</Select.Option>\n        <Select.Option value=\"au\">Australia</Select.Option>\n      </Select.Content>\n      \n      <Select.Value>\n        {(value) => `Selected: ${value.toUpperCase()}`}\n      </Select.Value>\n    </Select>\n  );\n}\n\n// 4. Modal Component\nconst ModalContext = React.createContext({});\n\nfunction Modal({ children, isOpen: controlledIsOpen, onClose }) {\n  const [internalIsOpen, setInternalIsOpen] = useState(false);\n  \n  const isOpen = controlledIsOpen !== undefined ? controlledIsOpen : internalIsOpen;\n  const setIsOpen = onClose || setInternalIsOpen;\n  \n  const contextValue = useMemo(() => ({\n    isOpen,\n    setIsOpen\n  }), [isOpen, setIsOpen]);\n  \n  if (!isOpen) return null;\n  \n  return (\n    <ModalContext.Provider value={contextValue}>\n      <div className=\"modal-overlay\">\n        <div className=\"modal\">{children}</div>\n      </div>\n    </ModalContext.Provider>\n  );\n}\n\nfunction ModalTrigger({ children }) {\n  const { setIsOpen } = useContext(ModalContext);\n  \n  return React.cloneElement(children, {\n    onClick: () => setIsOpen(true)\n  });\n}\n\nfunction ModalClose({ children }) {\n  const { setIsOpen } = useContext(ModalContext);\n  \n  return React.cloneElement(children, {\n    onClick: () => setIsOpen(false)\n  });\n}\n\nfunction ModalHeader({ children }) {\n  return (\n    <div className=\"modal-header\">\n      <h2>{children}</h2>\n      <Modal.Close>\n        <button className=\"modal-close\"></button>\n      </Modal.Close>\n    </div>\n  );\n}\n\nfunction ModalContent({ children }) {\n  return <div className=\"modal-content\">{children}</div>;\n}\n\nfunction ModalFooter({ children }) {\n  return <div className=\"modal-footer\">{children}</div>;\n}\n\n// Attach subcomponents\nModal.Trigger = ModalTrigger;\nModal.Close = ModalClose;\nModal.Header = ModalHeader;\nModal.Content = ModalContent;\nModal.Footer = ModalFooter;\n\n// Usage\nfunction ProductModal() {\n  return (\n    <Modal>\n      <Modal.Trigger>\n        <button>View Product Details</button>\n      </Modal.Trigger>\n      \n      <Modal.Header>Product Information</Modal.Header>\n      \n      <Modal.Content>\n        <p>This is the product description.</p>\n        <p>Price: $99.99</p>\n      </Modal.Content>\n      \n      <Modal.Footer>\n        <button>Add to Cart</button>\n        <Modal.Close>\n          <button>Close</button>\n        </Modal.Close>\n      </Modal.Footer>\n    </Modal>\n  );\n}\n\n// 5. Form Field Component\nconst FieldContext = React.createContext({});\n\nfunction Field({ name, children }) {\n  const [value, setValue] = useState('');\n  const [touched, setTouched] = useState(false);\n  const [error, setError] = useState('');\n  \n  const contextValue = useMemo(() => ({\n    name,\n    value,\n    setValue,\n    touched,\n    setTouched,\n    error,\n    setError\n  }), [name, value, touched, error]);\n  \n  return (\n    <FieldContext.Provider value={contextValue}>\n      <div className=\"field\">{children}</div>\n    </FieldContext.Provider>\n  );\n}\n\nfunction FieldLabel({ children }) {\n  const { name } = useContext(FieldContext);\n  \n  return (\n    <label htmlFor={name} className=\"field-label\">\n      {children}\n    </label>\n  );\n}\n\nfunction FieldInput({ type = 'text', ...props }) {\n  const { name, value, setValue, setTouched, error } = useContext(FieldContext);\n  \n  return (\n    <div>\n      <input\n        id={name}\n        type={type}\n        value={value}\n        onChange={(e) => setValue(e.target.value)}\n        onBlur={() => setTouched(true)}\n        className={`field-input ${error ? 'error' : ''}`}\n        {...props}\n      />\n      {error && <span className=\"field-error\">{error}</span>}\n    </div>\n  );\n}\n\nfunction FieldError({ children }) {\n  const { error } = useContext(FieldContext);\n  \n  if (!error) return null;\n  \n  return <div className=\"field-error-message\">{children || error}</div>;\n}\n\n// Attach subcomponents\nField.Label = FieldLabel;\nField.Input = FieldInput;\nField.Error = FieldError;\n\n// Usage\nfunction UserForm() {\n  return (\n    <form>\n      <Field name=\"username\">\n        <Field.Label>Username</Field.Label>\n        <Field.Input placeholder=\"Enter username\" />\n        <Field.Error>Username is required</Field.Error>\n      </Field>\n      \n      <Field name=\"email\">\n        <Field.Label>Email</Field.Label>\n        <Field.Input type=\"email\" placeholder=\"Enter email\" />\n        <Field.Error>Valid email is required</Field.Error>\n      </Field>\n    </form>\n  );\n}",
                        "components": [
                            {
                                "name": "Context Provider",
                                "english": "Share state between compound components",
                                "hinglish": "Compound components ke beech state share karo",
                                "importance": "Implicit state management",
                                "tip": "Use React.createContext() and Provider"
                            },
                            {
                                "name": "Subcomponent Attachment",
                                "english": "Attach child components to parent",
                                "hinglish": "Child components ko parent se attach karo",
                                "importance": "Clean API for consumers",
                                "tip": "Parent.Child = ChildComponent"
                            },
                            {
                                "name": "Flexible Composition",
                                "english": "Allow various component arrangements",
                                "hinglish": "Various component arrangements allow karo",
                                "importance": "Customizable UI patterns",
                                "tip": "Don't enforce strict child order"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Pattern",
                                "State Sharing",
                                "Flexibility"
                            ],
                            "rows": [
                                [
                                    "Compound Components",
                                    "Implicit (Context)",
                                    "High"
                                ],
                                [
                                    "Render Props",
                                    "Explicit (Function args)",
                                    "Medium"
                                ],
                                [
                                    "HOCs",
                                    "Injected props",
                                    "Low"
                                ],
                                [
                                    "Single Component",
                                    "Internal state",
                                    "None"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Use Context for state sharing",
                                "reason": "Clean implicit state management",
                                "hinglish": "Clean implicit state management ke liye"
                            },
                            {
                                "practice": "Provide sensible defaults",
                                "reason": "Better developer experience",
                                "hinglish": "Better developer experience ke liye"
                            },
                            {
                                "practice": "Support controlled and uncontrolled",
                                "reason": "Maximum flexibility",
                                "hinglish": "Maximum flexibility ke liye"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Overly complex Context",
                                "solution": "Keep Context focused and simple",
                                "hinglish": "Context focused aur simple rakho"
                            },
                            {
                                "mistake": "Not handling missing subcomponents",
                                "solution": "Provide error messages or defaults",
                                "hinglish": "Error messages ya defaults provide karo"
                            }
                        ]
                    }
                },
                {
                    "id": 23,
                    "title": "Controlled vs Uncontrolled Components",
                    "english": "Controlled components have form data controlled by React state, while uncontrolled components store data in the DOM.",
                    "hinglish": "Controlled components mein form data React state se control hota hai, jabki uncontrolled components data DOM mein store karte hain.",
                    "examples": [
                        "// Controlled\n<input value={name} onChange={e => setName(e.target.value)} />",
                        "// Uncontrolled\n<input defaultValue=\"initial\" ref={inputRef} />"
                    ],
                    "practice": [
                        {
                            "question": "What's the difference between controlled and uncontrolled?",
                            "answer": "Controlled: React state manages value; Uncontrolled: DOM manages value"
                        },
                        {
                            "question": "When to use uncontrolled components?",
                            "answer": "When you need to integrate with non-React code or for simple forms"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// 1. Controlled Component Example\nfunction ControlledForm() {\n  const [formData, setFormData] = useState({\n    name: '',\n    email: '',\n    message: '',\n    subscribe: true,\n    category: 'general'\n  });\n  \n  const handleChange = (e) => {\n    const { name, value, type, checked } = e.target;\n    setFormData(prev => ({\n      ...prev,\n      [name]: type === 'checkbox' ? checked : value\n    }));\n  };\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('Form data:', formData);\n    // Form submission logic\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>Name:</label>\n        <input\n          type=\"text\"\n          name=\"name\"\n          value={formData.name}\n          onChange={handleChange}\n          required\n        />\n      </div>\n      \n      <div>\n        <label>Email:</label>\n        <input\n          type=\"email\"\n          name=\"email\"\n          value={formData.email}\n          onChange={handleChange}\n          required\n        />\n      </div>\n      \n      <div>\n        <label>Category:</label>\n        <select\n          name=\"category\"\n          value={formData.category}\n          onChange={handleChange}\n        >\n          <option value=\"general\">General</option>\n          <option value=\"support\">Support</option>\n          <option value=\"feedback\">Feedback</option>\n        </select>\n      </div>\n      \n      <div>\n        <label>Message:</label>\n        <textarea\n          name=\"message\"\n          value={formData.message}\n          onChange={handleChange}\n          rows=\"4\"\n        />\n      </div>\n      \n      <div>\n        <label>\n          <input\n            type=\"checkbox\"\n            name=\"subscribe\"\n            checked={formData.subscribe}\n            onChange={handleChange}\n          />\n          Subscribe to newsletter\n        </label>\n      </div>\n      \n      <button type=\"submit\">Submit</button>\n      \n      {/* Real-time preview */}\n      <div className=\"preview\">\n        <h3>Preview:</h3>\n        <p>Name: {formData.name}</p>\n        <p>Email: {formData.email}</p>\n        <p>Category: {formData.category}</p>\n        <p>Message: {formData.message}</p>\n        <p>Subscribed: {formData.subscribe ? 'Yes' : 'No'}</p>\n      </div>\n    </form>\n  );\n}\n\n// 2. Uncontrolled Component Example\nfunction UncontrolledForm() {\n  const nameRef = useRef(null);\n  const emailRef = useRef(null);\n  const messageRef = useRef(null);\n  const subscribeRef = useRef(null);\n  const categoryRef = useRef(null);\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    \n    // Get values from refs\n    const formData = {\n      name: nameRef.current.value,\n      email: emailRef.current.value,\n      message: messageRef.current.value,\n      subscribe: subscribeRef.current.checked,\n      category: categoryRef.current.value\n    };\n    \n    console.log('Form data:', formData);\n    \n    // Reset form\n    e.target.reset();\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>Name:</label>\n        <input\n          type=\"text\"\n          name=\"name\"\n          ref={nameRef}\n          defaultValue=\"\" // Initial value\n          required\n        />\n      </div>\n      \n      <div>\n        <label>Email:</label>\n        <input\n          type=\"email\"\n          name=\"email\"\n          ref={emailRef}\n          defaultValue=\"\"\n          required\n        />\n      </div>\n      \n      <div>\n        <label>Category:</label>\n        <select\n          name=\"category\"\n          ref={categoryRef}\n          defaultValue=\"general\"\n        >\n          <option value=\"general\">General</option>\n          <option value=\"support\">Support</option>\n          <option value=\"feedback\">Feedback</option>\n        </select>\n      </div>\n      \n      <div>\n        <label>Message:</label>\n        <textarea\n          name=\"message\"\n          ref={messageRef}\n          defaultValue=\"\"\n          rows=\"4\"\n        />\n      </div>\n      \n      <div>\n        <label>\n          <input\n            type=\"checkbox\"\n            name=\"subscribe\"\n            ref={subscribeRef}\n            defaultChecked={true}\n          />\n          Subscribe to newsletter\n        </label>\n      </div>\n      \n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n\n// 3. Hybrid Approach\nfunction HybridForm() {\n  // Some fields controlled, some uncontrolled\n  const [name, setName] = useState('');\n  const fileInputRef = useRef(null);\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    \n    // Get file from uncontrolled input\n    const file = fileInputRef.current.files[0];\n    \n    console.log('Name:', name);\n    console.log('File:', file?.name);\n    \n    // Submit logic\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      {/* Controlled input */}\n      <div>\n        <label>Name:</label>\n        <input\n          type=\"text\"\n          value={name}\n          onChange={(e) => setName(e.target.value)}\n          required\n        />\n      </div>\n      \n      {/* Uncontrolled file input */}\n      <div>\n        <label>Upload File:</label>\n        <input\n          type=\"file\"\n          ref={fileInputRef}\n          accept=\".pdf,.doc,.docx\"\n        />\n      </div>\n      \n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n\n// 4. File Input (Always Uncontrolled)\nfunction FileUpload() {\n  const fileInputRef = useRef(null);\n  const [preview, setPreview] = useState(null);\n  \n  const handleFileChange = (e) => {\n    const file = e.target.files[0];\n    \n    if (file) {\n      // Create preview\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        setPreview(reader.result);\n      };\n      reader.readAsDataURL(file);\n    } else {\n      setPreview(null);\n    }\n  };\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    const file = fileInputRef.current.files[0];\n    console.log('Uploading:', file?.name);\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>Choose File:</label>\n        <input\n          type=\"file\"\n          ref={fileInputRef}\n          onChange={handleFileChange}\n          accept=\"image/*\"\n        />\n      </div>\n      \n      {preview && (\n        <div>\n          <img src={preview} alt=\"Preview\" width=\"200\" />\n        </div>\n      )}\n      \n      <button type=\"submit\">Upload</button>\n    </form>\n  );\n}\n\n// 5. Custom Input with Both Modes\nfunction SmartInput({ value: controlledValue, onChange, defaultValue, ...props }) {\n  const isControlled = controlledValue !== undefined;\n  const [internalValue, setInternalValue] = useState(defaultValue || '');\n  \n  const value = isControlled ? controlledValue : internalValue;\n  \n  const handleChange = (e) => {\n    const newValue = e.target.value;\n    \n    if (!isControlled) {\n      setInternalValue(newValue);\n    }\n    \n    if (onChange) {\n      onChange(e);\n    }\n  };\n  \n  return (\n    <input\n      {...props}\n      value={value}\n      onChange={handleChange}\n    />\n  );\n}\n\n// 6. Form with Validation\nfunction ValidatedForm() {\n  const [formData, setFormData] = useState({\n    username: '',\n    password: ''\n  });\n  const [errors, setErrors] = useState({});\n  \n  const validate = () => {\n    const newErrors = {};\n    \n    if (!formData.username) newErrors.username = 'Username required';\n    if (!formData.password) newErrors.password = 'Password required';\n    if (formData.password.length < 6) newErrors.password = 'Password too short';\n    \n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    \n    if (validate()) {\n      console.log('Form valid:', formData);\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>Username:</label>\n        <input\n          value={formData.username}\n          onChange={(e) => setFormData({...formData, username: e.target.value})}\n          className={errors.username ? 'error' : ''}\n        />\n        {errors.username && <span>{errors.username}</span>}\n      </div>\n      \n      <div>\n        <label>Password:</label>\n        <input\n          type=\"password\"\n          value={formData.password}\n          onChange={(e) => setFormData({...formData, password: e.target.value})}\n          className={errors.password ? 'error' : ''}\n        />\n        {errors.password && <span>{errors.password}</span>}\n      </div>\n      \n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n\n// 7. Performance Comparison\nfunction PerformanceDemo() {\n  const [count, setCount] = useState(0);\n  \n  // This causes re-render on every keystroke\n  const ControlledInput = () => {\n    const [value, setValue] = useState('');\n    \n    return (\n      <input\n        value={value}\n        onChange={(e) => setValue(e.target.value)}\n        placeholder=\"Type fast (controlled)\"\n      />\n    );\n  };\n  \n  // This doesn't cause re-render\n  const UncontrolledInput = React.useRef(null);\n  \n  return (\n    <div>\n      <h1>Performance Test</h1>\n      <p>Render count: {count}</p>\n      <button onClick={() => setCount(c => c + 1)}>\n        Force Re-render\n      </button>\n      \n      <div>\n        <h3>Controlled Input (re-renders on type)</h3>\n        <ControlledInput />\n      </div>\n      \n      <div>\n        <h3>Uncontrolled Input (no re-render)</h3>\n        <input\n          ref={UncontrolledInput}\n          defaultValue=\"\"\n          placeholder=\"Type fast (uncontrolled)\"\n        />\n      </div>\n    </div>\n  );\n}\n\n// 8. Integration with Third-party Libraries\nfunction ThirdPartyIntegration() {\n  const editorRef = useRef(null);\n  \n  useEffect(() => {\n    // Initialize third-party editor\n    const editor = new ThirdPartyEditor(editorRef.current, {\n      initialValue: 'Hello World'\n    });\n    \n    // Cleanup\n    return () => editor.destroy();\n  }, []);\n  \n  const getContent = () => {\n    if (editorRef.current) {\n      const editor = editorRef.current.getInstance();\n      return editor.getContent();\n    }\n    return '';\n  };\n  \n  const handleSubmit = () => {\n    const content = getContent();\n    console.log('Editor content:', content);\n  };\n  \n  return (\n    <div>\n      <div ref={editorRef} />\n      <button onClick={handleSubmit}>Submit</button>\n    </div>\n  );\n}",
                        "components": [
                            {
                                "name": "Controlled Components",
                                "english": "React state controls form data",
                                "hinglish": "React state form data control karta hai",
                                "importance": "Single source of truth, validation",
                                "tip": "Use value prop with onChange handler"
                            },
                            {
                                "name": "Uncontrolled Components",
                                "english": "DOM stores form data",
                                "hinglish": "DOM form data store karta hai",
                                "importance": "Performance, third-party integration",
                                "tip": "Use defaultValue/defaultChecked with refs"
                            },
                            {
                                "name": "Hybrid Approach",
                                "english": "Mix controlled and uncontrolled",
                                "hinglish": "Controlled aur uncontrolled mix karo",
                                "importance": "Best of both worlds",
                                "tip": "Use controlled for simple fields, uncontrolled for files"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Aspect",
                                "Controlled",
                                "Uncontrolled"
                            ],
                            "rows": [
                                [
                                    "Data Source",
                                    "React State",
                                    "DOM"
                                ],
                                [
                                    "Updates",
                                    "Re-renders on change",
                                    "No re-render"
                                ],
                                [
                                    "Validation",
                                    "Real-time",
                                    "On submit only"
                                ],
                                [
                                    "Performance",
                                    "Slower for frequent updates",
                                    "Faster"
                                ],
                                [
                                    "Third-party",
                                    "Hard to integrate",
                                    "Easy integration"
                                ],
                                [
                                    "Form Reset",
                                    "Easy (setState)",
                                    "Native (form.reset())"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Use controlled for most forms",
                                "reason": "Better validation and UX",
                                "hinglish": "Better validation aur UX ke liye"
                            },
                            {
                                "practice": "Use uncontrolled for file inputs",
                                "reason": "File API requires DOM access",
                                "hinglish": "File API DOM access require karta hai"
                            },
                            {
                                "practice": "Support both modes in library components",
                                "reason": "Maximum flexibility for consumers",
                                "hinglish": "Consumers ke liye maximum flexibility"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Mixing controlled and uncontrolled incorrectly",
                                "solution": "Don't use value with defaultValue",
                                "hinglish": "Value aur defaultValue ek saath mat use karo"
                            },
                            {
                                "mistake": "Not handling file inputs properly",
                                "solution": "Always use uncontrolled for file inputs",
                                "hinglish": "File inputs ke liye hamesha uncontrolled use karo"
                            }
                        ]
                    }
                },
                {
                    "id": 24,
                    "title": "Performance Optimization: React.memo, useMemo, useCallback",
                    "english": "Optimize React performance by memoizing components, values, and functions to prevent unnecessary re-renders.",
                    "hinglish": "React performance optimize karo components, values aur functions ko memoize karke unnecessary re-renders se bachne ke liye.",
                    "examples": [
                        "const MemoizedComponent = React.memo(Component);",
                        "const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\nconst memoizedCallback = useCallback(() => {\n  doSomething(a, b);\n}, [a, b]);"
                    ],
                    "practice": [
                        {
                            "question": "What does React.memo do?",
                            "answer": "Memoizes component, prevents re-render if props haven't changed"
                        },
                        {
                            "question": "Difference between useMemo and useCallback?",
                            "answer": "useMemo memoizes values, useCallback memoizes functions"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// 1. React.memo for Component Memoization\nconst ExpensiveComponent = React.memo(function ExpensiveComponent({ data, onAction }) {\n  console.log('ExpensiveComponent rendered');\n  \n  // Simulate expensive computation\n  const processedData = () => {\n    let result = 0;\n    for (let i = 0; i < 1000000; i++) {\n      result += Math.sqrt(i) * Math.random();\n    }\n    return data.value + result;\n  };\n  \n  return (\n    <div className=\"expensive-component\">\n      <h3>Expensive Component</h3>\n      <p>Data: {data.value}</p>\n      <p>Processed: {processedData()}</p>\n      <button onClick={onAction}>Action</button>\n    </div>\n  );\n}, (prevProps, nextProps) => {\n  // Custom comparison function\n  // Return true if props are equal (skip re-render)\n  // Return false if props are different (re-render)\n  \n  // Only re-render if data.value changes\n  return prevProps.data.value === nextProps.data.value &&\n         prevProps.onAction === nextProps.onAction;\n});\n\n// 2. useMemo for Expensive Calculations\nfunction DataGrid({ rows, sortBy, filter }) {\n  console.log('DataGrid rendered');\n  \n  // Memoized sorting - only recalculates when rows or sortBy changes\n  const sortedRows = useMemo(() => {\n    console.log('Sorting rows...');\n    const startTime = performance.now();\n    \n    const sorted = [...rows].sort((a, b) => {\n      if (a[sortBy] < b[sortBy]) return -1;\n      if (a[sortBy] > b[sortBy]) return 1;\n      return 0;\n    });\n    \n    const endTime = performance.now();\n    console.log(`Sorting took ${endTime - startTime}ms`);\n    \n    return sorted;\n  }, [rows, sortBy]);\n  \n  // Memoized filtering - only recalculates when rows or filter changes\n  const filteredRows = useMemo(() => {\n    console.log('Filtering rows...');\n    \n    if (!filter) return sortedRows;\n    \n    return sortedRows.filter(row => \n      Object.values(row).some(value =>\n        String(value).toLowerCase().includes(filter.toLowerCase())\n      )\n    );\n  }, [sortedRows, filter]);\n  \n  // Memoized derived data\n  const stats = useMemo(() => {\n    return {\n      total: filteredRows.length,\n      average: filteredRows.reduce((sum, row) => sum + row.value, 0) / filteredRows.length || 0,\n      max: Math.max(...filteredRows.map(row => row.value)),\n      min: Math.min(...filteredRows.map(row => row.value))\n    };\n  }, [filteredRows]);\n  \n  // Memoized JSX for heavy rendering\n  const rowsList = useMemo(() => {\n    return filteredRows.map(row => (\n      <tr key={row.id}>\n        <td>{row.name}</td>\n        <td>{row.value}</td>\n        <td>{row.category}</td>\n      </tr>\n    ));\n  }, [filteredRows]);\n  \n  return (\n    <div className=\"data-grid\">\n      <h2>Data Grid (Total: {stats.total})</h2>\n      \n      <div className=\"stats\">\n        <p>Average: {stats.average.toFixed(2)}</p>\n        <p>Max: {stats.max}</p>\n        <p>Min: {stats.min}</p>\n      </div>\n      \n      <table>\n        <thead>\n          <tr>\n            <th>Name</th>\n            <th>Value</th>\n            <th>Category</th>\n          </tr>\n        </thead>\n        <tbody>\n          {rowsList}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\n// 3. useCallback for Function Stability\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n  const [items, setItems] = useState([]);\n  \n  // Without useCallback - new function on every render\n  const handleAddBad = () => {\n    setItems(prev => [...prev, `Item ${prev.length + 1}`]);\n  };\n  \n  // With useCallback - stable function reference\n  const handleAddGood = useCallback(() => {\n    setItems(prev => [...prev, `Item ${prev.length + 1}`]);\n  }, []); // Empty dependency array = never changes\n  \n  // With dependencies\n  const handleAddWithCount = useCallback(() => {\n    setItems(prev => [...prev, `Item ${prev.length + 1} (count: ${count})`]);\n  }, [count]); // Recreated when count changes\n  \n  // Memoized child component with stable callback\n  const memoizedChild = useMemo(() => (\n    <ChildComponent \n      onAdd={handleAddGood}\n      items={items}\n    />\n  ), [handleAddGood, items]);\n  \n  return (\n    <div>\n      <h1>Count: {count}</h1>\n      <button onClick={() => setCount(c => c + 1)}>\n        Increment Count\n      </button>\n      \n      <h2>Items: {items.length}</h2>\n      \n      {/* This re-renders every time because handleAddBad is new */}\n      <ChildComponent onAdd={handleAddBad} items={items} />\n      \n      {/* This doesn't re-render unnecessarily */}\n      <MemoizedChildComponent onAdd={handleAddGood} items={items} />\n      \n      {/* Memoized JSX */}\n      {memoizedChild}\n      \n      {/* List of items */}\n      <ul>\n        {items.map((item, index) => (\n          <li key={index}>{item}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nconst ChildComponent = React.memo(function ChildComponent({ onAdd, items }) {\n  console.log('ChildComponent rendered');\n  \n  return (\n    <div className=\"child\">\n      <button onClick={onAdd}>Add Item</button>\n      <p>Items in child: {items.length}</p>\n    </div>\n  );\n});\n\nconst MemoizedChildComponent = React.memo(ChildComponent);\n\n// 4. Performance Profiling Component\nfunction ProfilerDemo() {\n  const [renderCount, setRenderCount] = useState(0);\n  \n  const handleRender = useCallback(\n    (id, phase, actualDuration, baseDuration, startTime, commitTime) => {\n      console.log(`${id} ${phase} took ${actualDuration}ms`);\n    },\n    []\n  );\n  \n  return (\n    <React.Profiler id=\"ProfilerDemo\" onRender={handleRender}>\n      <div>\n        <h1>Performance Profiler</h1>\n        <p>Render count: {renderCount}</p>\n        <button onClick={() => setRenderCount(c => c + 1)}>\n          Force Re-render\n        </button>\n        \n        <OptimizedSection />\n        <UnoptimizedSection />\n      </div>\n    </React.Profiler>\n  );\n}\n\nfunction OptimizedSection() {\n  const [data, setData] = useState([1, 2, 3, 4, 5]);\n  \n  // Memoized calculation\n  const sum = useMemo(() => {\n    console.log('Calculating optimized sum...');\n    return data.reduce((a, b) => a + b, 0);\n  }, [data]);\n  \n  // Stable callback\n  const addNumber = useCallback(() => {\n    setData(prev => [...prev, prev.length + 1]);\n  }, []);\n  \n  return (\n    <div className=\"optimized\">\n      <h2>Optimized Section</h2>\n      <p>Sum: {sum}</p>\n      <button onClick={addNumber}>Add Number</button>\n      <MemoizedList data={data} />\n    </div>\n  );\n}\n\nfunction UnoptimizedSection() {\n  const [data, setData] = useState([1, 2, 3, 4, 5]);\n  \n  // Recalculates on every render\n  const sum = () => {\n    console.log('Calculating unoptimized sum...');\n    return data.reduce((a, b) => a + b, 0);\n  };\n  \n  // New function on every render\n  const addNumber = () => {\n    setData(prev => [...prev, prev.length + 1]);\n  };\n  \n  return (\n    <div className=\"unoptimized\">\n      <h2>Unoptimized Section</h2>\n      <p>Sum: {sum()}</p>\n      <button onClick={addNumber}>Add Number</button>\n      <UnoptimizedList data={data} />\n    </div>\n  );\n}\n\nconst MemoizedList = React.memo(function MemoizedList({ data }) {\n  console.log('MemoizedList rendered');\n  \n  return (\n    <ul>\n      {data.map(item => (\n        <li key={item}>Item {item}</li>\n      ))}\n    </ul>\n  );\n});\n\nfunction UnoptimizedList({ data }) {\n  console.log('UnoptimizedList rendered');\n  \n  return (\n    <ul>\n      {data.map(item => (\n        <li key={item}>Item {item}</li>\n      ))}\n    </ul>\n  );\n}\n\n// 5. When NOT to Optimize\nfunction OptimizationGuidelines() {\n  return (\n    <div>\n      <h2>When to Optimize:</h2>\n      <ul>\n        <li>Large lists or tables</li>\n        <li>Expensive calculations</li>\n        <li>Components that re-render often with same props</li>\n        <li>Functions passed to memoized children</li>\n      </ul>\n      \n      <h2>When NOT to Optimize:</h2>\n      <ul>\n        <li>Simple components</li>\n        <li>Cheap calculations</li>\n        <li>Components that always get new props</li>\n        <li>Early development phase</li>\n      </ul>\n      \n      <h2>Common Pitfalls:</h2>\n      <ul>\n        <li>Over-optimizing (premature optimization)</li>\n        <li>Creating new objects/arrays in dependency arrays</li>\n        <li>Forgetting dependencies in useCallback/useMemo</li>\n        <li>Memoizing everything (memory overhead)</li>\n      </ul>\n    </div>\n  );\n}\n\n// 6. useMemo for Configuration Objects\nfunction ConfigurableComponent({ theme, size, variant }) {\n  // Memoized config object - prevents unnecessary re-renders of child\n  const config = useMemo(() => ({\n    theme,\n    size,\n    variant,\n    // Complex derived configuration\n    styles: {\n      backgroundColor: theme === 'dark' ? '#333' : '#fff',\n      color: theme === 'dark' ? '#fff' : '#333',\n      fontSize: size === 'large' ? '18px' : '14px',\n      padding: size === 'large' ? '20px' : '10px',\n    },\n    // Computed properties\n    isActive: variant === 'active',\n    isDisabled: variant === 'disabled',\n  }), [theme, size, variant]);\n  \n  return <ChildWithConfig config={config} />;\n}\n\nconst ChildWithConfig = React.memo(function ChildWithConfig({ config }) {\n  return (\n    <div style={config.styles}>\n      <p>Theme: {config.theme}</p>\n      <p>Size: {config.size}</p>\n      <p>Variant: {config.variant}</p>\n    </div>\n  );\n});\n\n// 7. Custom Comparison for React.memo\nconst CustomMemoComponent = React.memo(\n  function CustomMemoComponent({ items, onSelect }) {\n    return (\n      <div>\n        {items.map(item => (\n          <button key={item.id} onClick={() => onSelect(item)}>\n            {item.name}\n          </button>\n        ))}\n      </div>\n    );\n  },\n  // Custom comparison function\n  (prevProps, nextProps) => {\n    // Compare items array length and IDs\n    if (prevProps.items.length !== nextProps.items.length) {\n      return false; // Re-render\n    }\n    \n    // Check if any item changed\n    for (let i = 0; i < prevProps.items.length; i++) {\n      if (prevProps.items[i].id !== nextProps.items[i].id) {\n        return false; // Re-render\n      }\n    }\n    \n    // Compare function reference\n    if (prevProps.onSelect !== nextProps.onSelect) {\n      return false; // Re-render\n    }\n    \n    return true; // Skip re-render\n  }\n);\n\n// 8. Performance Measurement Hook\nfunction usePerformance() {\n  const renderCount = useRef(0);\n  const lastRenderTime = useRef(performance.now());\n  \n  useEffect(() => {\n    renderCount.current += 1;\n    const now = performance.now();\n    const timeSinceLastRender = now - lastRenderTime.current;\n    lastRenderTime.current = now;\n    \n    console.log(`Render #${renderCount.current} took ${timeSinceLastRender.toFixed(2)}ms`);\n    \n    if (timeSinceLastRender > 16) { // 60fps threshold\n      console.warn('Slow render detected!');\n    }\n  });\n  \n  return { renderCount: renderCount.current };\n}\n\nfunction MeasuredComponent() {\n  const { renderCount } = usePerformance();\n  \n  return (\n    <div>\n      <p>This component has rendered {renderCount} times</p>\n    </div>\n  );\n}",
                        "components": [
                            {
                                "name": "React.memo",
                                "english": "Higher-order component for memoization",
                                "hinglish": "Memoization ke liye higher-order component",
                                "importance": "Prevents unnecessary component re-renders",
                                "tip": "Use for expensive components that get same props"
                            },
                            {
                                "name": "useMemo",
                                "english": "Memoizes expensive calculations",
                                "hinglish": "Expensive calculations ko memoize karta hai",
                                "importance": "Performance optimization for derived values",
                                "tip": "Use for heavy computations, object creation"
                            },
                            {
                                "name": "useCallback",
                                "english": "Memoizes function references",
                                "hinglish": "Function references ko memoize karta hai",
                                "importance": "Prevents child re-renders from new function props",
                                "tip": "Use for functions passed to memoized children"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Optimization",
                                "What it Memoizes",
                                "When to Use"
                            ],
                            "rows": [
                                [
                                    "React.memo",
                                    "Component output",
                                    "Expensive components with stable props"
                                ],
                                [
                                    "useMemo",
                                    "Computed values",
                                    "Heavy calculations, object creation"
                                ],
                                [
                                    "useCallback",
                                    "Function references",
                                    "Functions passed to memoized children"
                                ],
                                [
                                    "None",
                                    "Nothing",
                                    "Simple components, early development"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Measure before optimizing",
                                "reason": "Avoid premature optimization",
                                "hinglish": "Premature optimization se bacho"
                            },
                            {
                                "practice": "Use React DevTools Profiler",
                                "reason": "Identify real performance bottlenecks",
                                "hinglish": "Real performance bottlenecks identify karo"
                            },
                            {
                                "practice": "Optimize strategically",
                                "reason": "Focus on actual bottlenecks",
                                "hinglish": "Actual bottlenecks par focus karo"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Overusing memoization",
                                "solution": "Only optimize measurable bottlenecks",
                                "hinglish": "Sirf measurable bottlenecks optimize karo"
                            },
                            {
                                "mistake": "Creating new dependencies",
                                "solution": "Memoize objects/arrays in dependency arrays",
                                "hinglish": "Dependency arrays mein objects/arrays memoize karo"
                            }
                        ]
                    }
                }
            ]
        },
        {
            "level": "advanced",
            "order": 4,
            "topics": [
                {
                    "id": 25,
                    "title": "State Management Strategies",
                    "english": "Choose appropriate state management based on app complexity: Context for simple cases, Redux/Zustand for complex apps, Recoil for atomic updates, TanStack Query for server state.",
                    "hinglish": "App complexity ke hisaab se sahi state management choose karo: Simple cases ke liye Context, complex apps ke liye Redux/Zustand, atomic updates ke liye Recoil, server state ke liye TanStack Query.",
                    "examples": [
                        "// Context for theme\nconst ThemeContext = createContext();",
                        "// Redux Toolkit slice\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState,\n  reducers: { increment, decrement }\n});",
                        "// Zustand store\nconst useStore = create((set) => ({\n  count: 0,\n  increment: () => set(state => ({ count: state.count + 1 }))\n}));"
                    ],
                    "practice": [
                        {
                            "question": "When to use Context vs Redux?",
                            "answer": "Context: Simple global state (theme, auth). Redux: Complex state with middleware, devtools, time-travel."
                        },
                        {
                            "question": "What's TanStack Query for?",
                            "answer": "Server state management: caching, synchronization, background updates."
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// 1. Context API - Simple theme\nconst ThemeContext = createContext();\n\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  \n  const value = useMemo(() => ({\n    theme,\n    toggleTheme: () => setTheme(t => t === 'light' ? 'dark' : 'light')\n  }), [theme]);\n  \n  return (\n    <ThemeContext.Provider value={value}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\n// 2. Redux Toolkit - Complex app state\nimport { createSlice, configureStore } from '@reduxjs/toolkit';\n\nconst cartSlice = createSlice({\n  name: 'cart',\n  initialState: { items: [], total: 0 },\n  reducers: {\n    addItem: (state, action) => {\n      state.items.push(action.payload);\n      state.total += action.payload.price;\n    },\n    removeItem: (state, action) => {\n      const index = state.items.findIndex(item => item.id === action.payload);\n      if (index !== -1) {\n        state.total -= state.items[index].price;\n        state.items.splice(index, 1);\n      }\n    }\n  }\n});\n\nconst store = configureStore({\n  reducer: {\n    cart: cartSlice.reducer,\n    user: userSlice.reducer,\n    products: productsSlice.reducer\n  }\n});\n\n// 3. Zustand - Lightweight alternative\nimport create from 'zustand';\n\nconst useCartStore = create((set) => ({\n  items: [],\n  total: 0,\n  addItem: (item) => set(state => ({\n    items: [...state.items, item],\n    total: state.total + item.price\n  })),\n  removeItem: (id) => set(state => ({\n    items: state.items.filter(item => item.id !== id),\n    total: state.total - (state.items.find(item => item.id === id)?.price || 0)\n  }))\n}));\n\n// 4. Recoil - Atomic state\nimport { atom, selector } from 'recoil';\n\nconst cartState = atom({\n  key: 'cartState',\n  default: []\n});\n\nconst cartTotal = selector({\n  key: 'cartTotal',\n  get: ({get}) => {\n    const cart = get(cartState);\n    return cart.reduce((total, item) => total + item.price, 0);\n  }\n});\n\n// 5. TanStack Query - Server state\nimport { useQuery, useMutation } from '@tanstack/react-query';\n\nfunction ProductsPage() {\n  const { data: products, isLoading } = useQuery({\n    queryKey: ['products'],\n    queryFn: () => fetch('/api/products').then(res => res.json()),\n    staleTime: 5 * 60 * 1000 // 5 minutes\n  });\n  \n  const addToCart = useMutation({\n    mutationFn: (productId) => \n      fetch('/api/cart', { method: 'POST', body: JSON.stringify({ productId }) }),\n    onSuccess: () => {\n      // Invalidate and refetch\n      queryClient.invalidateQueries(['cart']);\n    }\n  });\n}",
                        "components": [
                            {
                                "name": "Context API",
                                "english": "Built-in React for simple global state",
                                "hinglish": "Simple global state ke liye built-in React",
                                "importance": "No external dependencies",
                                "tip": "Split contexts by domain to prevent re-renders"
                            },
                            {
                                "name": "Redux Toolkit",
                                "english": "Predictable state container with devtools",
                                "hinglish": "Devtools ke saath predictable state container",
                                "importance": "Complex apps with middleware needs",
                                "tip": "Use RTK Query for server state"
                            },
                            {
                                "name": "Zustand",
                                "english": "Minimal state management with hooks",
                                "hinglish": "Hooks ke saath minimal state management",
                                "importance": "Simplicity and performance",
                                "tip": "Great for small to medium apps"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Library",
                                "Bundle Size",
                                "Best For",
                                "Learning Curve"
                            ],
                            "rows": [
                                [
                                    "Context API",
                                    "0KB",
                                    "Simple global state",
                                    "Low"
                                ],
                                [
                                    "Redux Toolkit",
                                    "~30KB",
                                    "Complex enterprise apps",
                                    "Medium"
                                ],
                                [
                                    "Zustand",
                                    "~5KB",
                                    "Lightweight apps",
                                    "Low"
                                ],
                                [
                                    "Recoil",
                                    "~15KB",
                                    "Atomic state patterns",
                                    "Medium"
                                ],
                                [
                                    "TanStack Query",
                                    "~15KB",
                                    "Server state/caching",
                                    "Medium"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Start with Context, upgrade as needed",
                                "reason": "Avoid over-engineering early",
                                "hinglish": "Early over-engineering se bacho"
                            },
                            {
                                "practice": "Use TanStack Query for server state",
                                "reason": "Built-in caching and synchronization",
                                "hinglish": "Built-in caching aur synchronization"
                            },
                            {
                                "practice": "Group related state together",
                                "reason": "Reduce boilerplate and complexity",
                                "hinglish": "Boilerplate aur complexity reduce karo"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Using Redux for everything",
                                "solution": "Evaluate actual complexity needs",
                                "hinglish": "Actual complexity needs evaluate karo"
                            },
                            {
                                "mistake": "Mixing client and server state",
                                "solution": "Separate concerns clearly",
                                "hinglish": "Concerns clearly separate karo"
                            }
                        ]
                    }
                },
                {
                    "id": 26,
                    "title": "State Organization and Selectors",
                    "english": "Group related state, use selectors for derived data, normalize nested data to improve performance and maintainability.",
                    "hinglish": "Related state group karo, derived data ke liye selectors use karo, nested data normalize karo performance aur maintainability improve karne ke liye.",
                    "examples": [
                        "// Selector for derived state\nconst totalPrice = useSelector(state => \n  state.cart.items.reduce((sum, item) => sum + item.price, 0)\n);",
                        "// Normalized state\nconst normalizedProducts = {\n  byId: { 1: {...}, 2: {...} },\n  allIds: [1, 2]\n};"
                    ],
                    "practice": [
                        {
                            "question": "What are selectors?",
                            "answer": "Functions that compute derived state from store"
                        },
                        {
                            "question": "Why normalize state?",
                            "answer": "Avoids data duplication, easier updates, better performance"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// 1. Grouping related state\n// Bad: Scattered state\nconst [products, setProducts] = useState([]);\nconst [selectedProduct, setSelectedProduct] = useState(null);\nconst [productLoading, setProductLoading] = useState(false);\n\n// Good: Grouped state\nconst [productState, setProductState] = useState({\n  items: [],\n  selectedId: null,\n  loading: false,\n  error: null,\n  filters: { category: '', priceRange: [0, 1000] }\n});\n\n// 2. Selectors for derived data\nconst useProductSelectors = () => {\n  const products = useSelector(state => state.products.items);\n  const filters = useSelector(state => state.products.filters);\n  \n  // Memoized selector\n  const filteredProducts = useMemo(() => {\n    return products.filter(product => {\n      const matchesCategory = !filters.category || product.category === filters.category;\n      const matchesPrice = product.price >= filters.priceRange[0] && \n                          product.price <= filters.priceRange[1];\n      return matchesCategory && matchesPrice;\n    });\n  }, [products, filters]);\n  \n  const totalValue = useMemo(() => {\n    return filteredProducts.reduce((sum, product) => sum + product.price, 0);\n  }, [filteredProducts]);\n  \n  return { filteredProducts, totalValue };\n};\n\n// 3. Normalized state structure\nconst normalizedState = {\n  products: {\n    byId: {\n      'p1': { id: 'p1', name: 'Product 1', category: 'cat1', price: 100 },\n      'p2': { id: 'p2', name: 'Product 2', category: 'cat2', price: 200 }\n    },\n    allIds: ['p1', 'p2'],\n    selectedId: 'p1',\n    categories: ['cat1', 'cat2']\n  },\n  users: {\n    byId: {\n      'u1': { id: 'u1', name: 'John', cart: ['p1'] },\n      'u2': { id: 'u2', name: 'Jane', cart: ['p2'] }\n    },\n    allIds: ['u1', 'u2'],\n    currentUserId: 'u1'\n  }\n};\n\n// Selector to get user with products\nconst currentUserWithProducts = createSelector(\n  [state => state.users.byId[state.users.currentUserId],\n   state => state.products.byId],\n  (user, products) => ({\n    ...user,\n    cartItems: user.cart.map(productId => products[productId])\n  })\n);\n\n// 4. Modular state slices\n// cartSlice.js\nexport const cartSlice = createSlice({\n  name: 'cart',\n  initialState: {\n    items: [],\n    total: 0,\n    discount: 0\n  },\n  reducers: {\n    addItem: (state, action) => {\n      state.items.push(action.payload);\n      state.total += action.payload.price;\n    },\n    applyDiscount: (state, action) => {\n      state.discount = action.payload;\n    }\n  }\n});\n\n// Selectors for cart slice\nexport const selectCartItems = state => state.cart.items;\nexport const selectCartTotal = state => state.cart.total;\nexport const selectFinalPrice = createSelector(\n  [selectCartTotal, state => state.cart.discount],\n  (total, discount) => total - (total * discount / 100)\n);",
                        "components": [
                            {
                                "name": "State Grouping",
                                "english": "Group related state properties together",
                                "hinglish": "Related state properties ek saath group karo",
                                "importance": "Better organization and updates",
                                "tip": "Group by domain/feature"
                            },
                            {
                                "name": "Selectors",
                                "english": "Compute derived state from store",
                                "hinglish": "Store se derived state compute karo",
                                "importance": "Performance and reusability",
                                "tip": "Memoize expensive calculations"
                            },
                            {
                                "name": "State Normalization",
                                "english": "Flatten nested data structures",
                                "hinglish": "Nested data structures flatten karo",
                                "importance": "Avoids duplication, easier updates",
                                "tip": "Use byId and allIds pattern"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Structure",
                                "Performance",
                                "Maintainability"
                            ],
                            "rows": [
                                [
                                    "Flat state",
                                    "Fast reads",
                                    "Hard to maintain"
                                ],
                                [
                                    "Grouped state",
                                    "Good",
                                    "Better"
                                ],
                                [
                                    "Normalized",
                                    "Best",
                                    "Best"
                                ],
                                [
                                    "Nested",
                                    "Slow updates",
                                    "Worst"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Normalize deeply nested data",
                                "reason": "Up to 40% faster updates",
                                "hinglish": "40% tak faster updates"
                            },
                            {
                                "practice": "Use memoized selectors",
                                "reason": "Prevent unnecessary re-computations",
                                "hinglish": "Unnecessary re-computations se bacho"
                            },
                            {
                                "practice": "Keep state minimal",
                                "reason": "Store only necessary data",
                                "hinglish": "Sirf necessary data store karo"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Deeply nested state",
                                "solution": "Normalize with byId/allIds pattern",
                                "hinglish": "byId/allIds pattern se normalize karo"
                            },
                            {
                                "mistake": "Computing in render",
                                "solution": "Use selectors with memoization",
                                "hinglish": "Memoization ke saath selectors use karo"
                            }
                        ]
                    }
                },
                {
                    "id": 27,
                    "title": "Performance Optimization Patterns",
                    "english": "Apply lazy loading, code splitting, component splitting, and proper memoization to reduce bundle size and improve render performance.",
                    "hinglish": "Lazy loading, code splitting, component splitting aur proper memoization apply karo bundle size reduce karne aur render performance improve karne ke liye.",
                    "examples": [
                        "// Lazy loading\nconst HeavyComponent = React.lazy(() => import('./HeavyComponent'));",
                        "// Code splitting by route\nconst Home = lazy(() => import('./pages/Home'));",
                        "// Component splitting\nconst UserCard = ({ user }) => (\n  <div>\n    <UserAvatar user={user} />\n    <UserInfo user={user} />\n  </div>\n);"
                    ],
                    "practice": [
                        {
                            "question": "What does lazy loading improve?",
                            "answer": "Initial load time by loading code only when needed"
                        },
                        {
                            "question": "How does component splitting help?",
                            "answer": "Reduces re-renders by isolating changes to smaller components"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// 1. Lazy Loading Components\nconst Dashboard = React.lazy(() => import('./Dashboard'));\nconst Analytics = React.lazy(() => import('./Analytics'));\nconst Settings = React.lazy(() => import('./Settings'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<LoadingSpinner />}>\n      <Router>\n        <Route path=\"/dashboard\" element={<Dashboard />} />\n        <Route path=\"/analytics\" element={<Analytics />} />\n        <Route path=\"/settings\" element={<Settings />} />\n      </Router>\n    </Suspense>\n  );\n}\n\n// 2. Code Splitting by Feature\n// Preload on hover\nfunction FeatureButton() {\n  const [preloaded, setPreloaded] = useState(false);\n  \n  const preloadFeature = () => {\n    import('./HeavyFeature').then(() => setPreloaded(true));\n  };\n  \n  return (\n    <button \n      onClick={() => import('./HeavyFeature')}\n      onMouseEnter={preloadFeature}\n    >\n      Load Feature\n    </button>\n  );\n}\n\n// 3. Component Splitting\n// Before: Large component\nfunction UserProfile({ user }) {\n  return (\n    <div className=\"user-profile\">\n      <div className=\"avatar-section\">\n        <img src={user.avatar} />\n        <button>Change Avatar</button>\n      </div>\n      <div className=\"info-section\">\n        <h2>{user.name}</h2>\n        <p>{user.bio}</p>\n        <SocialLinks links={user.social} />\n      </div>\n      <div className=\"stats-section\">\n        <Stats data={user.stats} />\n      </div>\n    </div>\n  );\n}\n\n// After: Split components\nfunction UserProfile({ user }) {\n  return (\n    <div className=\"user-profile\">\n      <UserAvatar user={user} />\n      <UserInfo user={user} />\n      <UserStats stats={user.stats} />\n    </div>\n  );\n}\n\n// Memoized child components\nconst UserAvatar = React.memo(({ user }) => (\n  <div className=\"avatar-section\">\n    <img src={user.avatar} />\n    <button>Change Avatar</button>\n  </div>\n));\n\nconst UserInfo = React.memo(({ user }) => (\n  <div className=\"info-section\">\n    <h2>{user.name}</h2>\n    <p>{user.bio}</p>\n    <SocialLinks links={user.social} />\n  </div>\n));\n\n// 4. Virtualized Lists for large data\nimport { FixedSizeList } from 'react-window';\n\nfunction BigList({ items }) {\n  return (\n    <FixedSizeList\n      height={400}\n      width={300}\n      itemCount={items.length}\n      itemSize={50}\n    >\n      {({ index, style }) => (\n        <div style={style}>\n          {items[index].name}\n        </div>\n      )}\n    </FixedSizeList>\n  );\n}\n\n// 5. Performance Budgets\n// package.json scripts\n\"scripts\": {\n  \"build\": \"webpack --profile --json > stats.json\",\n  \"analyze\": \"webpack-bundle-analyzer stats.json\"\n}\n\n// 6. Optimizing Images\nfunction OptimizedImage({ src, alt }) {\n  return (\n    <img\n      src={src}\n      alt={alt}\n      loading=\"lazy\"\n      decoding=\"async\"\n      width=\"300\"\n      height=\"200\"\n    />\n  );\n}",
                        "components": [
                            {
                                "name": "Lazy Loading",
                                "english": "Load code only when needed",
                                "hinglish": "Code sirf jab zaroorat ho tab load karo",
                                "importance": "Reduces initial bundle size up to 50%",
                                "tip": "Use React.lazy() with Suspense"
                            },
                            {
                                "name": "Component Splitting",
                                "english": "Break large components into smaller ones",
                                "hinglish": "Large components ko smaller components mein break karo",
                                "importance": "Reduces re-renders by 25-40%",
                                "tip": "Split by responsibility"
                            },
                            {
                                "name": "Virtualization",
                                "english": "Render only visible items in lists",
                                "hinglish": "Lists mein sirf visible items render karo",
                                "importance": "Handles thousands of items efficiently",
                                "tip": "Use react-window or react-virtualized"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Technique",
                                "Bundle Reduction",
                                "Render Improvement"
                            ],
                            "rows": [
                                [
                                    "Code Splitting",
                                    "30-60%",
                                    "20% faster load"
                                ],
                                [
                                    "Component Splitting",
                                    "N/A",
                                    "25-40% less re-renders"
                                ],
                                [
                                    "Virtualization",
                                    "N/A",
                                    "90% less DOM nodes"
                                ],
                                [
                                    "Memoization",
                                    "N/A",
                                    "50% faster renders"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Set performance budgets",
                                "reason": "Prevent bundle size creep",
                                "hinglish": "Bundle size creep se bacho"
                            },
                            {
                                "practice": "Analyze bundle regularly",
                                "reason": "Identify optimization opportunities",
                                "hinglish": "Optimization opportunities identify karo"
                            },
                            {
                                "practice": "Implement progressive loading",
                                "reason": "Better perceived performance",
                                "hinglish": "Better perceived performance ke liye"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Splitting too aggressively",
                                "solution": "Balance between granularity and requests",
                                "hinglish": "Granularity aur requests ke beech balance rakho"
                            },
                            {
                                "mistake": "Not measuring impact",
                                "solution": "Use Lighthouse and React DevTools",
                                "hinglish": "Lighthouse aur React DevTools use karo"
                            }
                        ]
                    }
                },
                {
                    "id": 28,
                    "title": "Benchmarking and Measurement",
                    "english": "Use React DevTools Profiler, Lighthouse, and custom benchmarks to identify bottlenecks and measure optimization impact.",
                    "hinglish": "Bottlenecks identify karne aur optimization impact measure karne ke liye React DevTools Profiler, Lighthouse aur custom benchmarks use karo.",
                    "examples": [
                        "// React Profiler\n<Profiler id=\"App\" onRender={onRenderCallback}>\n  <App />\n</Profiler>",
                        "// Custom benchmark\nconsole.time('expensiveOperation');\n// ... operation\nconsole.timeEnd('expensiveOperation');",
                        "// Performance measurement\nconst start = performance.now();\n// component render\nconst duration = performance.now() - start;"
                    ],
                    "practice": [
                        {
                            "question": "What does React Profiler measure?",
                            "answer": "Component render times and re-render causes"
                        },
                        {
                            "question": "How to measure bundle size impact?",
                            "answer": "Use webpack-bundle-analyzer or source-map-explorer"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// 1. React DevTools Profiler\nfunction ProfilerDemo() {\n  const onRender = (id, phase, actualDuration, baseDuration) => {\n    console.log(`${id} ${phase} took ${actualDuration}ms`);\n    if (actualDuration > 16) {\n      console.warn('Slow render detected!');\n    }\n  };\n  \n  return (\n    <Profiler id=\"App\" onRender={onRender}>\n      <App />\n    </Profiler>\n  );\n}\n\n// 2. Custom Performance Hook\nfunction useRenderTimer(name) {\n  const renderCount = useRef(0);\n  const totalTime = useRef(0);\n  \n  useEffect(() => {\n    renderCount.current++;\n    const start = performance.now();\n    \n    return () => {\n      const duration = performance.now() - start;\n      totalTime.current += duration;\n      \n      if (duration > 16) {\n        console.warn(`${name} render #${renderCount.current} took ${duration.toFixed(2)}ms`);\n      }\n    };\n  });\n  \n  return { renderCount: renderCount.current, totalTime: totalTime.current };\n}\n\n// 3. Benchmarking Function\nfunction benchmark(operation, iterations = 1000) {\n  const times = [];\n  \n  for (let i = 0; i < iterations; i++) {\n    const start = performance.now();\n    operation();\n    times.push(performance.now() - start);\n  }\n  \n  const average = times.reduce((a, b) => a + b) / times.length;\n  const p95 = times.sort((a, b) => a - b)[Math.floor(times.length * 0.95)];\n  \n  return { average, p95, times };\n}\n\n// 4. Lighthouse CI Integration\n// .github/workflows/lighthouse.yml\nname: Lighthouse CI\non: [push]\njobs:\n  lighthouse:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v2\n      - run: npm install\n      - run: npm run build\n      - uses: treosh/lighthouse-ci-action@v3\n        with:\n          configPath: './lighthouserc.json'\n\n// 5. Bundle Size Tracking\n// package.json\n\"scripts\": {\n  \"build:analyze\": \"webpack --profile --json > stats.json\",\n  \"analyze\": \"webpack-bundle-analyzer stats.json\",\n  \"size\": \"bundlesize\"\n},\n\"bundlesize\": [\n  {\n    \"path\": \"./dist/*.js\",\n    \"maxSize\": \"100 kB\"\n  }\n]\n\n// 6. Performance Regression Tests\ndescribe('Performance', () => {\n  test('render within budget', () => {\n    const start = performance.now();\n    render(<ExpensiveComponent />);\n    const duration = performance.now() - start;\n    \n    expect(duration).toBeLessThan(50); // 50ms budget\n  });\n  \n  test('re-render optimization', () => {\n    const { rerender } = render(<MemoizedComponent />);\n    const firstRender = performance.now();\n    \n    rerender(<MemoizedComponent />);\n    const secondRender = performance.now() - firstRender;\n    \n    expect(secondRender).toBeLessThan(5); // Should be fast\n  });\n});\n\n// 7. Real User Monitoring (RUM)\nfunction usePerformanceMetrics() {\n  useEffect(() => {\n    const navigationTiming = performance.getEntriesByType('navigation')[0];\n    const paintTiming = performance.getEntriesByType('paint');\n    \n    console.log('Load metrics:', {\n      domContentLoaded: navigationTiming.domContentLoadedEventEnd,\n      load: navigationTiming.loadEventEnd,\n      firstPaint: paintTiming.find(p => p.name === 'first-paint')?.startTime,\n      firstContentfulPaint: paintTiming.find(p => p.name === 'first-contentful-paint')?.startTime\n    });\n    \n    // Send to analytics\n    sendToAnalytics({\n      event: 'performance_metrics',\n      data: { /* metrics */ }\n    });\n  }, []);\n}",
                        "components": [
                            {
                                "name": "React Profiler",
                                "english": "Built-in React performance measurement",
                                "hinglish": "Built-in React performance measurement",
                                "importance": "Identify slow components and re-renders",
                                "tip": "Use in development to find bottlenecks"
                            },
                            {
                                "name": "Lighthouse",
                                "english": "Google's web performance audit tool",
                                "hinglish": "Google ka web performance audit tool",
                                "importance": "Comprehensive performance scoring",
                                "tip": "Run in CI to prevent regressions"
                            },
                            {
                                "name": "Custom Benchmarks",
                                "english": "Specific performance tests",
                                "hinglish": "Specific performance tests",
                                "importance": "Measure optimization impact",
                                "tip": "Test before and after optimizations"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Tool",
                                "What it Measures",
                                "When to Use"
                            ],
                            "rows": [
                                [
                                    "React DevTools",
                                    "Component renders",
                                    "Development debugging"
                                ],
                                [
                                    "Lighthouse",
                                    "Overall page perf",
                                    "CI/CD and audits"
                                ],
                                [
                                    "WebPageTest",
                                    "Real-world conditions",
                                    "Production monitoring"
                                ],
                                [
                                    "Custom Benchmarks",
                                    "Specific operations",
                                    "Optimization validation"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Measure before optimizing",
                                "reason": "Focus on actual bottlenecks",
                                "hinglish": "Actual bottlenecks par focus karo"
                            },
                            {
                                "practice": "Set performance budgets",
                                "reason": "Prevent regression",
                                "hinglish": "Regression se bacho"
                            },
                            {
                                "practice": "Monitor in production",
                                "reason": "Real user experience matters",
                                "hinglish": "Real user experience matters"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Optimizing without measuring",
                                "solution": "Always profile first",
                                "hinglish": "Hamesha pehle profile karo"
                            },
                            {
                                "mistake": "Ignoring production metrics",
                                "solution": "Implement RUM",
                                "hinglish": "RUM implement karo"
                            }
                        ]
                    }
                }
            ]
        },
        {
            "level": "advanced",
            "order": 5,
            "topics": [
                {
                    "id": 29,
                    "title": "Testing with Jest and React Testing Library",
                    "english": "Write maintainable tests using AAA pattern, user-centric queries, and async utilities to test React components effectively.",
                    "hinglish": "AAA pattern, user-centric queries aur async utilities use karke maintainable tests likho React components effectively test karne ke liye.",
                    "examples": [
                        "// AAA Pattern\nimport { render, screen, fireEvent } from '@testing-library/react';\ntest('button click shows text', () => {\n  // Arrange\n  render(<Button>Click me</Button>);\n  \n  // Act\n  fireEvent.click(screen.getByText('Click me'));\n  \n  // Assert\n  expect(screen.getByText('Clicked!')).toBeInTheDocument();\n});",
                        "// Async test\nawait waitFor(() => {\n  expect(screen.getByText('Data loaded')).toBeInTheDocument();\n});"
                    ],
                    "practice": [
                        {
                            "question": "What is AAA pattern in testing?",
                            "answer": "Arrange (setup), Act (execute), Assert (verify)"
                        },
                        {
                            "question": "Which query methods to prefer in RTL?",
                            "answer": "ByRole, ByText, ByLabelText (user-centric) over implementation details"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// 1. Component Test\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  test('increments counter on click', () => {\n    // Arrange\n    render(<Counter />);\n    \n    // Act\n    const button = screen.getByRole('button', { name: /increment/i });\n    fireEvent.click(button);\n    \n    // Assert\n    expect(screen.getByText('Count: 1')).toBeInTheDocument();\n  });\n  \n  test('decrements counter', () => {\n    render(<Counter initialValue={5} />);\n    \n    fireEvent.click(screen.getByRole('button', { name: /decrement/i }));\n    \n    expect(screen.getByText('Count: 4')).toBeInTheDocument();\n  });\n});\n\n// 2. Form Test\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  test('submits form with data', async () => {\n    const mockSubmit = jest.fn();\n    render(<LoginForm onSubmit={mockSubmit} />);\n    \n    // Fill form\n    fireEvent.change(screen.getByLabelText(/email/i), {\n      target: { value: 'test@example.com' }\n    });\n    fireEvent.change(screen.getByLabelText(/password/i), {\n      target: { value: 'password123' }\n    });\n    \n    // Submit\n    fireEvent.click(screen.getByRole('button', { name: /login/i }));\n    \n    // Assert\n    expect(mockSubmit).toHaveBeenCalledWith({\n      email: 'test@example.com',\n      password: 'password123'\n    });\n  });\n});\n\n// 3. Async Test\nimport { waitFor } from '@testing-library/react';\nimport DataFetcher from './DataFetcher';\n\ndescribe('DataFetcher', () => {\n  test('loads and displays data', async () => {\n    // Mock fetch\n    global.fetch = jest.fn(() =>\n      Promise.resolve({\n        json: () => Promise.resolve([{ id: 1, name: 'Item 1' }])\n      })\n    );\n    \n    render(<DataFetcher />);\n    \n    // Wait for data\n    await waitFor(() => {\n      expect(screen.getByText('Item 1')).toBeInTheDocument();\n    });\n    \n    // Loading state\n    expect(screen.queryByText('Loading...')).not.toBeInTheDocument();\n  });\n});\n\n// 4. Mocking\njest.mock('./api', () => ({\n  fetchUser: jest.fn(() => Promise.resolve({ name: 'John' }))\n}));\n\n// 5. Custom Render with Providers\nimport { render as rtlRender } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport { store } from './store';\n\nconst render = (ui, options) => {\n  return rtlRender(ui, {\n    wrapper: ({ children }) => (\n      <Provider store={store}>\n        {children}\n      </Provider>\n    ),\n    ...options\n  });\n};\n\nexport { render };\n\n// 6. Snapshot Test\ntest('matches snapshot', () => {\n  const { asFragment } = render(<Component />);\n  expect(asFragment()).toMatchSnapshot();\n});",
                        "components": [
                            {
                                "name": "AAA Pattern",
                                "english": "Arrange, Act, Assert structure",
                                "hinglish": "Arrange, Act, Assert structure",
                                "importance": "Clean, readable tests",
                                "tip": "Keep each test focused on one behavior"
                            },
                            {
                                "name": "Screen Queries",
                                "english": "Query methods from testing-library",
                                "hinglish": "Testing-library se query methods",
                                "importance": "User-centric testing",
                                "tip": "Prefer getByRole, getByText over getByTestId"
                            },
                            {
                                "name": "Async Utilities",
                                "english": "waitFor, findBy queries",
                                "hinglish": "waitFor, findBy queries",
                                "importance": "Handle async operations",
                                "tip": "Use waitFor for side effects, findBy for elements"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Query Type",
                                "When to Use",
                                "Example"
                            ],
                            "rows": [
                                [
                                    "getByRole",
                                    "Interactive elements",
                                    "getByRole('button')"
                                ],
                                [
                                    "getByText",
                                    "Text content",
                                    "getByText('Submit')"
                                ],
                                [
                                    "getByLabelText",
                                    "Form inputs",
                                    "getByLabelText('Email')"
                                ],
                                [
                                    "getByTestId",
                                    "Last resort",
                                    "getByTestId('submit-btn')"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Test behavior, not implementation",
                                "reason": "Tests survive refactoring",
                                "hinglish": "Tests refactoring survive kare"
                            },
                            {
                                "practice": "Use userEvent over fireEvent",
                                "reason": "More realistic interactions",
                                "hinglish": "More realistic interactions"
                            },
                            {
                                "practice": "Keep tests independent",
                                "reason": "No test order dependency",
                                "hinglish": "Test order dependency nahi"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Testing implementation details",
                                "solution": "Focus on user interactions",
                                "hinglish": "User interactions par focus karo"
                            },
                            {
                                "mistake": "Not cleaning up mocks",
                                "solution": "Use afterEach cleanup",
                                "hinglish": "afterEach cleanup use karo"
                            }
                        ]
                    }
                },
                {
                    "id": 30,
                    "title": "Real Project Development",
                    "english": "Build production-ready projects with Material UI/Tailwind for UI, Redux for state, and structured 8-week learning timelines.",
                    "hinglish": "Production-ready projects banao Material UI/Tailwind se UI ke liye, Redux state ke liye, aur structured 8-week learning timelines ke saath.",
                    "examples": [
                        "// Material UI component\nimport { Button, TextField } from '@mui/material';\n<Button variant=\"contained\">Submit</Button>",
                        "// Tailwind component\n<button className=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\">\n  Click me\n</button>",
                        "// Redux with RTK Query\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\nconst api = createApi({\n  reducerPath: 'api',\n  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),\n  endpoints: (builder) => ({\n    getUsers: builder.query({ query: () => 'users' })\n  })\n});"
                    ],
                    "practice": [
                        {
                            "question": "When to use Material UI vs Tailwind?",
                            "answer": "Material UI: Quick prototyping, consistent design system. Tailwind: Custom designs, utility-first."
                        },
                        {
                            "question": "What to focus in 8-week React learning?",
                            "answer": "Week 1-2: Fundamentals, 3-4: Hooks/State, 5-6: Routing/Testing, 7-8: Real projects"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// 1. Material UI Project Structure\n// App.js\nimport { ThemeProvider, createTheme } from '@mui/material';\nimport { AppBar, Toolbar, Typography, Button, Container } from '@mui/material';\n\ntheme = createTheme({\n  palette: {\n    primary: { main: '#1976d2' },\n    secondary: { main: '#dc004e' }\n  }\n});\n\nfunction App() {\n  return (\n    <ThemeProvider theme={theme}>\n      <AppBar position=\"static\">\n        <Toolbar>\n          <Typography variant=\"h6\">My App</Typography>\n          <Button color=\"inherit\">Login</Button>\n        </Toolbar>\n      </AppBar>\n      <Container>\n        {/* App content */}\n      </Container>\n    </ThemeProvider>\n  );\n}\n\n// 2. Tailwind Project\n// tailwind.config.js\nmodule.exports = {\n  content: ['./src/**/*.{js,jsx}'],\n  theme: {\n    extend: {\n      colors: {\n        primary: '#3b82f6',\n        secondary: '#10b981'\n      }\n    }\n  }\n};\n\n// Component.js\nfunction Component() {\n  return (\n    <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\">\n      <div className=\"bg-white shadow rounded-lg p-6\">\n        <h2 className=\"text-2xl font-bold text-gray-900 mb-4\">Title</h2>\n        <p className=\"text-gray-600\">Content</p>\n        <button className=\"mt-4 bg-primary hover:bg-primary-dark text-white px-4 py-2 rounded\">\n          Action\n        </button>\n      </div>\n    </div>\n  );\n}\n\n// 3. Redux Toolkit Setup\n// store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport { api } from './services/api';\nimport authReducer from './features/auth/authSlice';\n\nconst store = configureStore({\n  reducer: {\n    [api.reducerPath]: api.reducer,\n    auth: authReducer\n  },\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware().concat(api.middleware)\n});\n\n// 4. 8-Week Learning Plan\n/*\nWeek 1-2: React Fundamentals\n- JSX, Components, Props, State\n- Event Handling, Conditional Rendering\n- Lists, Forms, Basic Hooks\n\nWeek 3-4: Advanced Concepts\n- useEffect, useRef, useContext\n- Custom Hooks, Error Boundaries\n- React Router, Code Splitting\n\nWeek 5-6: State Management & Testing\n- Redux Toolkit, Context API\n- Jest, React Testing Library\n- Integration Testing\n\nWeek 7-8: Real Projects\n- E-commerce App\n- Social Media Dashboard\n- Portfolio Website\n*/\n\n// 5. Project Structure\n/*\nsrc/\n  components/\n    Button/\n      Button.jsx\n      Button.test.jsx\n      Button.module.css\n  features/\n    auth/\n      authSlice.js\n      LoginForm.jsx\n    cart/\n      cartSlice.js\n      CartWidget.jsx\n  pages/\n    Home.jsx\n    Products.jsx\n  services/\n    api.js\n    auth.js\n  hooks/\n    useLocalStorage.js\n    useDebounce.js\n  utils/\n    helpers.js\n    constants.js\n*/\n\n// 6. Interview Preparation Focus\nconst interviewTopics = {\n  fundamentals: ['Virtual DOM', 'JSX', 'Components'],\n  hooks: ['useState', 'useEffect', 'useContext', 'Custom Hooks'],\n  state: ['Redux', 'Context', 'State Management'],\n  performance: ['Memoization', 'Code Splitting', 'Lazy Loading'],\n  testing: ['RTL', 'Jest', 'Testing Patterns']\n};\n\n// 7. Common Packages for Projects\nconst essentialPackages = {\n  ui: ['@mui/material', 'tailwindcss'],\n  state: ['@reduxjs/toolkit', 'react-query'],\n  routing: ['react-router-dom'],\n  forms: ['react-hook-form', 'formik'],\n  utils: ['axios', 'lodash', 'date-fns'],\n  testing: ['@testing-library/react', 'jest']\n};",
                        "components": [
                            {
                                "name": "UI Libraries",
                                "english": "Material UI, Tailwind CSS",
                                "hinglish": "Material UI, Tailwind CSS",
                                "importance": "Rapid development, consistent design",
                                "tip": "Choose based on design needs"
                            },
                            {
                                "name": "State Management",
                                "english": "Redux Toolkit with RTK Query",
                                "hinglish": "Redux Toolkit with RTK Query",
                                "importance": "Predictable state, server state caching",
                                "tip": "Use RTK Query for API calls"
                            },
                            {
                                "name": "Learning Timeline",
                                "english": "Structured 8-week plan",
                                "hinglish": "Structured 8-week plan",
                                "importance": "Systematic skill development",
                                "tip": "Build projects each week"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Library",
                                "Pros",
                                "Cons"
                            ],
                            "rows": [
                                [
                                    "Material UI",
                                    "Complete components, theming",
                                    "Bundle size, less custom"
                                ],
                                [
                                    "Tailwind",
                                    "Utility-first, highly custom",
                                    "Learning curve, verbose"
                                ],
                                [
                                    "Redux Toolkit",
                                    "DevTools, middleware",
                                    "Boilerplate, complexity"
                                ],
                                [
                                    "React Query",
                                    "Server state caching",
                                    "Learning curve"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Follow consistent project structure",
                                "reason": "Better collaboration and maintenance",
                                "hinglish": "Better collaboration aur maintenance"
                            },
                            {
                                "practice": "Build portfolio projects",
                                "reason": "Practical experience for interviews",
                                "hinglish": "Interviews ke liye practical experience"
                            },
                            {
                                "practice": "Master hooks thoroughly",
                                "reason": "Foundation of modern React",
                                "hinglish": "Modern React ki foundation"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "Jumping to advanced topics early",
                                "solution": "Master fundamentals first",
                                "hinglish": "Pehle fundamentals master karo"
                            },
                            {
                                "mistake": "Over-engineering small projects",
                                "solution": "Start simple, scale as needed",
                                "hinglish": "Simple start karo, scale as needed"
                            }
                        ]
                    }
                },
                {
                    "id": 31,
                    "title": "Deployment and Optimization",
                    "english": "Deploy optimized React apps with proper caching, middleware, bundle analysis, and performance monitoring.",
                    "hinglish": "Optimized React apps deploy karo proper caching, middleware, bundle analysis aur performance monitoring ke saath.",
                    "examples": [
                        "// Vercel configuration\n// vercel.json\n{\n  \"rewrites\": [{ \"source\": \"/(.*)\", \"destination\": \"/index.html\" }]\n}",
                        "// Cache headers middleware\napp.use((req, res, next) => {\n  res.setHeader('Cache-Control', 'public, max-age=31536000');\n  next();\n});",
                        "// Bundle analysis\n// package.json\n\"scripts\": {\n  \"analyze\": \"webpack-bundle-analyzer stats.json\"\n}"
                    ],
                    "practice": [
                        {
                            "question": "What cache headers for static assets?",
                            "answer": "Cache-Control: public, max-age=31536000 (1 year) for immutable assets"
                        },
                        {
                            "question": "How to reduce bundle size?",
                            "answer": "Code splitting, tree shaking, lazy loading, compression"
                        }
                    ],
                    "detailed_explanation": {
                        "example_code": "// 1. Deployment Configuration\n// vercel.json (Vercel)\n{\n  \"buildCommand\": \"npm run build\",\n  \"outputDirectory\": \"build\",\n  \"routes\": [\n    { \"handle\": \"filesystem\" },\n    { \"src\": \"/.*\", \"dest\": \"/index.html\" }\n  ],\n  \"headers\": [\n    {\n      \"source\": \"/static/(.*)\",\n      \"headers\": [\n        {\n          \"key\": \"Cache-Control\",\n          \"value\": \"public, max-age=31536000, immutable\"\n        }\n      ]\n    }\n  ]\n}\n\n// 2. Webpack Optimization\n// webpack.config.js\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      chunks: 'all',\n      cacheGroups: {\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name: 'vendors',\n          chunks: 'all'\n        }\n      }\n    },\n    minimize: true\n  },\n  performance: {\n    hints: 'warning',\n    maxAssetSize: 250000,\n    maxEntrypointSize: 250000\n  }\n};\n\n// 3. Express Server with Middleware\n// server.js\nimport express from 'express';\nimport compression from 'compression';\nimport helmet from 'helmet';\n\nconst app = express();\n\n// Security headers\napp.use(helmet({\n  contentSecurityPolicy: false\n}));\n\n// Compression\napp.use(compression());\n\n// Static files with caching\napp.use('/static', express.static('build/static', {\n  maxAge: '1y',\n  immutable: true\n}));\n\n// Serve React app\napp.get('*', (req, res) => {\n  res.sendFile(path.join(__dirname, 'build', 'index.html'));\n});\n\napp.listen(3000);\n\n// 4. Environment Configuration\n// .env.production\nREACT_APP_API_URL=https://api.example.com\nREACT_APP_GA_TRACKING_ID=UA-XXXXX\n\n// 5. CI/CD Pipeline\n// .github/workflows/deploy.yml\nname: Deploy\non:\n  push:\n    branches: [main]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v2\n      - run: npm ci\n      - run: npm test\n      - run: npm run build\n      - uses: vercel/action@v0.8.3\n        with:\n          vercel-token: ${{ secrets.VERCEL_TOKEN }}\n\n// 6. Bundle Analysis\n// package.json scripts\n\"scripts\": {\n  \"build:analyze\": \"webpack --profile --json > stats.json\",\n  \"analyze\": \"webpack-bundle-analyzer stats.json\"\n},\n\n// 7. Performance Budget\n// .bundlesizerc.json\n{\n  \"files\": [\n    {\n      \"path\": \"./build/static/js/*.js\",\n      \"maxSize\": \"150 kB\"\n    },\n    {\n      \"path\": \"./build/static/css/*.css\",\n      \"maxSize\": \"50 kB\"\n    }\n  ]\n}\n\n// 8. Monitoring Setup\n// monitoring.js\nimport { useEffect } from 'react';\nimport * as Sentry from '@sentry/react';\n\nexport function useMonitoring() {\n  useEffect(() => {\n    // Error tracking\n    window.addEventListener('error', (e) => {\n      Sentry.captureException(e.error);\n    });\n    \n    // Performance monitoring\n    const navigationTiming = performance.getEntriesByType('navigation')[0];\n    console.log('Page load time:', navigationTiming.loadEventEnd);\n  }, []);\n}",
                        "components": [
                            {
                                "name": "Deployment Platforms",
                                "english": "Vercel, Netlify, AWS, Heroku",
                                "hinglish": "Vercel, Netlify, AWS, Heroku",
                                "importance": "Easy deployment, scaling",
                                "tip": "Vercel/Netlify for SPAs, AWS for enterprise"
                            },
                            {
                                "name": "Optimization Techniques",
                                "english": "Code splitting, compression, caching",
                                "hinglish": "Code splitting, compression, caching",
                                "importance": "Faster load times, better UX",
                                "tip": "Implement progressive loading"
                            },
                            {
                                "name": "Monitoring & Analytics",
                                "english": "Error tracking, performance monitoring",
                                "hinglish": "Error tracking, performance monitoring",
                                "importance": "Production reliability",
                                "tip": "Set up alerts for critical errors"
                            }
                        ],
                        "comparison_table": {
                            "headers": [
                                "Platform",
                                "Best For",
                                "Cost"
                            ],
                            "rows": [
                                [
                                    "Vercel",
                                    "React/Next.js apps",
                                    "Free tier, pay for scaling"
                                ],
                                [
                                    "Netlify",
                                    "Static sites, SPAs",
                                    "Free tier, reasonable"
                                ],
                                [
                                    "AWS Amplify",
                                    "Full-stack apps",
                                    "Pay-as-you-go"
                                ],
                                [
                                    "Heroku",
                                    "Simple deployments",
                                    "Free to expensive"
                                ]
                            ]
                        },
                        "best_practices": [
                            {
                                "practice": "Implement proper caching",
                                "reason": "Up to 70% faster repeat visits",
                                "hinglish": "70% tak faster repeat visits"
                            },
                            {
                                "practice": "Use CDN for static assets",
                                "reason": "Global distribution, faster loads",
                                "hinglish": "Global distribution, faster loads"
                            },
                            {
                                "practice": "Monitor performance metrics",
                                "reason": "Identify and fix bottlenecks",
                                "hinglish": "Bottlenecks identify aur fix karo"
                            }
                        ],
                        "common_mistakes": [
                            {
                                "mistake": "No caching headers",
                                "solution": "Set Cache-Control for static assets",
                                "hinglish": "Static assets ke liye Cache-Control set karo"
                            },
                            {
                                "mistake": "Not analyzing bundle",
                                "solution": "Regular bundle analysis",
                                "hinglish": "Regular bundle analysis"
                            }
                        ]
                    }
                }
            ]
        }
    ]
}